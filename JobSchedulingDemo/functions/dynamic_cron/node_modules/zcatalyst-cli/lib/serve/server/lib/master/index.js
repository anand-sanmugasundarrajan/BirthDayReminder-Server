'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = __importDefault(require("express"));
const error_1 = __importDefault(require("../../../../error"));
const apig_matcher_1 = __importDefault(require("../../../../express_middlewares/apig-matcher"));
const auth_checker_1 = __importDefault(require("../../../../express_middlewares/auth-checker"));
const authenticator_1 = __importDefault(require("../../../../express_middlewares/authenticator"));
const cookie_parser_1 = __importDefault(require("../../../../express_middlewares/cookie-parser"));
const error_handler_1 = __importDefault(require("../../../../express_middlewares/error-handler"));
const logger_1 = __importDefault(require("../../../../express_middlewares/logger"));
const project_1 = __importDefault(require("../../../../express_middlewares/project"));
const unknown_req_proxy_1 = __importDefault(require("./unknown-req-proxy"));
const url_rewriter_1 = __importDefault(require("../../../../express_middlewares/url-rewriter"));
const runtime_store_1 = __importDefault(require("../../../../runtime-store"));
const constants_1 = require("../../../../util_modules/constants");
const js_1 = require("../../../../util_modules/js");
const logger_2 = require("../../../../util_modules/logger");
const project_2 = require("../../../../util_modules/project");
const option_1 = require("../../../../util_modules/option");
const server_js_1 = require("../../../../util_modules/server.js");
const utils_1 = require("./utils");
const appsail_1 = require("./appsail");
const web_client_1 = require("./web-client");
const functions_1 = require("./functions");
function spinUpMaster(listenPort, { otherServerDetails, appSailDetails }) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        if ((otherServerDetails && appSailDetails) || (!otherServerDetails && !appSailDetails)) {
            throw new error_1.default('Either functions/client or AppSail is need to start the master server. But both cannot use the same master', { exit: 2 });
        }
        const projectDetails = {
            id: (0, project_2.getProjectId)(),
            domain_prefix: (0, project_2.getDomainPrefix)(),
            domain: constants_1.ORIGIN.app.replace('https://', ''),
            key: (0, project_2.getDomainKey)(),
            env_name: (0, project_2.getEnvName)()
        };
        const rules = runtime_store_1.default.get('context.apig.local.config', -1);
        const customProxyUrl = (0, option_1.getOptionValue)('proxy');
        const app = (0, express_1.default)();
        let systemRoutes;
        const nonApigURL = ['/accounts', '/clientoauth', '/_wms', '/wmssrv'];
        app.use((0, logger_1.default)(appSailDetails));
        app.use(cookie_parser_1.default);
        app.use((0, project_1.default)(projectDetails));
        app.use(authenticator_1.default);
        !appSailDetails &&
            app.use(nonApigURL, (req, res) => {
                req.url = req.originalUrl;
                unknownProxy(req, res);
            });
        !appSailDetails &&
            app.use('*/.catalyst%2Freload-script.js', (req, res) => {
                var _a;
                req.url = '/.catalyst%2Freload-script.js';
                (_a = otherServerDetails === null || otherServerDetails === void 0 ? void 0 : otherServerDetails.client) === null || _a === void 0 ? void 0 : _a.forEach((clientDetails) => {
                    const appTarget = `http://127.0.0.1:${clientDetails.httpPort}/app/`;
                    proxy.web(req, res, {
                        target: appTarget,
                        changeOrigin: true
                    });
                });
            });
        if (rules !== -1 && !appSailDetails) {
            for (const [sourceURL, methodByConfig] of Object.entries(rules)) {
                const router = app.route(sourceURL);
                for (const [method, config] of Object.entries(methodByConfig)) {
                    if (config.system) {
                        if (systemRoutes === undefined) {
                            systemRoutes = {};
                        }
                        js_1.JS.set(systemRoutes, [sourceURL, method], config);
                    }
                    router[method]((req, res, next) => {
                        if (res.locals.apigRules === undefined) {
                            res.locals.apigRules = [];
                        }
                        res.locals.apigRules.push(Object.assign({ source_endpoint: sourceURL, params: req.params }, config));
                        next();
                    });
                }
            }
            app.use('/', apig_matcher_1.default, auth_checker_1.default, url_rewriter_1.default);
        }
        const proxy = (0, utils_1.createProxyServer)(listenPort);
        appSailDetails && ((_b = (_a = appSailDetails.target) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.catalyst_auth) === true
            ? proxy.on('proxyRes', (0, utils_1.proxyResponseHandler)({
                signInRedirect: appSailDetails.target.config.login_redirect || '/'
            }))
            : proxy.on('proxyRes', (0, utils_1.proxyResponseHandler)({ systemRoutes }));
        const proxyDestroyer = new server_js_1.ConnectionDestroyer(proxy);
        const unknownProxy = (0, unknown_req_proxy_1.default)(proxy, listenPort, customProxyUrl);
        otherServerDetails &&
            Object.keys(otherServerDetails).forEach((targ) => {
                var _a, _b, _c;
                switch (targ) {
                    case 'client': {
                        (_a = otherServerDetails.client) === null || _a === void 0 ? void 0 : _a.forEach((clientDetails) => (0, web_client_1.addWebClientRoutes)(app, clientDetails, proxy, unknownProxy));
                        break;
                    }
                    case 'server': {
                        (_b = otherServerDetails.server) === null || _b === void 0 ? void 0 : _b.forEach((serverDetail) => {
                            var _a;
                            app.use('/server/' + ((_a = serverDetail.target) === null || _a === void 0 ? void 0 : _a.name), (req, res) => {
                                proxy.web(req, res, {
                                    target: `http://127.0.0.1:${serverDetail.httpPort}`
                                });
                            });
                        });
                        break;
                    }
                    case 'functions': {
                        (_c = otherServerDetails.functions) === null || _c === void 0 ? void 0 : _c.forEach((fnDetails) => (0, functions_1.addFnRoutes)(app, fnDetails, proxy));
                        break;
                    }
                    default:
                        throw new error_1.default('Unknown type provided to master server ' + targ, {
                            exit: 2
                        });
                }
            });
        appSailDetails && (0, appsail_1.addAppSailRoutes)(app, appSailDetails, proxy, unknownProxy);
        app.use('/', (0, unknown_req_proxy_1.default)(proxy, listenPort, customProxyUrl));
        app.use(error_handler_1.default);
        const expressServer = app.listen(listenPort, '127.0.0.1').on('error', (err) => {
            if (proxy) {
                proxyDestroyer.destroy();
            }
            console.error(err);
        });
        const expressDestroyer = new server_js_1.ConnectionDestroyer(expressServer);
        expressServer.maxConnections = 100;
        process.on('SIGINT', () => expressDestroyer.destroy(false));
        expressServer.on('close', () => __awaiter(this, void 0, void 0, function* () {
            yield proxyDestroyer.destroy().catch((err) => (0, logger_2.debug)(err));
        }));
        expressServer.on('upgrade', (...upgradeParam) => {
            app.emit('upgrade', ...upgradeParam);
        });
        return expressServer;
    });
}
exports.default = spinUpMaster;
