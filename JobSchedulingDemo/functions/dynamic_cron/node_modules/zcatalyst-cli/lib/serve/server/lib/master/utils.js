"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.appsailInitJs = exports.proxyResponseHandler = exports.createProxyServer = exports.redirectByAuth = exports.removeSecure = void 0;
const http_1 = require("http");
const constants_1 = require("../../../../util_modules/constants");
const fs_1 = require("../../../../util_modules/fs");
const error_1 = __importDefault(require("../../../../error"));
const project_1 = require("../../../../util_modules/project");
const http_proxy_1 = require("http-proxy");
const logger_1 = require("../../../../util_modules/logger");
const iam_cookies = [
    'ZD_CSRF_TOKEN',
    '_iamadt_client',
    '_iambdt_client',
    '_zcsr_tmp',
    'iamcsr',
    'zalb',
    'stk',
    'JSESSIONID'
];
const isIamCookie = (cookieStr) => iam_cookies.some((val) => cookieStr.startsWith(val));
const removeSecure = (str) => str.replace(/;\s?Secure/i, '').replace(/;\s?SameSite=None/i, '');
exports.removeSecure = removeSecure;
const redirectByAuth = (req, res, redirectUrl) => {
    if (req.headers['cookie'] !== undefined) {
        res.writeHead(302, { Location: redirectUrl });
        res.end();
    }
    else {
        res.writeHead(302, { Location: '/app/' });
        res.end();
    }
};
exports.redirectByAuth = redirectByAuth;
const createProxyServer = (port) => {
    const proxy = (0, http_proxy_1.createProxyServer)({
        hostRewrite: `localhost:${port}`,
        protocolRewrite: 'http'
    })
        .on('error', (err, req, res) => {
        if (res.writableEnded) {
            return;
        }
        if (res instanceof http_1.ServerResponse) {
            res.writeHead(502, { 'Content-Type': 'json' });
        }
        res.end(JSON.stringify({ error: 'unable to serve the request' }));
        console.log();
        console.log('Unable to reach the servers to serve the request:  ', req.url);
        console.error(err);
    })
        .on('econnreset', (err, req, res, targetUrl) => {
        if (res.writableEnded) {
            return;
        }
        if (res instanceof http_1.ServerResponse) {
            res.writeHead(502, { 'Content-Type': 'json' });
        }
        res.end(JSON.stringify({ error: 'unable to serve the request. ECONNRESET.' }));
        console.log();
        console.log('Connection reset while trying to serve the request ', req.url);
        (0, logger_1.debug)('Connection reset from target URL : ', targetUrl);
        console.error(err);
    })
        .on('close', () => (0, logger_1.debug)('proxy closed'));
    return proxy;
};
exports.createProxyServer = createProxyServer;
const proxyResponseHandler = ({ systemRoutes, signInRedirect = '/app/local-redirect' }) => (proxyRes, req, res) => {
    var _a, _b;
    if (!req.url) {
        return;
    }
    proxyRes.headers['set-cookie'] = (_a = proxyRes.headers['set-cookie']) === null || _a === void 0 ? void 0 : _a.map((cookie) => {
        if (isIamCookie(cookie))
            return (0, exports.removeSecure)(cookie);
        return cookie;
    });
    if (req.url.startsWith('/baas') || req.url.startsWith('/__catalyst')) {
        if (req.url.includes('/signin-redirect')) {
            if (systemRoutes === undefined) {
                (0, exports.redirectByAuth)(req, res, signInRedirect);
                return;
            }
            const sourceRedirectUrl = Object.keys(systemRoutes).find((sourceUrl) => {
                const methodByConfig = systemRoutes ? systemRoutes[sourceUrl] : undefined;
                if (methodByConfig) {
                    return !!Object.values(methodByConfig).find((config) => {
                        return config.name === 'Login Redirect';
                    });
                }
                return false;
            });
            if (sourceRedirectUrl === undefined) {
                res.end('INVALID_URL');
                return;
            }
            (0, exports.redirectByAuth)(req, res, sourceRedirectUrl);
        }
        else if (req.url.includes('/logout')) {
            const set = proxyRes.headers['set-cookie'];
            if (set) {
                const result = set.map((cookie) => cookie.replace(new RegExp('Domain=[\\S^;]*', 'g'), 'Domain=localhost;'));
                proxyRes.headers['set-cookie'] = result;
            }
        }
    }
    else if (req.url.startsWith('/accounts') && req.url.includes('/signin')) {
        (_b = proxyRes.headers['set-cookie']) === null || _b === void 0 ? void 0 : _b.push('IAM_TEST_COOKIE=IAM_TEST_COOKIE; Domain=localhost; Path=/');
    }
};
exports.proxyResponseHandler = proxyResponseHandler;
const appsailInitJs = () => __awaiter(void 0, void 0, void 0, function* () {
    let initJsStr = yield fs_1.ASYNC.readFile(constants_1.TEMPLATE.init_js);
    if (!initJsStr) {
        throw new error_1.default('Unable to read the init_js file', { exit: 2 });
    }
    const feed = [(0, project_1.getProjectId)(), (0, project_1.getDomainKey)(), constants_1.ORIGIN.iamPortal, (0, project_1.getEnvId)()];
    Object.values(constants_1.PLACEHOLDER.init_js).forEach((holder, idx) => {
        initJsStr = initJsStr === null || initJsStr === void 0 ? void 0 : initJsStr.replace(new RegExp(holder, 'g'), feed[idx]);
    });
    return initJsStr;
});
exports.appsailInitJs = appsailInitJs;
