'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const util_1 = require("util");
const repl_server_1 = __importDefault(require("../repl-server"));
const ansi_colors_1 = require("ansi-colors");
const error_1 = __importDefault(require("../error"));
const fn_utils_1 = require("../fn-utils");
const runtime_store_1 = __importDefault(require("../runtime-store"));
const constants_1 = require("../util_modules/constants");
const fs_1 = require("../util_modules/fs");
const logger_js_1 = require("../util_modules/logger.js");
const option_1 = require("../util_modules/option");
const http_functions_1 = __importDefault(require("./dependencies/http-functions"));
const local_function_1 = __importDefault(require("./dependencies/local-function"));
const prepare_1 = __importDefault(require("./prepare"));
const fn_watcher_1 = __importDefault(require("../fn-watcher"));
const tunnel_server_1 = __importDefault(require("./dependencies/tunnel-server"));
const endpoints_1 = require("../endpoints");
exports.default = () => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const replServer = new repl_server_1.default({
        prompt: 'functions > ',
        writer: (output) => {
            if (output !== undefined) {
                if (output instanceof Promise) {
                    return '[cli] Function has been invoked\n';
                }
                if (output instanceof Error) {
                    return ansi_colors_1.bold.red('Error: ') + output.message;
                }
                return (0, util_1.inspect)(output);
            }
            return '';
        }
    });
    const httpServer = new http_functions_1.default({ repl: replServer });
    const tunnelServer = new tunnel_server_1.default(replServer);
    const projectRoot = runtime_store_1.default.get('project.root');
    yield (0, prepare_1.default)([constants_1.FN_TYPE.basic, constants_1.FN_TYPE.cron, constants_1.FN_TYPE.event, constants_1.FN_TYPE.integration, constants_1.FN_TYPE.job]);
    const targets = runtime_store_1.default
        .get('context.functions.targets', [])
        .filter((target) => {
        if (!target.valid) {
            (0, logger_js_1.warning)('target [' +
                target.name +
                '] is not a valid one reason : ' +
                target.failure_reason);
            Array.isArray(target.compilationError) &&
                target.compilationError.forEach((er) => (0, logger_js_1.error)(er));
            Array.isArray(target.compilationWarning) &&
                target.compilationWarning.forEach((warn) => (0, logger_js_1.warning)(warn));
        }
        return target.valid;
    });
    if (targets.length === 0) {
        throw new error_1.default('No functions are ready for serving', {
            exit: 0,
            errorId: 'SHELL-IDX-1'
        });
    }
    try {
        replServer.start();
        yield tunnelServer.startServer();
        const tunnelUrl = runtime_store_1.default.get('context.fn_shell.enable_tunnel', undefined);
        const _tunnelAPI = yield (0, endpoints_1.tunnelAPI)();
        if (tunnelUrl) {
            try {
                yield _tunnelAPI.enableTunnel(typeof tunnelUrl === 'string' ? tunnelUrl : undefined);
            }
            catch (er) {
                const _er = error_1.default.getErrorInstance(er);
                !replServer.closed && replServer.close();
                yield tunnelServer.stopServer();
                if (_er.status === 400) {
                    const data = (_a = _er.context) === null || _a === void 0 ? void 0 : _a.body.data;
                    throw new error_1.default('Unable to enable tunnel: ' + _er.message, {
                        exit: 1,
                        original: _er,
                        errorId: 'SHELL-IDX-2',
                        arg: [ansi_colors_1.italic.red(data.message + ''), ansi_colors_1.italic.red(data.error_code + '')]
                    });
                }
                throw new error_1.default('Unable to enable tunnel: ' + _er.message, {
                    exit: 2,
                    original: _er
                });
            }
            replServer.write(ansi_colors_1.green.bold('Tunneling enabled'));
        }
        const watchOpt = (0, option_1.getOptionValue)('watch');
        if (watchOpt === true) {
            (0, logger_js_1.info)();
            (0, logger_js_1.labeled)('DEPRECATED', `The ${ansi_colors_1.italic.bold('--watch')} option is deprecated. \nThe watch mode will be enabled by default. If you wish to disable it use the ${ansi_colors_1.italic.bold('--no-watch')} option. \nPlease execute ${(0, ansi_colors_1.bold)('catalyst functions:shell ' + (0, ansi_colors_1.italic)('--help'))} command for more usage details.`).WARN();
        }
        yield Promise.all(targets.map((target) => __awaiter(void 0, void 0, void 0, function* () {
            if (watchOpt !== false) {
                yield (0, fn_watcher_1.default)(target);
            }
            const localFn = new local_function_1.default(replServer, target);
            replServer.setContext(target.name, localFn.call());
            tunnelServer.addContext(target.id || target.name, localFn);
            target.localFn = localFn;
        })));
        if (runtime_store_1.default.get('context.port.http.' + constants_1.FN_TYPE.basic, false)) {
            yield httpServer.start();
        }
        yield replServer.wait();
        yield httpServer.stop();
        yield tunnelServer.stopServer().finally(() => __awaiter(void 0, void 0, void 0, function* () {
            if (!tunnelUrl) {
                return;
            }
            try {
                const tunnelDetails = yield _tunnelAPI.getTunnel();
                if (tunnelDetails.tunnel_status === 'Enabled') {
                    yield _tunnelAPI.disableTunnel();
                    (0, logger_js_1.info)();
                    (0, logger_js_1.info)(ansi_colors_1.green.bold('Tunneling disabled'));
                }
            }
            catch (er) {
                (0, logger_js_1.error)('Error disabling the tunnel');
                (0, logger_js_1.debug)(er);
            }
        }));
        yield Promise.all(targets.map((target) => __awaiter(void 0, void 0, void 0, function* () {
            if (target.localFn) {
                return target.localFn.shutdown();
            }
        })));
        yield fs_1.ASYNC.deleteDir((0, path_1.join)(projectRoot, constants_1.FOLDERNAME.build)).catch();
        fn_utils_1.fnUtils.common.executeHook({ prefix: 'post', command: 'serve' });
        (0, logger_js_1.info)();
        (0, logger_js_1.success)('shell complete');
    }
    catch (e) {
        !replServer.closed && replServer.close();
        yield Promise.all([
            fs_1.ASYNC.deleteDir((0, path_1.join)(projectRoot, constants_1.FOLDERNAME.build)).catch(),
            httpServer ? httpServer.stop() : undefined
        ]);
        throw e;
    }
});
