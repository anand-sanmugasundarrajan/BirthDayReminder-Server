"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Bucket_requester, _Bucket_cors, _Bucket_util;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bucket = void 0;
const constants_1 = __importDefault(require("../utils/constants"));
const object_1 = require("./object");
const validator_1 = require("../utils/validator");
const error_1 = require("../utils/error");
const stream_1 = require("stream");
const cors_1 = require("./cors");
const mime_types_1 = __importDefault(require("mime-types"));
const util_1 = require("./util");
const { REQ_METHOD, CREDENTIAL_USER, STRATUS_SUFFIX } = constants_1.default;
class Bucket {
    constructor(stratusInstance, bucket) {
        var _a;
        _Bucket_requester.set(this, void 0);
        _Bucket_cors.set(this, void 0);
        this.auth = true;
        _Bucket_util.set(this, void 0);
        __classPrivateFieldSet(this, _Bucket_requester, stratusInstance.requester, "f");
        if (typeof bucket === 'string') {
            this.bucketDetails = {
                bucket_name: bucket,
                bucket_url: ((_a = __classPrivateFieldGet(this, _Bucket_requester, "f").app) === null || _a === void 0 ? void 0 : _a.config.environment) == 'Development'
                    ? `https://${bucket}-development${STRATUS_SUFFIX}`
                    : `https://${bucket}${STRATUS_SUFFIX}`
            };
        }
        else {
            this.bucketDetails = bucket;
        }
        __classPrivateFieldSet(this, _Bucket_util, new util_1.Util(this), "f");
        __classPrivateFieldSet(this, _Bucket_cors, new cors_1.Cors(this), "f");
    }
    getAuthorizationClient() {
        return __classPrivateFieldGet(this, _Bucket_requester, "f");
    }
    /**
     * Get the bucket name.
     * @returns name of the bucket
     */
    getName() {
        return this.bucketDetails.bucket_name;
    }
    /**
     * List the objects and it's details in the bucket by pagination.
     * @param options ICatalystPagedObjectOptions to be applied for the list objects operation.
     * @returns ICatalystObjects.
     */
    listPagedObjects(_a = {}) {
        var { folderListing } = _a, options = __rest(_a, ["folderListing"]);
        return __awaiter(this, void 0, void 0, function* () {
            const param = {
                bucket_name: this.bucketDetails.bucket_name,
                folder_listing: folderListing || 'false',
                max_keys: options.maxKeys,
                prefix: options.prefix,
                continuation_token: options.continuationToken
            };
            const request = {
                method: REQ_METHOD.get,
                path: '/bucket/objects',
                qs: param,
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                catalyst: true,
                track: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            const objects = resp.data.data;
            const files = objects.contents.map((key) => new object_1.StratusObject(this, key));
            objects.contents = files;
            return objects;
        });
    }
    /**
     * List the objects and its details in the bucket as iterable.
     * @param prefix given prefixed objects to be returned.
     * @param maxKeys number of objects returned.
     * @returns AsyncGenerator<StratusObject, void>.
     */
    listIterableObjects({ prefix, maxKeys } = {}) {
        return __asyncGenerator(this, arguments, function* listIterableObjects_1() {
            let nextToken = undefined;
            do {
                const filesOutput = yield __await(this.listPagedObjects({
                    prefix,
                    maxKeys,
                    continuationToken: nextToken
                }));
                for (const key of filesOutput.contents) {
                    yield yield __await(key);
                }
                nextToken = filesOutput.next_continuation_token;
            } while (nextToken);
        });
    }
    /**
     * Get the details of the given bucket.
     * @returns ICatalystBucket.
     */
    getDetails() {
        return __awaiter(this, void 0, void 0, function* () {
            const request = {
                method: REQ_METHOD.get,
                path: '/bucket',
                qs: { bucket_name: this.bucketDetails.bucket_name },
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                catalyst: true,
                track: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.data.data[0];
        });
    }
    /**
     * Delete all the objects in the bucket
     * @returns boolean.
     */
    truncate() {
        return __awaiter(this, void 0, void 0, function* () {
            const param = {
                bucket_name: this.bucketDetails.bucket_name
            };
            const request = {
                method: REQ_METHOD.delete,
                path: '/bucket/truncate',
                qs: param,
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                catalyst: true,
                track: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.data.data;
        });
    }
    /**
     * Copy the given object to destination.
     * @param objectName name of the source object.
     * @param destObject name of the destination object.
     * @example
     * ```js
     * const sourceObject = 'sam/out/temp.txt';
     * const destObject = 'out/sam/temp.txt';
     * // invoke copy operation
     * const copyObjectRes = await bucket.copyObject(sourceObject, destObject);
     * console.log(copyObjectRes);
     * ```
     * @returns ICatalystUnzipRes.
     */
    copyObject(objectName, destObject) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyString)(objectName, 'object_name', true);
                (0, validator_1.isNonEmptyString)(destObject, 'dest_object', true);
            }, error_1.CatalystStratusError);
            const _param = {
                bucket_name: this.bucketDetails.bucket_name,
                object_key: objectName,
                destination: destObject
            };
            const request = {
                method: REQ_METHOD.post,
                path: '/bucket/object/copy',
                qs: _param,
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                catalyst: true,
                track: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.data.data;
        });
    }
    /**
     * Renames an existing object in the bucket.
     * @param objectName name of the source object.
     * @param destObject name of the destination object.
     * @example
     * ```js
     * const sourceObject = 'sam/out/temp.txt';
     * const destObject = 'out/sam/temp.txt';
     * // invoke rename operation
     * const renameObjectRes = await bucket.renameObjectObject(sourceObject, destObject);
     * console.log(renameObjectRes);
     * ```
     * @returns ICatalystObjectRenameRes.
     */
    renameObject(objectName, destObject) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyString)(objectName, 'object_name', true);
                (0, validator_1.isNonEmptyString)(destObject, 'dest_object', true);
            }, error_1.CatalystStratusError);
            const param = {
                bucket_name: this.bucketDetails.bucket_name,
                current_key: objectName,
                rename_to: destObject
            };
            const request = {
                method: REQ_METHOD.patch,
                path: '/bucket/object',
                qs: param,
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                catalyst: true,
                track: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.data.data;
        });
    }
    /**
     * Generate pre signed url for the given object
     * @param objectName name of the object.
     * @param urlAction provide the method based on the operation(put/get) performed.
     * @param signedUrlOptions to be applied when generating a pre signed url.
     * @example
     * ```js
     * const objectName = 'sam/out/temp.txt';
     * // signed url options
     * const options = {
     * 		'expiry_in_seconds': '3000',
     * 		'active_from':'23736279382'
     * }
     * // generate presigned url
     * const preSignedUrlRes = await bucket.generatePreSignedUrl(objectName, 'GET', options);
     * console.log(preSignedUrlRes);
     * ```
     * @returns { accessUrl: string }.
     */
    generatePreSignedUrl(objectName, urlAction, signedUrlOptions = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyString)(objectName, 'object_name', true);
                (0, validator_1.isNonEmptyString)(urlAction, 'url_action', true);
            }, error_1.CatalystStratusError);
            const param = {
                bucket_name: this.bucketDetails.bucket_name,
                object_key: objectName,
                expiry_in_seconds: signedUrlOptions.expiryIn || '',
                active_from: signedUrlOptions.activeFrom || '',
                version_id: signedUrlOptions.versionId || ''
            };
            const request = {
                method: urlAction,
                path: '/bucket/object/signed-url',
                qs: param,
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                catalyst: true,
                track: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.data.data;
        });
    }
    /**
     * Delete the given path and it's objects in the bucket
     * @param path to be deleted.
     * @example
     * ```js
     * const path = 'sam/';
     * // invoke delete path operation
     * const pathDeleteRes = await bucket.deletePath(path);
     * console.log(pathDeleteRes);
     * ```
     * @returns ICatalystObjectDetails.
     */
    deletePath(path) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyString)(path, 'object_path', true);
            }, error_1.CatalystStratusError);
            const param = { bucket_name: this.bucketDetails.bucket_name, prefix: path };
            const request = {
                method: REQ_METHOD.delete,
                path: '/bucket/object/prefix',
                qs: param,
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                catalyst: true,
                track: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.data.data;
        });
    }
    /**
     * Clear all the cached items in the bucket.
     * @param path path to be cleared.
     * @example
     * ```js
     * const path = ['sam', 'out/sam/temp.txt'];
     * // invoke purge cache operation
     * const purgeCacheRes = await bucket.purgeCache(path);
     * console.log(purgeCacheRes);
     * ```
     * @returns ICatalystObjectDetails.
     */
    purgeCache(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const param = {
                bucket_name: this.bucketDetails.bucket_name
            };
            const request = {
                method: REQ_METHOD.put,
                path: '/bucket/purge-cache',
                qs: param,
                data: path || [],
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                catalyst: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.data.data;
        });
    }
    /**
     * Download the object in the bucket.
     * @param objectName Name of the object.
     * @param getObjectOptions to be applied when download operation performed.
     *  @example
     * ```js
     * const objectName = 'out/sam/temp.txt';
     * const options = {
     * 		'versionId': 'bfjd673e2hgh2',
     * 		'range': '0-200'
     * }
     * // invoke object download operation
     * const getObjectRes = await bucket.getObject(objectName, options);
     * ```
     * @returns Readable object as stream.
     */
    getObject(objectName, { range, versionId } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyString)(objectName, 'object_name', true);
            }, error_1.CatalystStratusError);
            let url = this.bucketDetails.bucket_url;
            const signParam = (yield __classPrivateFieldGet(this, _Bucket_util, "f").getBucketSignature());
            if (signParam !== undefined) {
                url += '/_signed';
                this.auth = false;
            }
            const request = {
                method: REQ_METHOD.get,
                url: url + `/${encodeURI(objectName)}`,
                qs: Object.assign({ versionId: versionId }, signParam),
                type: "json" /* RequestType.JSON */,
                expecting: "raw" /* ResponseType.RAW */,
                catalyst: false,
                auth: this.auth,
                headers: range ? { Range: `bytes=${range}` } : {},
                external: true,
                user: CREDENTIAL_USER.user
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.data;
        });
    }
    /**
     * Delete a object in the bucket.
     * @param objectName Name of the object.
     * @param versionId Id of the object.
     * @param ttl time to live in seconds.
     * @example
     * ```js
     * const objectName = 'out/sam/temp.txt';
     * const options = {
     * 		'versionId': 'bfjd673e2hgh2',
     * 		'ttl': 300 // in seconds
     * }
     * // invoke object deletion operation
     * const deleteObjectRes = await bucket.deleteObject(objectName, options);
     * console.log(deleteObjectRes);
     * ```
     * @returns Record<string, string>.
     */
    deleteObject(objectName, { versionId, ttl } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyString)(objectName, 'object_name', true);
            }, error_1.CatalystStratusError);
            if (__classPrivateFieldGet(this, _Bucket_util, "f")._getUserType() !== 'admin' && __classPrivateFieldGet(this, _Bucket_util, "f")._getUserScope() !== 'admin') {
                const url = this.bucketDetails.bucket_url;
                yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                    (0, validator_1.isNonEmptyString)(objectName, 'object_name', true);
                }, error_1.CatalystStratusError);
                const request = {
                    method: REQ_METHOD.delete,
                    url: url + `/${encodeURI(objectName)}`,
                    qs: Object.assign({ ttl }, (versionId ? { versionId } : { deleteAllVersions: 'true' })),
                    type: "json" /* RequestType.JSON */,
                    expecting: "json" /* ResponseType.JSON */,
                    catalyst: false,
                    external: true,
                    track: true,
                    user: CREDENTIAL_USER.user
                };
                const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
                return { message: resp.resp.data };
            }
            const objects = [
                {
                    objectName,
                    versionId
                }
            ];
            return yield this.deleteObjects(objects, ttl);
        });
    }
    /**
     * Delete multiple objects in the bucket.
     * @param objects to be deleted.
     * @param ttl in seconds. The object will not be deleted immediately,
     * but only after the specified amount of time.
     * @example
     * ```js
     * const objects = [
     * 		{
     * 			'objectName': 'out1/sam1/temp1.txt',
     * 			'versionId': 'jsdbe6738y3bje'
     * 		},
     * 		{
     * 			'objectName': 'out2/sam2/temp2.txt',
     * 			'versionId': '34mnkejh89f9'
     * 		}
     * ];
     * const ttl = 1000;
     * // invoke objects deletion operation
     * const deleteObjectsRes = await bucket.deleteObjects(objects, ttl);
     * console.log(deleteObjectsRes);
     * ```
     * @returns Record<string, string>.
     */
    deleteObjects(objects, ttl) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyArray)(objects, 'objects', true);
            }, error_1.CatalystStratusError);
            const objectArr = objects.map((object) => ({
                key: object.objectName,
                version_id: object.versionId
            }));
            const objectsDetail = {
                objects: objectArr,
                ttl_in_seconds: ttl
            };
            const param = {
                bucket_name: this.bucketDetails.bucket_name
            };
            const request = {
                method: REQ_METHOD.put,
                path: '/bucket/object',
                data: objectsDetail,
                qs: param,
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                catalyst: true,
                track: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.data.data;
        });
    }
    /**
     * Upload an object to the bucket
     * @param objectName name of the object.
     * @param objectData body of the object.
     * @param uploadOptions to be applied while uploading object to the bucket.
     * @example
     * ```js
     * const objectName = 'out1/sam1/temp1.txt';
     * const objectData = fs.createReadStream('/user/alwind/sam/sample.txt');
     * const options = {
     * 		'overwritte': 'true',
     * 		'expiresAfter': '2000' // it will be deleted after the give time.
     * };
     * // upload an object
     * const putObjectRes = await bucket.putObject(objectName, objectData, options);
     * console.log(putObjectRes);
     * ```
     * @returns 'true' if upload success else return 'false'
     */
    putObject(objectName, objectData, uploadOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyString)(objectName, 'object_name', true);
                (0, validator_1.isNonNullValue)(objectData, 'object_body', true);
            }, error_1.CatalystStratusError);
            const extension = objectName.substring(objectName.lastIndexOf('.') + 1).toLowerCase();
            const contentType = mime_types_1.default.lookup(extension + '');
            let url = this.bucketDetails.bucket_url;
            const metaData = (uploadOptions === null || uploadOptions === void 0 ? void 0 : uploadOptions.metaData)
                ? Object.entries(uploadOptions === null || uploadOptions === void 0 ? void 0 : uploadOptions.metaData)
                    .map(([key, value]) => `${key}=${value};`)
                    .join('')
                : '';
            const params = Object.assign({ compress: 'false', 'Content-Type': contentType ? contentType : 'application/octet-stream', 'expires-after': (uploadOptions === null || uploadOptions === void 0 ? void 0 : uploadOptions.ttl) || '', overwrite: (uploadOptions === null || uploadOptions === void 0 ? void 0 : uploadOptions.overwrite) || '' }, (metaData ? { 'x-user-meta': metaData } : {}));
            const signParam = (yield __classPrivateFieldGet(this, _Bucket_util, "f").getBucketSignature());
            if (signParam !== undefined) {
                url += '/_signed';
                this.auth = false;
            }
            if (typeof objectData === 'string') {
                const bufferData = Buffer.from(objectData, 'utf-8');
                objectData = stream_1.Readable.from(bufferData);
            }
            if (objectData instanceof Buffer) {
                objectData = stream_1.Readable.from(objectData);
            }
            const request = {
                method: REQ_METHOD.put,
                url: url + `/${encodeURI(objectName)}`,
                data: objectData,
                qs: Object.assign({}, signParam),
                type: "raw" /* RequestType.RAW */,
                expecting: "json" /* ResponseType.JSON */,
                headers: params,
                catalyst: false,
                auth: this.auth,
                track: true,
                external: true,
                user: CREDENTIAL_USER.user
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.statusCode === 200;
        });
    }
    // /**
    //  * Download one or more objects in the bucket as zip.
    //  * @param objects to be downloaded.
    //  * @param prefix to download given prefixed objects.
    //  * @param continuationToken to get the next set of objects.
    //  * @returns
    //  */
    // async getMultipleObjects(
    // 	{
    // 		objects,
    // 		prefix
    // 	}: {
    // 		objects?: Array<string> | '*' | 'Top';
    // 		prefix?: Array<string>;
    // 	},
    // 	continuationToken?: string
    // ): Promise<{ data: IncomingMessage; continuationToken?: string }> {
    // 	const url = this.bucketDetails.bucket_url;
    // 	let inputData;
    // 	if (objects instanceof Array) {
    // 		const objList: Array<{ key: string }> = objects.map((key) => ({ key }));
    // 		inputData = { objects: objList, prefix };
    // 	} else {
    // 		inputData = { objects, prefix };
    // 	}
    // 	const request: IRequestConfig = {
    // 		method: REQ_METHOD.post,
    // 		url: url + `/?zip`,
    // 		data: inputData,
    // 		qs: { continuationToken },
    // 		type: RequestType.JSON,
    // 		expecting: ResponseType.RAW,
    // 		catalyst: false,
    // 		track: true,
    // 		external: true,
    // 		user: CREDENTIAL_USER.user
    // 	};
    // 	const resp = await this.#requester.send(request);
    // 	const finalRes = {
    // 		data: resp.data as IncomingMessage,
    // 		continuationToken: resp.headers['Continuation-Token'] as string
    // 	};
    // 	return finalRes;
    // }
    /**
     * Extract the zip object and upload all the files inside it as individual objects to the same bucket.
     * @param objectName name of the object.
     * @param destPath path to be unzipped.
     * @example
     * ```js
     * const objectName = 'out/sam/temp.zip';
     * const destPath = 'sam/out/';
     * // invoke zip extraction operation
     * const unzipObjectRes = await bucket.unzipObject(objectName, destPath);
     * console.log(unzipObjectRes);
     * ```
     * @returns ICatalystUnzipRes.
     */
    unzipObject(objectName, destPath) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyString)(objectName, 'object_name', true);
                (0, validator_1.isNonEmptyString)(destPath, 'dest_path', true);
            }, error_1.CatalystStratusError);
            const intrlparam = {
                bucket_name: this.bucketDetails.bucket_name,
                object_key: objectName,
                destination: destPath
            };
            const request = {
                method: REQ_METHOD.post,
                path: '/bucket/object/zip-extract',
                qs: intrlparam,
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                catalyst: true,
                track: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.data.data;
        });
    }
    /**
     * Get the status of the unzipObject operation.
     * @param objectName name of the object.
     * @param taskId Id to find the status of unzip task.
     * @example
     * ```js
     * const objectName = 'out/sam/temp.zip';
     * const taskId = '4384292001930123';
     * // get the status of zip extraction
     * const getUnzipStatusRes = await bucket.getUnzipStatus(objectName, taskId);
     * console.log(getUnzipStatusRes);
     * ```
     * @returns Record<string, string>.
     */
    getUnzipStatus(objectName, taskId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyString)(objectName, 'object_name', true);
                (0, validator_1.isNonEmptyString)(taskId, 'task_id', true);
            }, error_1.CatalystStratusError);
            const _param = {
                bucket_name: this.bucketDetails.bucket_name,
                object_key: objectName,
                task_id: taskId
            };
            const request = {
                method: REQ_METHOD.get,
                path: '/bucket/object/zip-extract/status',
                qs: _param,
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                catalyst: true,
                track: true,
                user: CREDENTIAL_USER.admin
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.data.data;
        });
    }
    /**
     * Get the CORS details of the bucket
     * @returns response of the get cors operation.
     */
    getCors() {
        return __awaiter(this, void 0, void 0, function* () {
            const corsDetails = __classPrivateFieldGet(this, _Bucket_cors, "f").getCors();
            return corsDetails;
        });
    }
    /**
     * Check whether a specific object is existing and also whether the given user has permission to access the object.
     * @param objectName Name that uniquely identifies the object within this bucket.
     * @param versionId Id of the object in case of a versioning enabled bucket.
     * @param throwErr throw error if the object doesn't exist.
     * @example
     * ```js
     * const objectName = 'out1/sam1/temp1.txt';
     * // check the availabilty of the object.
     * const headObjecttRes = await bucket.headObject(objectName, { versionId: 'dskjhgdfue627', throwErr: false });
     * console.log(headObjecttRes);
     * ```
     * @returns return 'true' if it exist else return false
     */
    headObject(objectName, { versionId, throwErr } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyString)(objectName, 'object_name', true);
            }, error_1.CatalystStratusError);
            try {
                const params = {
                    bucket_name: this.bucketDetails.bucket_name,
                    object_key: objectName,
                    version_id: versionId
                };
                const request = {
                    method: REQ_METHOD.head,
                    path: '/bucket/object',
                    qs: params,
                    type: "json" /* RequestType.JSON */,
                    expecting: "json" /* ResponseType.JSON */,
                    catalyst: true,
                    track: true,
                    user: CREDENTIAL_USER.admin
                };
                const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
                return resp.statusCode === 200;
            }
            catch (err) {
                if (!throwErr) {
                    const status = err.statusCode;
                    if (status === 404 || status === 403 || status === 400) {
                        return false;
                    }
                }
                throw err;
            }
        });
    }
    /**
     * Initiate the multipart upload.
     * @param objectName name of the object.
     * @returns details of the initiated object.
     */
    initiateMultipartUpload(objectName) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyString)(objectName, 'object_name', true);
            }, error_1.CatalystStratusError);
            const extension = objectName.substring(objectName.lastIndexOf('.') + 1).toLowerCase();
            const contentType = mime_types_1.default.lookup(extension + '');
            let url = this.bucketDetails.bucket_url;
            const signParam = (yield __classPrivateFieldGet(this, _Bucket_util, "f").getBucketSignature());
            if (signParam !== undefined) {
                url += '/_signed';
                this.auth = false;
            }
            const request = {
                method: REQ_METHOD.put,
                url: url + `/${encodeURI(objectName)}?multipart`,
                qs: Object.assign({}, signParam),
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                headers: {
                    compress: 'false',
                    'Content-Type': contentType ? contentType : 'application/octet-stream'
                },
                auth: this.auth,
                catalyst: false,
                external: true,
                user: CREDENTIAL_USER.user
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.data;
        });
    }
    /**
     * Upload the individual parts of the file, with a distinct part number.
     * @param objectName Name of the object.
     * @param uploadId Id of the particular upload.
     * @param objectData to be uploaded.
     * @param partNumber part number can be between 1 and 1000. It represent the ordering of the parts.
     * The parts can be uploaded in any order.
     * @returns return 'true' if completed successfully else return 'false'.
     */
    uploadPart(objectName, uploadId, objectData, partNumber, overwrite = 'false') {
        return __awaiter(this, void 0, void 0, function* () {
            if (objectData instanceof Buffer) {
                objectData = stream_1.Readable.from(objectData);
            }
            let url = this.bucketDetails.bucket_url;
            const signParam = yield __classPrivateFieldGet(this, _Bucket_util, "f").getBucketSignature();
            let param = {
                uploadId: uploadId,
                partNumber
            };
            if (signParam !== undefined) {
                url += '/_signed';
                this.auth = false;
                param = Object.assign({}, param, signParam);
            }
            const request = {
                method: REQ_METHOD.put,
                url: url + `/${encodeURI(objectName)}`,
                data: objectData,
                qs: param,
                type: "raw" /* RequestType.RAW */,
                headers: {
                    compress: 'false',
                    overwrite
                },
                expecting: "json" /* ResponseType.JSON */,
                catalyst: false,
                external: true,
                auth: this.auth,
                user: CREDENTIAL_USER.user
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.statusCode === 200;
        });
    }
    /**
     * Complete the multipart upload, after all parts are uploaded.
     * @param objectName Name of the object.
     * @param uploadId Id of the particular upload.
     * @returns return 'true' if completed successfully else return 'false'.
     */
    completeMultipartUpload(objectName, uploadId) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = this.bucketDetails.bucket_url;
            const signParam = (yield __classPrivateFieldGet(this, _Bucket_util, "f").getBucketSignature());
            if (signParam !== undefined) {
                url += '/_signed';
                this.auth = false;
            }
            const request = {
                method: REQ_METHOD.put,
                url: url + `/${encodeURI(objectName)}?completeMultipart`,
                qs: Object.assign({ uploadId: uploadId }, signParam),
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                catalyst: false,
                auth: this.auth,
                track: true,
                external: true,
                user: CREDENTIAL_USER.user
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.statusCode === 202;
        });
    }
    /**
     * Get a summary of the uploaded parts.
     * @param objectName Name of the object.
     * @param uploadId Id of the particular upload.
     * @returns ICatalystMultipartSummaryRes.
     */
    getMultipartUploadSummary(objectName, uploadId) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = this.bucketDetails.bucket_url;
            const signParam = (yield __classPrivateFieldGet(this, _Bucket_util, "f").getBucketSignature());
            if (signParam !== undefined) {
                url += '/_signed';
                this.auth = false;
            }
            const request = {
                method: REQ_METHOD.get,
                url: url + `/${encodeURI(objectName)}?multipartSummary`,
                qs: Object.assign({ uploadId }, signParam),
                type: "json" /* RequestType.JSON */,
                expecting: "json" /* ResponseType.JSON */,
                catalyst: false,
                auth: this.auth,
                track: true,
                external: true,
                user: CREDENTIAL_USER.user
            };
            const resp = yield __classPrivateFieldGet(this, _Bucket_requester, "f").send(request);
            return resp.data;
        });
    }
    /**
     * Get the object instance.
     *  @param objectName name of the object.
     * @returns instance of the object.
     */
    object(objectName) {
        if (!(0, validator_1.isNonEmptyString)(objectName)) {
            throw new error_1.CatalystStratusError('invalid-argument', 'Value provided for object_name must be a non empty String', objectName);
        }
        return new object_1.StratusObject(this, objectName);
    }
    toString() {
        return JSON.stringify(this.bucketDetails);
    }
    toJSON() {
        return this.bucketDetails;
    }
}
exports.Bucket = Bucket;
_Bucket_requester = new WeakMap(), _Bucket_cors = new WeakMap(), _Bucket_util = new WeakMap();
