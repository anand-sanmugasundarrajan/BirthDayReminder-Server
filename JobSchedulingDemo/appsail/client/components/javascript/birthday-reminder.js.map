{"version":3,"file":"components/javascript/birthday-reminder.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;AAIA;AAAA;AAEA;;AAEA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AAAA;AAEA;;;;;;;AA3RA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;AA8RA;;AA9RA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACfA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AA9WA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;AAiXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AA/XA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AA3vGA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8vGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AA5wGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAn7BA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;AAs7BA;AACA;;AAEA;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;AA3BA;;AA8BA;;AAEA;AACA;;AAEA;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;AArBA;;AAwBA;;AAEA;AACA;;AAEA;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;AArBA;;AAwBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAriCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;AArtBA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AAwtBA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAjwBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AA55IA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+5IA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;AAtDA;;AAyDA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAhLA;;AAmLA;;;;;AAKA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAjCA;;AAoCA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;;;;;AA5qLA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AARA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AAAA;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAAA;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;AAviHA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0iHA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAloHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAjzDA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAozDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAz2DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9FA;AACA;AACA;AACA;AACA;;AAEA;;AAeA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AAAA;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AAnnEA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsnEA;AACA;;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AA/HA;;AAkIA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAx1EA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAz/BA;AAAA;;AAAA;;;;;;;;;;AA4/BA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAnhCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClBA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAhNA;AAAA;;AAAA;;;;;;;;;AAmNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AA5NA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACXA;AACA;;AAEA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;;AAIA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;AAGA;;AAjVA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHA;AACA;;AAEA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;AAGA;;AA1gCA;;;;;;;;;;;;;ACHA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;AChmBA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;ACz2CA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACjhCA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://birthday-reminder/./components/javascript/birthday-reminder.js","webpack://birthday-reminder/./node_modules/@zoho/lyte-ui-component/components/javascript/lyte-button.js","webpack://birthday-reminder/./node_modules/@zoho/lyte-ui-component/components/javascript/lyte-calendar.js","webpack://birthday-reminder/./node_modules/@zoho/lyte-ui-component/components/javascript/lyte-carousel.js","webpack://birthday-reminder/./node_modules/@zoho/lyte-ui-component/components/javascript/lyte-checkbox.js","webpack://birthday-reminder/./node_modules/@zoho/lyte-ui-component/components/javascript/lyte-dropdown.js","webpack://birthday-reminder/./node_modules/@zoho/lyte-ui-component/components/javascript/lyte-input.js","webpack://birthday-reminder/./node_modules/@zoho/lyte-ui-component/components/javascript/lyte-modal.js","webpack://birthday-reminder/./node_modules/@zoho/lyte-ui-component/components/javascript/lyte-table.js","webpack://birthday-reminder/./node_modules/@zoho/lyte-ui-component/components/javascript/lyte-tooltip.js","webpack://birthday-reminder/./node_modules/@zoho/lyte-ui-component/components/javascript/lyte-wormhole.js","webpack://birthday-reminder/./node_modules/@zoho/lyte-ui-component/mixins/lyte-table-sortable.js","webpack://birthday-reminder/./node_modules/@zoho/lyte-ui-component/mixins/lyte-table-utils.js","webpack://birthday-reminder/./node_modules/@zoho/lyte-ui-component/plugins/lyte-moment-additional.js","webpack://birthday-reminder/./node_modules/@zoho/lyte-ui-component/plugins/lyte-moment-basic.js","webpack://birthday-reminder/./node_modules/@zoho/lyte-ui-component/plugins/lyte-scrollbar.js","webpack://birthday-reminder/./node_modules/@zoho/lyte-ui-component/plugins/lyte-search.js"],"sourcesContent":["import './../../node_modules/@zoho/lyte-ui-component/components/javascript/lyte-carousel.js';\nimport './../../node_modules/@zoho/lyte-ui-component/components/javascript/lyte-checkbox.js';\nimport './../../node_modules/@zoho/lyte-ui-component/components/javascript/lyte-table.js';\nimport './../../node_modules/@zoho/lyte-ui-component/components/javascript/lyte-input.js';\nimport './../../node_modules/@zoho/lyte-ui-component/components/javascript/lyte-button.js';\nimport './../../node_modules/@zoho/lyte-ui-component/components/javascript/lyte-modal.js';\nimport { Component } from \"./../component.js\";\n\nfunction prop(type, options) {\n    return {\n        type: type,\n        default: options.default\n    };\n}\n\nclass BirthdayReminder extends Component {\n    constructor() {\n        super();\n    }\n\n    data() {\n        return {\n            headerJSON: prop('array', {\n                default: [\n                    { name: 'Name', body: 'name' },\n                    { name: 'Message', body: 'message' },\n                    { name: 'Birthday', body: 'birthday' },\n                    { name: 'Email', body: 'email' }\n                ]\n            }),\n            reminders: prop('array', { default: [] }),\n            name: prop('string', { default: '' }),\n            message: prop('string', { default: '' }),\n            email: prop('string', { default: '' }),\n            birthday: prop('string', { default: '' }),\n            template: prop('string', { default: '' }),\n            editReminder: prop('object', { default: {} }),\n            deleteRemind: prop('object', { default: {} }),\n            isEditModalVisible: prop('boolean', { default: false }),\n            isDeleteModalVisible: prop('boolean', { default: false }),\n            isSignOutModalVisible: prop('boolean', { default: false }),\n            maxDate: prop('string', { default: this.getCurrentDate() }),\n            selectedButton: prop('string', { default: null }),\n            selectTemplate: prop('string', { default: '1636000000007022' }),\n            userName: prop('string', { default: '' }),\n            userId: prop('string', { default: null }),\n            userType: prop('string',{ default: null})\n        };\n    }\n\n    getCurrentDate() {\n        const today = new Date();\n        const yyyy = today.getFullYear();\n        const mm = String(today.getMonth() + 1).padStart(2, '0');\n        const dd = String(today.getDate()).padStart(2, '0');\n        return `${yyyy}-${mm}-${dd}`;\n    }\n\n    didConnect() {\n        this.loadReminders();\n    }\n    async loadReminders() {\n        try {\n            // @ts-ignore\n            const userManagement = catalyst.auth;\n            \n            const response = await userManagement.isUserAuthenticated();\n            this.setData('userId', response.content.user_id);\n            this.setData('userType', response.content.role_details.role_name);\n            const formData = {\n                userId: this.getData('userId'),\n                userType: this.getData('userType')\n             };\n                const reminderResponse = await fetch('https://appsail-10091141877.development.catalystappsail.com/execute/getReminder', {\n                method: 'POST',  \n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(formData)\n            });\n    \n            if (!reminderResponse.ok) {\n                throw new Error(`HTTP error! Status: ${reminderResponse.status}`);\n            }\n            const data = await reminderResponse.json();\n            this.setData('reminders', data);\n    \n        } catch (error) {\n            console.error('Error loading reminders:', error);\n        }\n    }\n    \n    \n\n    static methods() {\n        return {};\n    }\n\n    static actions() {\n        return {\n\n            updateReminder() {\n                const updatedData = {\n                    id: this.getData('editReminder').id,\n                    name: this.getData('editReminder').name,\n                    birthday: this.getData('editReminder').birthday,\n                    message: this.getData('editReminder').message,\n                    email: this.getData('editReminder').email,\n                    template: this.getData('selectTemplate')\n                };\n\n                fetch('https://appsail-10091141877.development.catalystappsail.com/execute/updateReminder', {\n                    method: 'PUT',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({ method: 'updateReminder', ...updatedData })\n                }).then(response => response.json())\n                    .then(data => {\n                        // @ts-ignore\n                        document.getElementById(\"editReminderModal\").ltProp('show', false);\n                        alert('Reminder updated successfully!');\n                        this.loadReminders();\n                        this.setData('isEditModalVisible', false);\n                    }).catch(error => {\n                        console.error('Error updating reminder:', error);\n                        alert('Failed to update reminder.');\n                    });\n\n            },\n\n            deleteReminder() {\n                const data = {\n                    id: this.getData('deleteRemind').id\n                };\n\n                fetch('https://appsail-10091141877.development.catalystappsail.com/execute/deleteReminder', {\n                    method: 'DELETE',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({ ...data })\n                }).then(response => response.json())\n                    .then(data => {\n                        alert('Reminder deleted successfully!');\n                        // @ts-ignore\n                        document.getElementById(\"deleteReminderModal\").ltProp('show', false);\n                        this.setData('isDeleteModalVisible', false);\n                        this.loadReminders();\n                    }).catch(error => {\n                        console.error('Error deleting reminder:', error);\n                        alert('Failed to delete reminder.');\n                    });\n            },\n            signOut(){\n                const directURL = 'https://appsail-10091141877.development.catalystappsail.com/__catalyst/auth/signup'\n                // @ts-ignore\n                catalyst.auth.signOut(directURL);\n            },\n            signIntoZoho(){\n                const directURL = 'https://appsail-10091141877.development.catalystappsail.com/__catalyst/auth/login'\n                // @ts-ignore\n                catalyst.auth.signOut(directURL);\n            },\n\n\n\n            toggleAutoSend(id, checked) {\n                fetch('https://appsail-10091141877.development.catalystappsail.com/execute/toggleAutoSend', {\n                    method: 'PATCH',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({ id: id, status: checked ? 'enable' : 'disable' })\n                }).then(response => response.json())\n                    .then(data => {\n                        console.log('Auto-send toggled successfully!');\n                        this.loadReminders();\n                    }).catch(error => {\n                        console.error('Error toggling auto-send:', error);\n                        alert('Failed to toggle auto-send.');\n                    });\n            },\n\n            openEditModal(id, name, birthday, message, email) {\n                this.setData('editReminder', { id, name, birthday, message, email });\n                // @ts-ignore\n                document.getElementById(\"editReminderModal\").ltProp('show', true);\n                // this.$L(\"#editReminderModal\")[0].ltProp('show', true)\n            },\n            openSignOutModal() {\n                // @ts-ignore\n                document.getElementById(\"signOut-modal\").ltProp('show', true);\n            },\n\n            closeEditModal() {\n                this.setData('isEditModalVisible', false);\n                // @ts-ignore\n                document.getElementById(\"editReminderModal\").ltProp('show', false);\n                // this.$L(\"#editReminderModal\")[0].ltProp('show', false)\n\n            },\n            openDeleteModal(id) {\n                this.setData('deleteRemind', { id });\n                // @ts-ignore\n                document.getElementById(\"deleteReminderModal\").ltProp('show', true);\n\n\n            },\n            closeDeleteModal() {\n                this.setData('deleteReminderModal', false);\n                // @ts-ignore\n                document.getElementById(\"deleteReminderModal\").ltProp('show', false);\n            },\n            async submitForm(event) {\n                if (event) event.preventDefault();\n            \n                try {\n                    const name = this.getData('name');\n                    const birthday = this.getData('birthday');\n                    const message = this.getData('message');\n                    const email = this.getData('email');\n                    const userId = this.getData('userId');\n                    const userType = this.getData('userType');\n            \n                    const carouselElement = document.querySelector('.carousel-item.lyteActive');\n                    if (!carouselElement) {\n                        alert('Carousel element not found.');\n                        return;\n                    }\n            \n                    const template = carouselElement.getAttribute('data-template-id');\n                    if (!template) {\n                        alert('No template ID found for the active carousel item.');\n                        return;\n                    }\n            \n                    const today = new Date();\n                    const yyyy = today.getFullYear();\n                    const mm = String(today.getMonth() + 1).padStart(2, '0');\n                    const dd = String(today.getDate()).padStart(2, '0');\n                    const now = `${yyyy}-${mm}-${dd}`;\n            \n                    if (now < birthday) {\n                        alert('Enter a valid past date');\n                        return;\n                    }\n            \n                    // Email validation logic\n                    const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n                    const isValidEmail = re.test(String(email).toLowerCase());\n            \n                    if (!isValidEmail) {\n                        alert('Invalid email format');\n                        return;\n                    }\n            \n                    if (!name || !message || !email || !birthday || !template) {\n                        alert('All fields are required');\n                        return;\n                    }\n            \n                    const formData = {\n                        name,\n                        birthday,\n                        message,\n                        email,\n                        template, \n                        userId,\n                        userType\n                    };\n            \n                    const response = await fetch('https://appsail-10091141877.development.catalystappsail.com/execute/insertReminder', {\n                        method: 'POST',\n                        headers: {\n                            'Content-Type': 'application/json'\n                        },\n                        body: JSON.stringify(formData)\n                    });\n            \n                    if (!response.ok) {\n                        throw new Error(`HTTP error! Status: ${response.status}`);\n                    }\n            \n                    alert('Reminder added successfully!');\n                    this.loadReminders();\n                } catch (error) {\n                    console.error('Error adding reminder:', error);\n                    alert('Failed to add reminder.');\n                }\n            }\n        }\n    }            \n\n\n\n    static observers() {\n        return {};\n    }\n}\n\nexport { BirthdayReminder };\n","import { prop } from \"@slyte/core\";\nimport { Component } from \"../component.js\";\n\n/**\n * Renders a button\n * @component lyte-button\n * @version 1.0.0\n * @utility click, focus, blur\n * @dependencies lyte-shortcut\n * \t\t/plugins/lyte-shortcut.js\n */\n\nclass LyteButtonComponent extends Component {\n    constructor() {\n        super();\n    }\n\n    data() {\n\t\treturn {\n\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropName\n\t\t\t */\n\n\t\t\t'ltPropName': prop( 'string', {\n\t\t\t\t'default': undefined\n\t\t\t} ),\n\n\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropDisabled=false\n\t\t\t */\n\n\t\t\t'ltPropDisabled': prop( 'boolean', {\n\t\t\t\t'default': false\n\t\t\t} ),\n\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropAutoFocus=false\n\t\t\t */\n\n\t\t\t'ltPropAutofocus': prop( 'boolean', {\n\t\t\t\t'default': false\n\t\t\t} ),\n\n\t\t\t/**\n\t\t\t * @componentProperty {default | primary | secondary | success | failure} ltPropAppearance=default\n\t\t\t */\n\n\t\t\t'ltPropAppearance': prop( 'string', {\n\t\t\t\t'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-button', 'appearance', 'default' )\n\t\t\t} ),\n\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropId\n\t\t\t */\n\n\t\t\t'ltPropId': prop( 'string', {\n\t\t\t\t'default': undefined\n\t\t\t} ),\n\n\t\t\t/**\n\t\t\t * @componentProperty {button | submit | reset} ltPropType=button\n\t\t\t */\n\n\t\t\t'ltPropType': prop( 'string', {\n\t\t\t\t'default': 'button'\n\t\t\t} ),\n\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropValue\n\t\t\t */\n\n\t\t\t'ltPropValue': prop( 'string', {\n\t\t\t\t'default': undefined\n\t\t\t} ),\n\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropTabindex\n\t\t\t */\n\n\t\t\t'ltPropTabindex': prop( 'string', {\n\t\t\t\t'default': undefined\n\t\t\t} ),\n\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropStyle\n\t\t\t */\n\n\t\t\t'ltPropStyle': prop( 'string', {\n\t\t\t\t'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-button', 'style', undefined )\n\t\t\t} ),\n\n\t\t\t/**\n\t\t\t * @componentProperty {extra-small | small | medium | large} ltPropSize=default\n\t\t\t */\n\n\t\t\t'ltPropSize': prop( 'string', {\n\t\t\t\t'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-button', 'size', 'default' )\n\t\t\t} ),\n\t\t\t/**\n\t\t\t * @componentProperty {colorString} ltPropBackgroundColor\n\t\t\t */\n\n\t\t\t'ltPropBackgroundColor': prop( 'string', {\n\t\t\t\t'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-button', 'backgroundColor', undefined )\n\t\t\t} ),\n\t\t\t/**\n\t\t\t * @componentProperty {colorString} ltPropColor\n\t\t\t */\n\n\t\t\t'ltPropColor': prop( 'string', {\n\t\t\t\t'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-button', 'color', undefined )\n\t\t\t} ),\n\n\t\t\t/**\n\t\t\t * @componentProperty {string} lyteShortcut\n\t\t\t */\n\n\t\t\t'lyteShortcut': prop( 'string', {\n\t\t\t\t'default': ''\n\t\t\t} ),\n\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropClass\n\t\t\t */\n\n\t\t\t'ltPropClass':prop( 'string', {\n\t\t\t\t'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-button', 'class', '' )\n\t\t\t} ),\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropClass\n\t\t\t */\n\n\t\t\t'lyteUnbound': prop( 'boolean', {\n\t\t\t\t'default': false\n\t\t\t} ),\n\n\t\t\t/**\n\t\t\t * @componentProperty {object} ltPropAriaButton={}\n\t\t\t * @version 3.1.0\n\t\t\t */\n\n\t\t\t'ltPropAriaButton': prop('object', {\n\t\t\t\t'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-button', 'ariaButton', {} )\n\t\t\t} ),\n\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropText\n\t\t\t */\n\n\t\t\t'ltPropText': prop( 'string', {\n\t\t\t\t'default': ''\n\t\t\t}),\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropDataTabindex\n\t\t\t */\n\t\t\t'ltPropDataTabindex': prop('string', { 'default': null }),\n\t\t\t'randomId': prop('string')\n\t\t};\n\t}\n\n    init() {\n\t\tthis.pushValue();\n\t}\n\n    registerFunction(fn) {\n\t\tvar that = this;\n\t\tthis.$node[ fn ] = function() {\n\t\t\tvar node = that.$node,\n\t\t\tbutton = node.querySelector( 'button' ),\n\t\t\tdisabled = node.ltProp( 'disabled' );\n\n\t\t\tif( disabled ) {\n\t\t\t\treturn ;\n\t\t\t}\n\n\t\t\tbutton[ fn ]();\n\t\t}\n\t}\n\n    didConnect() {\n\t\tvar fns = [ 'click', 'focus', 'blur' ], i = 0,\n\t\toldAria = {}, newAria = this.getData( 'ltPropAriaButton' );\n\n\t\tfor( ; i < fns.length; i++ ) {\n\t\t\tthis.registerFunction( fns[ i ] );\n\t\t}\n\n\t\tthis.addAriaValues( oldAria, newAria );\n\t}\n\n    addAriaValues(oldAria, newAria) {\n\t\tvar button = this.getButtonWidget();\n\n\t\twindow._lyteUiUtils.setAttribute( button, newAria, oldAria );\n\t}\n\n    getButtonWidget() {\n\t\treturn this.$node.querySelector( 'button' );\n\t}\n\n    didDestroy() {\n\t\tvar val;\n\n\t\tdelete this.$node.focus;\n\t\tdelete this.$node.blur;\n\t\tdelete this.$node.click;\n\n\t\ttry {\n\t\t\tval = JSON.parse( this.getData('lyteShortcut') );\n\t\t}\n\t\tcatch( err ) {\n\t\t\treturn ;\n\t\t}\n\n\t\tif( Array.isArray( val ) ) {\n\t\t\tval.forEach( function( shortcutConfig ) {\n\t\t\t\tif( shortcutConfig.key ) {\n\t\t\t\t\twindow.shortcut.push( {\n\t\t\t\t\t\tnewKey: undefined,\n\t\t\t\t\t\ttype: undefined,\n\t\t\t\t\t\twait: undefined,\n\t\t\t\t\t\toldKey: shortcutConfig.key\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t\telse {\n\t\t\twindow.shortcut.push( {\n\t\t\t\tnewKey: undefined,\n\t\t\t\ttype: undefined,\n\t\t\t\twait: undefined,\n\t\t\t\toldKey: val.key\n\t\t\t} );\n\t\t}\n\t}\n\n    pushValue(oldValue) {\n\t\tvar key = this.getData( 'lyteShortcut' ),\n\t\tnode = this.$node,\n\t\t// oldValue can be an array as well. Need to handle that\n\t\toldObj = JSON.parse( oldValue || '{}' ),\n\t\toldKey = oldObj.key;\n\n\t\tif(!key){\n\t\t\treturn\n\t\t}\n\t\twindow.newObj = JSON.parse( key );\n\t\tif(Array.isArray(newObj)){\n\t\t\tnewObj.forEach(function(item){\n\t\t\t\tif(item.key){\n\t\t\t\t\twindow.shortcut.push( {\n\t\t\t\t\t\tnewKey : item.key,\n\t\t\t\t\t\ttype : item.type,\n\t\t\t\t\t\twait : item.wait,\n\t\t\t\t\t\t// Need to unregister shortcut for array case\n\t\t\t\t\t\toldKey:undefined,\n\t\t\t\t\t\tvalue:node\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t\telse{\n\t\t\tif(newObj.key){\n\t\t\t\twindow.shortcut.push( {\n\t\t\t\t\tnewKey : newObj.key,\n\t\t\t\t\ttype : newObj.type,\n\t\t\t\t\twait : newObj.wait,\n\t\t\t\t\toldKey: oldKey,\n\t\t\t\t\tvalue:node\n\t\t\t\t} );\n\t\t\t}\n\t\t\telse {\n\t\t\t\twindow.shortcut.push( {\n\t\t\t\t\tnewKey: undefined,\n\t\t\t\t\ttype: undefined,\n\t\t\t\t\twait: undefined,\n\t\t\t\t\toldKey: oldKey\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\t}\n\n    static actions() {\n        return {\n            check: function( event ) {\n                var button = this.$node.querySelector( 'button' )\n                if( button.disabled ) {\n                    event.stopPropagation();\n                    event.preventDefault();\n                }\n            }\n        };\n    }\n\n    static observers() {\n        return {\n            ariaObserver: function( change ) {\n                var oldAria = change.oldValue,\n                newAria = change.newValue;\n\n                this.addAriaValues( oldAria, newAria );\n            }.observes( 'ltPropAriaButton' ),\n\n            shortcutChanged: function( changeObj ) {\n                this.pushValue( changeObj.oldValue );\n            }.observes( 'lyteShortcut' ),\n\n            changeClass: function() {\n                var cls = this.getData('ltPropClass'), tempStyle = '',\n                tempClass = 'lyte-button' + ( cls ? ' ' + cls : '' ),\n                app = this.getData( 'ltPropAppearance' ), size = this.getData( 'ltPropSize' ),\n                color = this.getData( 'ltPropColor' ), bg = this.getData( 'ltPropBackgroundColor' );\n                size = size ? size.toLowerCase() : '';\n                app = app ? app : 'default';\n\n                if( bg ) {\n                    tempClass = tempClass + ' lyteBackgroundColorBtn';\n                }\n                else if( color ) {\n                    tempClass = tempClass + ' lyteColorBtn';\n                }\n                else if( app.indexOf( 'default' ) !== -1 ) {\n                    tempClass = tempClass + ' lyteDefaultBtn';\n                }\n                else if( app.indexOf( 'primary' ) !== -1 ) {\n                    tempClass = tempClass + ' lytePrimaryBtn';\n                }\n                else if( app.indexOf( 'secondary' ) !== -1 ) {\n                    tempClass = tempClass + ' lyteSecondary';\n                }\n\n                if( app.indexOf( 'success' ) !== -1 ) {\n                    tempClass = tempClass + ' lyteSuccess';\n                }\n                else if( app.indexOf( 'failure' ) !== -1 ) {\n                    tempClass = tempClass + ' lyteFailure';\n                }\n\n                if( size === 'extra-small' ) {\n                    tempClass = tempClass + ' lyteExsm';\n                }\n                else if( size === 'small' ) {\n                    tempClass = tempClass + ' lyteSm';\n                }\n                else if( size === 'large' ) {\n                    tempClass = tempClass + ' lyteLg';\n                }\n\n                if( color ) {\n                    if( !bg ) {\n                        // Adding bg-color #fff because androids render a grayish button.\n                        tempStyle = tempStyle + 'background-color: #fff; color:' + color + ';border-color:' + color + ';';\n                    }\n                    else {\n                        tempStyle = tempStyle + 'background-color:' + bg + ';border-color:' + bg + ';color:' + color + ';';\n                    }\n                }\n                else if( bg ) {\n                    tempStyle = tempStyle + 'background-color:' + bg + \";border-color:\" + bg + \";color:white;\";\n                }\n\n                if( this.getData( 'ltPropStyle' ) ) {\n                    tempStyle = tempStyle + this.getData( 'ltPropStyle' );\n                }\n\n                this.setData( 'finalStyle', tempStyle );\n                this.setData( 'finalClass', tempClass );\n            }.observes(\n                'ltPropClass',\n                'ltPropBackgroundColor',\n                'ltPropColor',\n                'ltPropStyle',\n                'ltPropSize',\n                'ltPropAppearance'\n            ).on( 'init' )\n        };\n    }\n}\n\n/**\n * @syntax yielded\n * <lyte-button>\n *     <template is=\"registerYield\" yield-name=\"text\">\n *         click me\n *     </template>\n * </lyte-button>\n */\n\n/**\n * @syntax staticBuilder\n * <lyte-button lt-prop-text=\"click me\"></lyte-button>\n */\n\nexport { LyteButtonComponent };\n","import './../helpers/helpers-dev.js';\nimport './lyte-dropdown.js';\nimport { prop } from \"@slyte/core\";\nimport { Component } from \"../component.js\";\n\nimport $L from \"@zoho/lyte-dom\";\n\nimport \"../../components/javascript/lyte-tooltip.js\";\n\nimport \"../../plugins/lyte-moment-basic.js\";\nimport \"../../plugins/lyte-moment-additional.js\";\n\n/**\n * Renders a calendar\n * @component lyte-calendar\n * @version 1.0.0\n * @utility revertToToday,revertToSelected\n * @methods onDateSelected,onNavigate,onViewChange\n * @dependencies lyte-dropdown\n */\n\nclass LyteCalendarComponent extends Component {\n    constructor() {\n        super();\n    }\n\n\tdata() {\n\t\treturn {\n\t\t\t'ltPropStartDate': prop('string', {\n\t\t\t\t'default': ''\n\t\t\t}),\n\t\t\t'ltPropEndDate': prop('string', {\n\t\t\t\t'default': ''\n\t\t\t}),\n\n\t\t\t/**\n\t\t\t * @componentProperty {dateString} ltPropCurrentDate\n\t\t\t */\n\n\t\t\t'ltPropCurrentDate': prop( 'string', { \n\t\t\t\t'default': '' \n\t\t\t} ),\n\t\t\t/** \n\t\t\t * @typedef {\n\t\t\t\t* MM/DD/YYYY |\n\t\t\t\t* YYYY/MM/DD |\n\t\t\t\t* MMM/DD/YYYY |\n\t\t\t\t* MMM/YYYY/DD |\n\t\t\t\t* DD/MMM/YYYY |\n\t\t\t\t* YYYY/MMM/DD |\n\t\t\t\t* DD/YYYY/MMM |\n\t\t\t\t* YYYY/DD/MMM |\n\t\t\t\t* MMMM/DD/YYYY |\n\t\t\t\t* MMMM/YYYY/DD |\n\t\t\t\t* DD/YYYY/MMMM |\n\t\t\t\t* YYYY/DD/MMMM |\n\t\t\t\t* DD/MMMM/YYYY |\n\t\t\t\t* YYYY/MMMM/DD\n\t\t\t\t* } dateFormat\n\t\t\t*/\n\t\t\t/**\n\t\t\t * @componentProperty {dateFormat} ltPropFormat\n\t\t\t * @default MM/DD/YYYY\n\t\t\t */\n\n\t\t\t'ltPropFormat': prop( 'string', { \n\t\t\t\t'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-calendar', 'format', 'MM/DD/YYYY' )  \n\t\t\t} ),\n\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropYear\n\t\t\t * @default false\n\t\t\t * \n\t\t\t */\n\n\t\t\t'ltPropYear': prop( 'boolean', { \n\t\t\t\t'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-calendar', 'year', false ) \n\t\t\t} ),\n\n\t\t\t/**\n\t\t\t * @typedef {\n\t\t\t * 'MMMM YYYY' |\n\t\t\t * 'MMM YYYY'\n\t\t\t * } MonthHeaderFormat\n\t\t\t */\n\t\t\t/**\n\t\t\t * @componentProperty {MonthHeaderFormat} ltPropMonthHeaderFormat\n\t\t\t * @default 'MMMM YYYY'\n\t\t\t */\n\n\t\t\t'ltPropMonthHeaderFormat': prop( 'string', { \n\t\t\t\t'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-calendar', 'monthHeaderFormat', 'MMMM YYYY' ) \n\t\t\t} ),\n\t\t\t'daysOfWeek': prop( 'array', { \n\t\t\t\t'default': [] \n\t\t\t} ),\n\n\t\t\t'ariaMonthNames': prop( 'array', { 'default': [\n\t\t\t\t\t'January',\n\t\t\t\t\t'February',\n\t\t\t\t\t'March',\n\t\t\t\t\t'April',\n\t\t\t\t\t'May',\n\t\t\t\t\t'June',\n\t\t\t\t\t'July',\n\t\t\t\t\t'August',\n\t\t\t\t\t'September',\n\t\t\t\t\t'October',\n\t\t\t\t\t'November',\n\t\t\t\t\t'December' \n\t\t\t] } ),\n\n\t\t\t'monthSystemValues': prop( 'array', {\n\t\t\t\t'default': [\n\t\t\t\t\t'January',\n\t\t\t\t\t'February',\n\t\t\t\t\t'March',\n\t\t\t\t\t'April',\n\t\t\t\t\t'May',\n\t\t\t\t\t'June',\n\t\t\t\t\t'July',\n\t\t\t\t\t'August',\n\t\t\t\t\t'September',\n\t\t\t\t\t'October',\n\t\t\t\t\t'November',\n\t\t\t\t\t'December'\n\t\t\t\t]\n\t\t\t}),\n\n\t\t\t'monthNames': prop( 'array', { \n\t\t\t\t'default': [\n\t\t\t\t\t'January',\n\t\t\t\t\t'February',\n\t\t\t\t\t'March',\n\t\t\t\t\t'April',\n\t\t\t\t\t'May',\n\t\t\t\t\t'June',\n\t\t\t\t\t'July',\n\t\t\t\t\t'August',\n\t\t\t\t\t'September',\n\t\t\t\t\t'October',\n\t\t\t\t\t'November',\n\t\t\t\t\t'December'\n\t\t\t\t]\n\t\t\t} ),\n\t\t\t'shortHands': prop( 'array', { \n\t\t\t\t'default': [\n\t\t\t\t\t'Jan',\n\t\t\t\t\t'Feb',\n\t\t\t\t\t'Mar',\n\t\t\t\t\t'Apr',\n\t\t\t\t\t'short.may',\n\t\t\t\t\t'Jun',\n\t\t\t\t\t'Jul',\n\t\t\t\t\t'Aug',\n\t\t\t\t\t'Sep',\n\t\t\t\t\t'Oct',\n\t\t\t\t\t'Nov',\n\t\t\t\t\t'Dec'\n\t\t\t\t]\n\t\t\t} ),\n\t\t\t'todayName': prop( 'string', {\n\t\t\t\t'default': 'Today' \n\t\t\t} ),\n\t\t\t'viewDate': prop( 'object', { \n\t\t\t\t'default': {} \n\t\t\t} ),\n\t\t\t'changeData': prop( 'number', {\n\t\t\t\t'default': 0 \n\t\t\t} ),\n\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropYield\n\t\t\t * @default false\n\t\t\t *\n\t\t\t */\n\n\t\t\t'ltPropYield': prop( 'boolean', { \n\t\t\t\t'default': false\n\t\t\t}),\n\n\t\t\t/**\n\t\t\t * @componentProperty {dateString} ltPropMinDate\n\t\t\t */\n\n\t\t\t'ltPropMinDate': prop( 'string', { \n\t\t\t\t'default': ''\n\t\t\t}),\n\n\t\t\t/**\n\t\t\t * @componentProperty {dateString} ltPropMaxDate\n\t\t\t */\n\n\t\t\t'ltPropMaxDate': prop( 'string', { \n\t\t\t\t'default': '' \n\t\t\t} ),\n\n\t\t\t/**\n\t\t\t * @componentProperty {number} ltPropStartWeekDay\n\t\t\t * @default 1\n\t\t\t * @minValue 0\n\t\t\t * @maxValue 6\n\t\t\t * @step 1\n\t\t\t */\n\n\t\t\t'ltPropStartWeekDay': prop( 'number', { \n\t\t\t\t'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-calendar', 'startWeekDay', 1 )\n\t\t\t} ),\n\t\t\t'navYield': prop( 'boolean', { \n\t\t\t\t'default': false \n\t\t\t} ),\n\t\t\t'selectDate': prop( 'boolean', { \n\t\t\t\t'default': true \n\t\t\t} ),\n\t\t\t'currentDatechanged': prop( 'number', { \n\t\t\t\t'default': 0 \n\t\t\t} ),\n\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropFillRows\n\t\t\t * @default true\n\t\t\t * @version 1.0.2\n\t\t\t *\n\t\t\t */\n\n\t\t\t'ltPropFillRows': prop( 'boolean', { \n\t\t\t\t'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-calendar', 'fillRows', true ) \n\t\t\t} ),\n\n\t\t\t/**\n\t\t\t * @componentProperty {number} ltPropNumberOfRows\n\t\t\t * @version 1.0.2\n\t\t\t * @default 6\n\t\t\t */\n\n\t\t\t'ltPropNumberOfRows': prop( 'number', { \n\t\t\t\t'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-calendar', 'numberOfRows', 6 )\n\t\t\t} ),\n\t\t\t'callFrmDidcnct' : prop('boolean',{\"default\" : false}),\n\t\t\t'monthDD' : prop(\"object\"),\n\t\t\t'yearDD' : prop(\"object\"),\n\t\t\t'years' :prop(\"array\",{\"default\":[]}),\n\n\t\t\t/**\n\t\t\t * @componentProperty {default|dropdown|drilldown} ltPropHeaderType\n\t\t\t * @default default\n\t\t\t * @version 1.0.2\n\t\t\t */\n\n\t\t\t'ltPropHeaderType' : prop( \"string\", { \"default\": window._lyteUiUtils.resolveDefaultValue( 'lyte-calendar', 'headerType', 'default' ) } ),\n\n\t\t\t'ltPropDropdown': prop( 'object', { 'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-calendar', 'dropdown', \n\t\t\t\t{\n\t\t\t\t\t'callout': true\n\t\t\t\t} \n\t\t\t) } ),\n\n\t\t\t'cords': prop( 'object', { default: {} } ),\n\t\t\t'start': prop( 'number' ),\n\t\t\t'prev': prop( 'boolean' ),\n\t\t\t'tt': prop( 'boolean', { 'default': true } ),\n\t\t\t'showToday': prop( 'boolean', { 'default': true } ),\n\n\t\t\t'monthViewTableArray': prop( 'array', { 'default': [] } ),\n\n\t\t\t'ltPropBodyYield': prop( 'boolean', { 'default': false } ),\n\n\t\t\t'ltPropShowToday': prop( 'boolean', { 'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-calendar', 'showToday', true ) } ),\n\n\t\t\t'ltPropI18n': prop( 'boolean', { 'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-calendar', 'I18n', false ) } ),\n\n\t\t\t'ltPropActivateNavigation': prop( 'boolean', { 'default': false } ),\n\n\t\t\t// This attribute is only relevant for dateView\n\t\t\t'ltPropDisableNavigation': prop( 'boolean', { 'default': false } ),\n\n\t\t\t/* A team uses this but we are not goint to expose this outside */\n\t\t\t'ltPropPreventAddingRows': prop( 'boolean', { 'default': false } ),\n\n\t\t\t'ltPropSelectionType': prop( 'string', { 'default': 'day' } ),\n\n\t\t\t'ltPropWeekends': prop( 'array', { 'default': [ 6, 0 ] } ),\n\n\t\t\t'ltPropCurrentWeek': prop( 'array', { 'default': [] } ),\n\n\t\t\t'ltPropCurrentMonth': prop( 'string', { 'default': '' } ),\n\n\t\t\t'ltPropCurrentYear': prop( 'string', { 'default': '' } ),\n\n\t\t\t'ltPropDisabledDates': prop( 'array', { 'default': [] } ),\n\n\t\t\t'ltPropCurrentDates': prop( 'array', { 'default': [] } ),\n\n\t\t\t'ltPropMultiple': prop( 'boolean', { 'default': false } ),\n\n\t\t\t'headerId': prop( 'string' ),\n\n\t\t\t'monthDropdownId': prop( 'string' ),\n\t\t\t\n\t\t\t'yearDropdownId': prop( 'string' ),\n\n\t\t\t'ltPropIso' : prop( 'string'  ),\n\n\t\t\t'ltPropWeekNumCriteria': prop( 'number', { 'default': 1 } ),\n\n\t\t\t'ltPropHolidays': prop( 'array', { 'default': [ ] } ),\n\n\t\t\t'ltPropDisableWeekends': prop( 'boolean', { 'default': false } ),\n\n\t\t\t'ltPropDisableHolidays': prop( 'boolean', { 'default': false } ),\n\n\t\t\t'ltPropWeekNumber': prop( 'boolean', { 'default': false } ),\n\n\t\t\t//showToday even when we are in current date\n\t\t\t'ltPropAlwaysShowToday': prop( 'boolean', { 'default': false } ),\n\n\t\t\t'ltPropHighlightWeekendHolidays': prop( 'boolean', { 'default': false } ),\n\n\t\t\t'ltPropTimeZone' : prop( 'string' ),\n\n\t\t\t'ltPropDisabledDays' : prop( 'array', { default : window._lyteUiUtils.resolveDefaultValue( 'lyte-calendar', 'disabledWeekDays', [] ) } ),\n\n\t\t\t'ltPropHeaderAlignType': prop( 'string', { 'default': '' } ),\n\n\t\t\t'ltPropWeekNumHeader': prop( 'string', { 'default': '' } ),\n\n\t\t\t'showYear': prop( 'boolean', { 'default': false } ),\n\n\t\t\t'ltPropCurrentDisplayMonth': prop( 'string', { 'default': '' } ),\n\n\t\t\t'ltPropCurrentDisplayYear': prop( 'string', { 'default': '' } ),\n\n\t\t\t'ltPropCurrentDisplayDecade': prop( 'string', { 'default': '' } )\n\t\t};\n\t}\n\n    getCells() {\n\t\tvar container = this.getTableContainer(),\n\t\t\trows = container.children, cells = [];\n\n\t\tArray.from(rows).forEach(function (row) {\n\t\t\tcells = cells.concat(Array.from(row.children));\n\t\t});\n\n\t\treturn cells;\n\t}\n\n    getTableContainer() {\n\t\treturn this.$node.querySelector( '.lyteCalTableRowGroup' );\n\t}\n\n    moveForward(event, navDirection, cellsToMove) {\n\t\tthis.move( event, navDirection, cellsToMove );\n\t}\n\n    moveBackward(event, navDirection, cellsToMove) {\n\t\tthis.move( event, navDirection, cellsToMove );\n\t}\n\n    move(event, navDirection, cellsToMove) {\n\t\tvar activeCell = this.getActiveCell(),\n\t\t\tcells = this.getCells(),\n\t\t\tcurrentNavIndex = cells.indexOf(activeCell),\n\t\t\tnewNavIndex = currentNavIndex + cellsToMove,\n\t\t\tnewActiveCell;\n\n\t\tif (!activeCell) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.shouldViewChange(cells, newNavIndex, cellsToMove)) {\n\t\t\tnewActiveCell = this.getCellFromSameView(cells, newNavIndex);\n\t\t}\n\t\telse {\n\t\t\tnewActiveCell = this.getCellFromDifferentView(navDirection, currentNavIndex, cellsToMove, event);\n\t\t}\n\n\t\tthis.activateCell(newActiveCell);\n\t\tthis.focusActiveCell();\n\t}\n\n    getCellFromSameView(cells, index) {\n\t\treturn cells[ index ];\n\t}\n\n    focusActiveCell() {\n\t\tvar activeCell = this.getActiveCell();\n\n\t\tif (activeCell) {\n\t\t\tactiveCell.focus();\n\t\t}\n\t}\n\n    focusActiveRow() {\n\t\tvar activeRow = this.getActiveRow();\n\t\tif( activeRow ) {\n\t\t\tactiveRow.focus();\n\t\t}\n\t}\n\n    shouldViewChange(cells, newNavIndex, cellsToMove) {\n\t\tvar viewType = this.getData( 'viewType' );\n\n\t\tif (viewType === 'monthView' || viewType === 'decadeView') {\n\t\t\treturn !cells[newNavIndex];\n\t\t}\n\n\t\treturn !this.isSameMonth( cellsToMove );\n\t}\n\n    isDisabledCell(cell) {\n\t\treturn cell.classList.contains( 'lyteCalDisabled' )\n\t}\n\n    getCellFromDifferentView(navDirection, currentNavIndex, cellsToMove, event) {\n\t\tvar viewType = this.getData( 'viewType' ), newActiveDate;\n\n\t\tif (viewType === 'monthView' || viewType === 'decadeView') {\n\t\t\tthis.changeView(navDirection);\n\n\t\t\treturn this.getDrillDownViewCell(navDirection, currentNavIndex, cellsToMove);\n\t\t}\n\n\n\t\tnewActiveDate = this.getChangedDate(cellsToMove);\n\t\tthis.changeView(navDirection);\n\n\t\treturn this.getCell( newActiveDate );\n\t}\n\n    getDrillDownViewCell(navDirection, currentNavIndex, cellsToMove) {\n\t\tvar cells = this.getCells();\n\n\t\treturn navDirection === 'previous' ? cells[ cells.length + ( currentNavIndex + cellsToMove ) ] : cells[ ( currentNavIndex + cellsToMove ) % cells.length ]\n\t}\n\n    changeView(navDirection) {\n\t\tif( navDirection === 'previous' ) {\n\t\t\tthis.moveToPrevious( 'M', window.event );\t\n\t\t}\n\t\telse {\n\t\t\tthis.moveToNext( 'M', window.event );\n\t\t}\n\t}\n\n    moveToFirstCell(event, navDirection) {\n\t\tvar actionType = 'home',\n\t\t\tcellsToMove = this.getCellsToMove(navDirection, actionType);\n\n\t\tthis.moveBackward( event, navDirection, cellsToMove );\n\t}\n\n    moveToLastCell(event, navDirection) {\n\t\tvar actionType = 'end', \n\t\tcellsToMove = this.getCellsToMove( navDirection, actionType );\n\n\t\tthis.moveForward( event, navDirection, cellsToMove );\n\t}\n\n    getCellsToMove(navDirection, actionType) {\n\t\tvar activeCell = this.getActiveCell(),\n\t\t\tparentElement = (activeCell || {}).parentElement,\n\t\t\tchildren = Array.from((parentElement || {}).children || []),\n\t\t\tindex = children.indexOf(activeCell), viewType = this.getData('viewType');\n\n\t\tif (!activeCell) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (actionType === 'home' || actionType === 'end') {\n\t\t\treturn navDirection === 'previous' ? -index : (children.length - 1 - index);\n\t\t}\n\n\t\tif (viewType === 'monthView' || viewType === 'decadeView') {\n\t\t\treturn navDirection === 'previous' ? -4 : 4;\n\t\t}\n\n\t\treturn navDirection === 'previous' ? -7 : 7;\n\t}\n\n    getCell(date) {\n\t\treturn this.$node.querySelector( '[data-date=\"' + date + '\"]' );\n\t}\n\n    isSameMonth(daysToChange) {\n\t\tvar changedMonth = this.getChangedMonth( daysToChange ),\n\t\tviewDate = this.getData( 'viewDate' ),\n\t\tcurrentViewedMonth = viewDate.getMonth();\n\t\t\n\t\treturn changedMonth === currentViewedMonth;\n\n\t}\n\n    getChangedMonth(daysToChange) {\n\t\tvar changedDate = this.getChangedDate( daysToChange ),\n\t\tformat = this.getData( 'ltPropFormat' );\n\n\t\treturn $L.moment( changedDate, format ).format( 'M' ) - 1;\n\t}\n\n    // Assume activeCell will always return a valid cell\n    getChangedDate(daysToChange) {\n\t\tvar activeCell = this.getActiveCell(),\n\t\t\tactiveDate = activeCell.getAttribute('data-date'),\n\t\t\tformat = this.getData('ltPropFormat');\n\n\t\treturn $L.moment( activeDate, format ).add( daysToChange, 'day' ).format( format );\n\t}\n\n    previousNavigation(MONTH, event) {\n\t\tvar YEAR = 'Y', MONTH = 'M', \n\t\tnavigationType = event.shiftKey ? YEAR : MONTH;\n\n\t\tthis.moveToPrevious(navigationType, event);\n\t\tthis.focusActiveCell();\n\t}\n\n    nextNavigation(MONTH, event) {\n\t\tvar YEAR = 'Y', MONTH = 'M', \n\t\tnavigationType = event.shiftKey ? YEAR : MONTH;\n\n\t\tthis.moveToNext(navigationType, event);\n\t\tthis.focusActiveCell();\n\t}\n\n    toDate() {\n\n\t\tvar comp_timezone = this.data.ltPropTimeZone;\n\n\t\tif( comp_timezone != void 0 ){\n\t\t\treturn new Date( $L.moment().timezone( comp_timezone ).format( 'MM/DD/YYYY' ) );\n\t\t}\n\n\t\tif( this.isHavingTimezone ){\n\t\t\treturn new Date( $L.moment().format( 'MM/DD/YYYY' ) );\n\t\t}\n\t\treturn new Date();\n\t}\n\n    moment(arg1, arg2, arg3) {\n\t\tvar timezone = this.isHavingTimezone;\n\t\tif (timezone) {// for test case failure\n\t\t\tif (arg3) {\n\t\t\t\targ3.ignore_timezone = timezone;\n\t\t\t} else {\n\t\t\t\targ3 = { ignore_timezone: timezone };\n\t\t\t}\n\t\t\treturn $L.moment(arg1, arg2, arg3);\n\t\t} else {\n\t\t\tif (arg2) { // for test case failure\n\t\t\t\tif (arg3) { // for test case failure\n\t\t\t\t\treturn $L.moment(arg1, arg2, arg3);\n\t\t\t\t}\n\t\t\t\treturn $L.moment(arg1, arg2);\n\t\t\t}\n\t\t\treturn $L.moment(arg1);\n\t\t}\n\t}\n\n\tsetShowYearAccToView() {\n\t\tvar viewType = this.getData( 'viewType' );\n\t\tvar showYear = this.getData( 'ltPropYear' );\n\n\t\tif( viewType === 'dateView' ) {\n\t\t\tif( showYear ){\n\t\t\t\tthis.setData('showYear',true);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tthis.setData('showYear',false);\n\t\t\t}\n\t\t}\n\t\telse if( viewType === 'monthView' ) {\n\t\t\tthis.setData('showYear',false);\n\t\t}\n\t\telse if( viewType === 'decadeView' ) {\n\t\t\tthis.setData('showYear',false);\n\t\t}\n\t}\n\n    removeSelectionStyles() {\n\t\tvar container = this.$node.querySelector( '.lyteCalTableContainer' );\n\n\t\tcontainer.classList.remove( 'lyteCalDaySelType' );\n\t\tcontainer.classList.remove( 'lyteCalWeekSelType' );\n\t\tcontainer.classList.remove( 'lyteCalMonthSelType' );\n\t\tcontainer.classList.remove( 'lyteCalYearSelType' );\n\t}\n\n    changeDaysOfWeek() {\n\t\tvar days = [ 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat' ], \n\t\ttitle = [ 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' ],\n\t\tstartDay = this.getData( 'ltPropStartWeekDay' ), i, result = [] ;\n\t\tvar weekend = this.getData('ltPropWeekends');\n\n\t\tfor( i = 0; i < 7; i++ ) { \n\t\t\tvar resClass = 'lyteCalTableCellHeader';\n\t\t\tvar isWeekendHeader = weekend.indexOf( ( i + startDay ) % 7 ) === -1 ? false : true;\n\t\t\tif( isWeekendHeader ){\n\t\t\t\tresClass += ' lyteCalWeekendHeader'\n\t\t\t}\n\n\t\t\tresult.push( { 'day': days[ ( i + startDay ) % 7 ], 'id': this.generateRandomId() , 'title': title[ ( i + startDay ) % 7 ], 'class': resClass } );\n\n\t\t}\n\n\t\tthis.setData( 'daysOfWeek', result );\n\t\t\n\t}\n\n    generateRandomId() {\n\t\treturn 'Lyte_Calendar_Day_' + window._lyteUiUtils.calId++;\n\t}\n\n    isYYFormat() {\n\t\tvar format = this.getData( 'ltPropFormat' ),\n\t\trYY = /\\byy\\b/ig;\n\n\t\treturn rYY.test( format );\n\t}\n\n    outsideBoundary(calStartDate) {\n\t\tvar calculatedYear = calStartDate.getFullYear(),\n\t\t\tcurrent = this.toDate(),\n\t\t\tcurrentYear = current.getFullYear(),\n\t\t\tdiff = calculatedYear - currentYear,\n\t\t\tdateBounds = this.isMomentSupported ? $L.moment() : { uL: 19, lL: 80 };\n\n\t\tif (diff > dateBounds.uL) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (diff < -dateBounds.lL) {\n\t\t\treturn true;\n\t\t}\t\n\t\t\n\t}\n\n    didDestroy() {\n\t\tdelete this.$node.revertToToday;\n\t}\n\n    activateRelevantCell() {\n\t\tvar format = this.getData( 'ltPropFormat' ),\n\t\tcurDate = this.stringToDate( this.getData( 'ltPropCurrentDate' ), format ),\n\t\ttodayDate = this.toDate(), \n\t\tpreviousActiveDate = this.stringToDate( this.getData( 'previousActiveCellDate' ), format ), relevantCell;\n\n\t\tif( previousActiveDate !== 'Invalid Date' ) {\n\t\t\trelevantCell = this.findSimilarCell( previousActiveDate );\n\t\t}\n\n\t\tif( curDate !== 'Invalid Date' ) {\n\t\t\trelevantCell = relevantCell || this.findSimilarCell( curDate );\n\t\t}\n\n\t\trelevantCell = relevantCell || this.findSimilarCell( todayDate );\n\n\t\tthis.activateCell( relevantCell );\n\t}\n\n    findSimilarCell(userDateObj) {\n\t\tvar userDate = userDateObj.getDate(),\n\t\t\tcurrentViewedDateObj = this.getData('viewDate'),\n\t\t\tcurrentViewedMonth = currentViewedDateObj.getMonth(),\n\t\t\tcurrentViewedYear = currentViewedDateObj.getFullYear(),\n\t\t\tuserMonth = userDateObj.getMonth(),\n\t\t\tnumberOfDaysInMonth = this.getNumber(currentViewedMonth, currentViewedYear),\n\t\t\tformat = this.getData('ltPropFormat'),\n\t\t\tresultDate, resultDateObj, resultDateString;\n\n\t\tresultDate = userDate > numberOfDaysInMonth ? numberOfDaysInMonth : userDate;\n\t\tresultDateObj = new Date(currentViewedMonth + 1 + '/' + resultDate + '/' + currentViewedYear);\n\t\tresultDateString = this.getDateFromFormat(resultDateObj, format);\n\n\t\treturn this.getCell( resultDateString );\n\t}\n\n    activateCell(cell) {\n\n\t\tif (!cell) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar previousCell = this.$node.querySelector('.lyteCalNavCell');\n\n\t\tif (previousCell) {\n\t\t\tpreviousCell.classList.remove('lyteCalNavCell');\n\t\t\tpreviousCell.setAttribute('tabindex', '-1');\n\t\t}\n\n\t\tcell.setAttribute('tabindex', '0');\n\t\tcell.focus();\n\t\tcell.classList.add( 'lyteCalNavCell' );\n\t\t\n\t\tthis.setData( 'previousActiveCellDate', cell.getAttribute( 'data-date' ) );\n\t}\n\n    getActiveCell() {\n\t\treturn this.$node.querySelector( '.lyteCalNavCell' );\n\t}\n\n    getActiveRow() {\n\t\tvar par =  this.$node.querySelector( '.lyteCalToday' ); //gives undefined !?\n\t\treturn $L( par ).closest('lyteCalTableRow')[0];\n\t}\n\n    removeOutOfRangeOption() {\n\t\tvar years = this.getData( 'years' ),\n\t\tindex;\n\n\t\tif( !isNaN( this.addedOption ) ) {\n\t\t\tindex = years.indexOf( this.addedOption );\n\n\t\t\tif( !!~index ) {\n\t\t\t\tthis.$addon.arrayUtils( years, 'removeAt', index );\n\t\t\t\tthis.addedOption = null;\n\t\t\t}\n\t\t}\n\t}\n\n    outOfRange(val) {\n\t\tif( val < 1900 || val > 2100 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n    addOutOfRangeOption(val) {\n\t\tvar years = this.getData( 'years' );\n\n\t\tthis.addedOption = val;\n\n\t\tif( val < 1900 ) {\n\t\t\tthis.$addon.arrayUtils( years, 'insertAt', 0, val );\n\t\t}\n\t\telse if( val > 2100 ) {\n\t\t\tthis.$addon.arrayUtils( years, 'push', val );\n\t\t}\n\t}\n\n    getMonthHeader() {\n\t\tvar format = this.getData( 'ltPropMonthHeaderFormat' ), \n\t\tlmd = /MMMM YYYY/ig,\n\t\tld = /MMM YYYY/ig,\n\t\tretval = \"\", monthArray;\n\n\t\tif( lmd.test( format ) ) {\n\t\t\tmonthArray = this.getData( 'monthNames' )\n\t\t\tretval = window._lyteUiUtils.i18n( monthArray[ this.getData( 'viewDate' ).getMonth() ] ) + \" \" + this.getData( 'viewDate' ).getFullYear();\n\t\t}\n\t\telse if( ld.test( format ) ) {\n\t\t\tmonthArray = this.getData( 'shortHands' )\n\t\t\tretval = window._lyteUiUtils.i18n( monthArray[ this.getData( 'viewDate' ).getMonth() ] ) + \" \" + this.getData( 'viewDate' ).getFullYear();\n\t\t}\n\n\t\treturn retval;\n\t}\n\n    revert(event) {\n\t\tvar from = new Date( this.getData( 'viewDate' ).getTime() ), \n\t\tcurDate = this.toDate();\n\n\n\t\tcurDate.setDate(1);\n\n\t\tvar to = new Date(curDate.getTime());\n\n\t\tthis.setData( 'viewDate', curDate );\n\t\tthis.setAndBuildView( 'dateView', event );\n\t\tif( !this.getData('ltPropAlwaysShowToday') ){\n\t\t\tthis.setData('showToday',false);\n\t\t}\n\t\tif( this.getMethods( 'onNavigate' ) \n\t\t\t&& ( from.getMonth() !== to.getMonth() \n\t\t\t|| from.getFullYear() !== to.getFullYear() ) \n\t\t) {\n\t\t\tthis.executeMethod('onNavigate', event, this.getDateFromFormat(from, this.getData('ltPropFormat')), this.getDateFromFormat(to, this.getData('ltPropFormat')), this);\n\t\t}\n\t}\n\n    revertToMonth(event) {\n\t\tvar from = new Date( this.getData( 'viewDate' ).getTime() ), \n\t\tcurDate = this.toDate();\n\n\n\t\tcurDate.setDate(1);\n\n\t\tvar to = new Date( curDate.getTime() );\n\n\t\tthis.setData( 'viewDate', curDate );\n\t\tthis.setAndBuildView( 'monthView', event );\n\t\tif( !this.getData('ltPropAlwaysShowToday') ){\n\t\t\tthis.setData('showToday',false);\n\t\t}\n\t\tif( this.getMethods( 'onNavigate' ) \n\t\t\t&& ( from.getMonth() !== to.getMonth() \n\t\t\t|| from.getFullYear() !== to.getFullYear() ) \n\t\t) {\n\t\t\tthis.executeMethod( 'onNavigate', event, this.getDateFromFormat( from, this.getData( 'ltPropFormat' ) ), this.getDateFromFormat( to, this.getData( 'ltPropFormat' ) ) ,this );\n\t\t}\n\t}\n\n\trevertToYear( event ) {\n\t\tvar from = new Date( this.getData( 'viewDate' ).getTime() ), \n\t\tcurDate = this.toDate();\n\n\n\t\tcurDate.setDate(1);\n\n\t\tvar to = new Date( curDate.getTime() );\n\n\t\tthis.setData( 'viewDate', curDate );\n\t\tthis.setAndBuildView( 'decadeView', event );\n\t\tif( !this.getData('ltPropAlwaysShowToday') ){\n\t\t\tthis.setData('showToday',false);\n\t\t}\n\n\t\tvar fromDecade = (from.getFullYear()+'').slice(0,3);\n\t\tvar toDecade = (to.getFullYear()+'').slice(0,3);\n\n\t\tif( this.getMethods( 'onNavigate' ) \n\t\t\t&& (  fromDecade !== toDecade ) \n\t\t) {\n\t\t\tthis.executeMethod( 'onNavigate', event, this.getDateFromFormat( from, this.getData( 'ltPropFormat' ) ), this.getDateFromFormat( to, this.getData( 'ltPropFormat' ) ) ,this );\n\t\t}\n\t}\n\n    getDateFromFormat(dateObj, format) {\n\t\tif( this.isMomentSupported ) {\n\t\t\treturn this.getDateStringFromMoment( dateObj, format );\n\t\t}\n\t\telse {\n\t\t\treturn this.getDateStringManually(dateObj, format);\n\t\t}\n\t}\n\n    getDateStringFromMoment(dateObj, format) {\n\t\tformat = this.getRelevantFormat( format );\n\n\t\treturn this.moment( dateObj ).format( format );\n\t}\n\n    resolveConflicts(format) {\n\t\tvar match = /(\\bd\\b|\\bdd\\b|\\bddd\\b|\\bdddd\\b)/.exec( format ),\n\t\tindex = ( match || {} ).index,\n\t\tmatchLength = ( match || [] )[ 0 ].length || 0;\n\n\t\tif (!isNaN(index)) {\n\t\t\treturn format.substring(0, index + matchLength) + (format.substring(index + matchLength) || '').toUpperCase();\n\t\t}\n\n\t\treturn format.toUpperCase();\n\t}\n\n    isConflictingFormat(format) {\n\t\tvar rdate = /(\\bd\\b|\\bdd\\b|\\bddd\\b|\\bdddd\\b)/ig,\n\t\t\tmatch = format.match(rdate) || [];\n\n\t\treturn match.length > 1;\n\t}\n\n    getRelevantFormat(format) {\n\n\t\tif (this.isConflictingFormat(format)) {\n\t\t\treturn this.resolveConflicts(format);\n\t\t}\n\n\t\treturn format.toUpperCase();\n\t}\n\n    getDateStringManually(dateObj, format) {\n\t\tvar date = dateObj.getDate(), year = dateObj.getFullYear(), month = dateObj.getMonth() + 1, monthArray,\n\t\t\tsd = /(MM).+(DD).+(YYYY)/ig,\n\t\t\tdmy = /(DD).+(MM).+(YYYY)/ig,\n\t\t\tld = /(MMM|DD|YYYY).+(MMM|DD|YYYY).+(YYYY|MMM|DD)/ig,\n\t\t\tlmd = /(MMMM|DD|YYYY).+(MMMM|DD|YYYY).+(YYYY|MMMM|DD)/ig,\n\t\t\tiso = /(YYYY).+(MM).+(DD)/ig;\n\n\t\tformat = format.toUpperCase();\n\n\t\tif (month < 10) {\n\t\t\tmonth = '0' + month\n\t\t}\n\n\t\tif (date < 10) {\n\t\t\tdate = '0' + date\n\t\t}\n\n\t\tif (lmd.test(format)) {\n\t\t\tmonthArray = [\n\t\t\t\t'January',\n\t\t\t\t'February',\n\t\t\t\t'March',\n\t\t\t\t'April',\n\t\t\t\t'May',\n\t\t\t\t'June',\n\t\t\t\t'July',\n\t\t\t\t'August',\n\t\t\t\t'September',\n\t\t\t\t'October',\n\t\t\t\t'November',\n\t\t\t\t'December'\n\t\t\t]\n\t\t\tformat = format.replace('MMMM', monthArray[month - 1]);\n\t\t\tformat = format.replace('DD', date);\n\t\t\tformat = format.replace('YYYY', year);\n\t\t}\n\t\telse if (ld.test(format)) {\n\t\t\tmonthArray = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n\t\t\tformat = format.replace('MMM', monthArray[month - 1]);\n\t\t\tformat = format.replace('DD', date);\n\t\t\tformat = format.replace('YYYY', year);\n\t\t}\n\t\telse if (iso.test(format)) {\n\t\t\tformat = format.replace('MM', month);\n\t\t\tformat = format.replace('DD', date);\n\t\t\tformat = format.replace('YYYY', year);\n\t\t}\n\t\telse if (sd.test(format)) {\n\t\t\tformat = format.replace('MM', month);\n\t\t\tformat = format.replace('DD', date);\n\t\t\tformat = format.replace('YYYY', year);\n\t\t}\n\t\telse if (dmy.test(format)) {\n\t\t\tformat = format.replace('MM', month);\n\t\t\tformat = format.replace('DD', date);\n\t\t\tformat = format.replace('YYYY', year);\n\t\t}\n\n\t\treturn format\n\t}\n\n    isLeapYear(year) {\n\t\treturn ( ( year % 4 == 0 ) && ( year % 100 != 0 ) ) || ( year % 400 == 0 );\n\t}\n\n    getNumber(month, year) {\n\t\tvar daysinmonths = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];\n\t\tif( this.isLeapYear.call( this, year ) && month == 1 ) {\n\t\t\treturn 29;\n\t\t}\n\t\telse {\n\t\t\treturn daysinmonths[month];\n\t\t}\n\t}\n\n    showtoday() {\n\t\tvar curDate = this.toDate();\n\n\t\tif (curDate.getMonth() != this.getData('viewDate').getMonth() || curDate.getYear() != this.getData('viewDate').getYear()) {\n\t\t\tthis.setData('showToday', true);\n\t\t}\n\t\telse {\n\t\t\tthis.setData('showToday', false);\n\t\t}\n\n\t\tif( this.getData('ltPropAlwaysShowToday') ){\n\t\t\tthis.setData( 'showToday', true);\n\t\t}\n\n\t}\n\n    reset(cur) {\n\t\tcur.setHours( 0 );\n\t\tcur.setMinutes( 0 );\n\t\tcur.setSeconds( 0 );\n\t\tcur.setMilliseconds( 0 );\n\t}\n\n    isInRange(current, start, end) {\n\t\tvar startDate, endDate;\n\n\t\tthis.reset(current);\n\n\t\tif (start === '' && end === '') {\n\t\t\treturn true;\n\t\t}\n\t\telse if (start !== '' && end === '') {\n\t\t\tstartDate = this.stringToDate(start, this.getData('ltPropFormat'));\n\t\t\tthis.reset(startDate);\n\n\t\t\tif (current >= startDate) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse if (start !== '' && end !== '') {\n\t\t\tstartDate = this.stringToDate(start, this.getData('ltPropFormat'));\n\t\t\tthis.reset(startDate);\n\n\t\t\tendDate = this.stringToDate(end, this.getData('ltPropFormat'));\n\t\t\tthis.reset(endDate);\n\n\t\t\tif (current >= startDate && current <= endDate) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tendDate = this.stringToDate(end, this.getData('ltPropFormat'));\n\t\t\tthis.reset(endDate);\n\n\t\t\tif (current <= endDate) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n    checkDate(current) {\n\t\tvar start = this.getData( 'ltPropMinDate' ) || '', \n\t\tend = this.getData( 'ltPropMaxDate' ) || '';\n\n\t\treturn this.isInRange( current, start, end );\n\t}\n\n    getNumberOfFirstRowDates(firstday) {\n\t\tvar startDayOfMonth = this.getData( 'ltPropStartWeekDay' ), \n\t\tfirstRowDays;\n\n\t\tif( firstday == 0 ) {\n\t\t\tfirstRowDays = startDayOfMonth === 0 ? 7 : startDayOfMonth;\n\t\t}\n\t\telse {\n\t\t\tif (firstday < startDayOfMonth) {\n\t\t\t\tfirstRowDays = startDayOfMonth - firstday;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfirstRowDays = 7 - (firstday - startDayOfMonth);\n\t\t\t}\n\t\t}\n\n\t\treturn firstRowDays;\n\n\t}\n\n    getNumberToSubtract(firstday) {\n\t\tvar numberToSubtract, startDayOfMonth = this.getData( 'ltPropStartWeekDay' );\n\n\t\tif (firstday == 0) {\n\t\t\tnumberToSubtract = startDayOfMonth == 0 ? 0 : 7 - startDayOfMonth;\n\t\t}\n\t\telse {\n\t\t\tif (firstday < startDayOfMonth) {\n\t\t\t\tnumberToSubtract = 7 - (startDayOfMonth - firstday);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnumberToSubtract = firstday - startDayOfMonth;\n\t\t\t}\n\t\t}\n\n\t\treturn numberToSubtract;\n\t}\n\n    getFirstDay(cur) {\n\t\tvar date = cur.getDate(), day = cur.getDay(), first;\n\n\t\tfirst = date - Math.floor(date / 7) * 7 - 1;\n\t\tfirst = day - first;\n\n\t\tif (first < 0) {\n\t\t\tfirst = 7 - first;\n\t\t}\n\n\t\treturn first;\n\t}\n\n    getRemainingDays(numberOfDaysInMonth, firstRowDays) {\n\t\tvar rem = numberOfDaysInMonth - firstRowDays;\n\t\trem = rem - 28;\n\n\t\treturn rem;\n\t}\n\n    inc(rem, num) {\n\t\tvar preventAddingRows = this.getData( 'ltPropPreventAddingRows' );\n\n\t\tif (preventAddingRows) {\n\t\t\treturn num;\n\t\t}\n\n\t\tif (rem > 0 && num == 6) {\n\t\t\treturn 7;\n\t\t}\n\n\t\treturn num;\n\t}\n\n    getFirstDateOfDateView() {\n\t\tvar cur = this.getData( 'viewDate' ), \n\t\tfirstday =  this.getFirstDay( cur ),\n\t\tmonth = cur.getMonth(), year = cur.getFullYear(),\n\t\tcalStartDate = new Date( month + 1 + '/1/' + year ),\n\t\tnumberToSubtract = this.getNumberToSubtract( firstday );\n\n\t\tcalStartDate.setDate( calStartDate.getDate() - numberToSubtract );\n\n\t\treturn calStartDate;\n\t}\n\n    getNumberOfRowsToDisplay() {\n\t\tvar numberOfRows = this.getData( 'ltPropNumberOfRows' ),\n\t\tcur = this.getData( 'viewDate' ),\n\t\tfirstday = this.getFirstDay( cur ), \n\t\tnumberOfDaysInMonth = this.getNumber( cur.getMonth(), cur.getFullYear() ),\n\t\tfirstRowDays = this.getNumberOfFirstRowDates( firstday ),\n\t\trem = this.getRemainingDays( numberOfDaysInMonth, firstRowDays );\n\n\t\treturn this.inc( rem, numberOfRows );\n\t}\n\n    setDatesFunction() {\n\t\tvar fillRows = this.getData( 'ltPropFillRows' ), \n\t\treachedNextMonth = false,\n\t\tcur = this.getData( 'viewDate' ),\n\t\tmonth = cur.getMonth(), \n\t\tresult = [], numberOfRows;\n\n\t\tvar weekNumber = this.getCurrentWeekNumber( cur );\n\t\tvar weekNumArr = [];\n\n\t\tnumberOfRows = this.getNumberOfRowsToDisplay();\n\n\t\tvar calStartDate = this.getFirstDateOfDateView();\n\t\t\n\t\t// Construct array\n\t\tfor (var i = 0; i < numberOfRows; i++) {\n\n\t\t\t// This is to ensure that we don't create an empty row when we reach the next month when fillRows is false.\n\t\t\tif (reachedNextMonth) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvar weekStartDate = this.cloneDateObj( calStartDate );\n\n\t\t\tresult.push( [] );\n\n\t\t\tfor( var j = 0; j < 7; j++ ) {\n\t\t\t\tif( \n\t\t\t\t\t( !fillRows && month !== calStartDate.getMonth() )\n\t\t\t\t\t|| ( fillRows && this.isYYFormat() && this.outsideBoundary( calStartDate ) && !this.isIso ) \n\t\t\t\t) {\n\t\t\t\t\tresult[ i ].push( { emptyBlock: true } );\n\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\treachedNextMonth = true;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresult[ i ].push( this.createDateCell( calStartDate, this.getCellClass( calStartDate ) ) );\n\t\t\t\t}\n\n\t\t\t\tcalStartDate.setDate( calStartDate.getDate() + 1 );\n\t\t\t}\n\n\t\t\tvar nextWeekStartDate = this.cloneDateObj( calStartDate );\n\t\t\tweekNumArr.push( this.createWeekCell( weekStartDate, nextWeekStartDate, weekNumber ) );\n\t\t\tweekNumber++;\n\t\t}\n\n\t\tthis.setData( 'matrix', result );\n\t\tthis.setData( 'weeknum', weekNumArr );\n\n\t\tif (this.shouldActivateCell()) {\n\t\t\tthis.activateRelevantCell();\n\t\t}\n\t}\n\n    createWeekCell(weekStartDate, nextWeekStartDate, weekNumber) {\n\t\treturn { class: this.getWeekClass( weekStartDate, nextWeekStartDate ), val: weekNumber }\n\t}\n\n    cloneDateObj(date) {\n\t\treturn new Date( date );\n\t}\n\n    getWeekClass(weekStartDate, nextWeekStartDate) {\n\t\tvar weekNumClass = 'lyteWeekNumberGrid',\n\t\tcur = this.getData( 'viewDate' ),\n\t\tweekEndDate = nextWeekStartDate.setDate( nextWeekStartDate.getDate() - 1 ),\n\t\ttodayDate = this.__ignoremin ? cur : this.toDate();\n\n\t\tif( this.isInRange( todayDate, weekStartDate, weekEndDate ) ) {\n\t\t\tweekNumClass += ' lyteCalCurWeekNum';\n\t\t}\n\n\t\treturn weekNumClass;\n\t}\n\n    isPresentInViewingMonth(currentProcessedDate) {\n\t\tvar viewingMonth = this.getData( 'viewDate' ).getMonth(),\n\t\tcurrentProcessedMonth = currentProcessedDate.getMonth();\n\n\t\treturn viewingMonth === currentProcessedMonth\n\t}\n\n    isRangeGiven() {\n\t\treturn ( this.getData( 'ltPropMinDate' ) || \"\" ) !== \"\" || ( this.getData( 'ltPropMaxDate' ) || \"\" ) !== \"\";\n\t}\n\n    getCellClass(currentProcessedDate) {\n\t\tvar clsname = 'lyteCalCdate', \n\t\tisRangeGiven = this.isRangeGiven(),\n\t\tisInRange = this.checkDate( currentProcessedDate ),\n\t\tdisabledDates = this.getDisabledDates(),\n\t\tisDisabled = this.isDisabled( currentProcessedDate, disabledDates ),\n\t\tselectionType = this.getData( 'ltPropSelectionType' ) || 'day',\n\t\tcurSelectedDate = this.getSelectedDateObj(),\n\t\tcur = this.getData( 'viewDate' ), \n\t\ttodayDate = this.__ignoremin ? cur : this.toDate();\n\n\t\tif( !this.isPresentInViewingMonth( currentProcessedDate ) ) {\n\t\t\tclsname += ' lyteCalDiffMonth';\n\n\t\t\tif( !isRangeGiven ) {\n\t\t\t\tclsname += ' lyteCalGray';\n\t\t\t}\n\n\t\t\t// Out of range in different month\n\t\t\telse if( !isInRange ) {\n\t\t\t\tclsname += ' lyteCalDisabled';\n\t\t\t}\t\t\n\t\t}\n\n\t\t// Out of range in same month\n\t\telse if( isRangeGiven \n\t\t\t&& !isInRange ) {\n\t\t\tclsname += ' lyteCalDisabled';\n\t\t}\n\n\t\tif( isDisabled ) {\n\t\t\tclsname += ' lyteCalendarDisabledDate';\n\t\t}\n\n\t\t// select-date might be some internal property used somewhere\n\t\tif( selectionType === 'day' && this.isSelectedDate( currentProcessedDate, curSelectedDate ) && this.getData( 'selectDate' ) ) {\n\t\t\tclsname += ' lyteCalSel';\n\t\t}\n\n\t\tif( selectionType === 'week' ) {\n\t\t\tclsname += ' ' + this.getWeekSelectedClass( currentProcessedDate );\n\t\t}\n\n\t\tif( \n\t\t\ttodayDate.getMonth() === currentProcessedDate.getMonth() \n\t\t\t&& todayDate.getDate() === currentProcessedDate.getDate() \n\t\t\t&& todayDate.getYear() === currentProcessedDate.getYear() ) {\n\n\t\t\tclsname += ' lyteCalToday';\n\t\t}\n\t\t\n\t\tclsname += this.addWeekEndClass( currentProcessedDate, isDisabled );\n\t\tclsname += this.addHolidayClass( currentProcessedDate, isDisabled );\n\t\tclsname += ' lyteCalTableCell';\n\n\t\treturn clsname;\n\t}\n\n    addWeekEndClass(currentProcessedDate, isDisabled) {\n\t\tvar clsname = '';\n\t\tvar holidayDates = this.getHolidayDates();\n\n\t\tif( this.isWeekend( currentProcessedDate ) ) {\n\t\t\tclsname += ' lyteCalWeekend';\t//only weekend\n\n\t\t\t/* ltPropDisableWeekends property should disable all weekends whether they are present in lt-prop-disabled-dates or not*/\n\t\t\tif( this.getData('ltPropDisableWeekends') && !isDisabled ){\n\t\t\t\tclsname += ' lyteCalendarDisabledDate'; \n\t\t\t}\n\n\t\t\tif( this.getData('ltPropHighlightWeekendHolidays') && this.isHoliday( currentProcessedDate, holidayDates ) ){\n\t\t\t\tclsname += ' lyteCalWeekendHoliday'; \t//weekend and holiday \n\t\t\t}\n\t\t}\n\n\t\treturn clsname;\n\t}\n\n    addHolidayClass(currentProcessedDate, isDisabled) {\n\t\tvar clsname = '';\n\t\tvar holidayDates = this.getHolidayDates();\n\n\t\tif( this.isHoliday( currentProcessedDate, holidayDates ) ) {\n\t\t\tclsname += ' lyteCalHoliday';\n\n\t\t\t/* ltPropDisableHolidays property should disable all holidays whether they are present in lt-prop-disabled-dates or not*/\n\t\t\tif( this.getData('ltPropDisableHolidays') && !isDisabled ){\n\t\t\t\tclsname += ' lyteCalendarDisabledDate';\n\t\t\t}\n\t\t}\n\n\t\treturn clsname;\n\t}\n\n    createDateCell(calStartDate, clsname) {\n\t\tvar obj = {},\n\t\tformat = this.getData( 'ltPropFormat' );\n\n\t\tobj.date = calStartDate.getDate();\n\t\tobj.id = this.generateRandomId();\n\t\tobj.clsname = clsname;\n\t\tobj.val = this.getDateFromFormat( calStartDate, format );\n\n\t\treturn obj;\n\t}\n\n    isSelectedDate(date, selectedDate) {\n\t\tvar isMultiple = this.getData( 'ltPropMultiple' );\n\n\t\tif (isMultiple) {\n\t\t\treturn this.isDateInArray(selectedDate, date);\n\t\t}\n\t\telse {\n\t\t\treturn selectedDate !== 'nodate' && selectedDate !== 'Invalid Date' && this.isSameDate(date, selectedDate);\n\t\t}\n\t\t\n\t}\n\n    isDateInArray(dateArr, date) {\n\t\tdateArr = dateArr || [];\n\n\t\tfor (var i = 0; i < dateArr.length; i++) {\n\t\t\tif (this.isSameDate(date, dateArr[i])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n    isSameDate(obj1, obj2) {\n\t\treturn obj1.getYear() == obj2.getYear()\n\t\t\t&& obj1.getMonth() == obj2.getMonth()\n\t\t\t&& obj1.getDate() == obj2.getDate();\n\t}\n\n    getSelectedDateObj() {\n\t\tvar isMultiple = this.getData( 'ltPropMultiple' ),\n\t\tselectedDates = this.getData( 'ltPropCurrentDates' ),\n\t\tthat = this,\n\t\tdateObj;\n\n\t\tif (isMultiple) {\n\t\t\treturn this.getDObjArrayFromStrings(selectedDates);\n\t\t}\n\t\telse {\n\t\t\tif (this.isIso) {\n\t\t\t\tdateObj = this.isoToDate(this.getData('ltPropIso'));\n\t\t\t} else {\n\t\t\t\tdateObj = this.getData('ltPropCurrentDate') ? this.stringToDate(this.getData('ltPropCurrentDate'), this.getData('ltPropFormat')) : 'nodate';\n\t\t\t}\n\n\t\t\treturn dateObj;\n\t\t}\n\n\t}\n\n    getDObjArrayFromStrings(dates) {\n\t\tvar that = this;\n\n\t\tdates = dates || [];\n\n\t\treturn dates.map( function( date ) { \n\t\t\treturn that.stringToDate( date, that.getData( 'ltPropFormat' ) );\n\t\t} );\n\t}\n\n    getDisabledDates() {\n\t\tvar disabledDates = this.getData( 'ltPropDisabledDates' );\n\n\t\treturn this.getDObjArrayFromStrings( disabledDates );\n\t}\n\n    isDisabled(date, disabledDates) {\n\t\treturn this.isDateInArray( disabledDates, date );\n\t}\n\n    getWeekSelectedClass(currentDate) {\n\t\tvar selectedWeek = this.getData( 'ltPropCurrentWeek' ) || [],\n\t\tweekStart = selectedWeek[ 0 ] || '',\n\t\tweekEnd = selectedWeek[ 1 ] || '',\n\t\tformat = this.getData( 'ltPropFormat' );\n\n\t\tweekStart = this.stringToDate(weekStart, format);\n\t\tweekEnd = this.stringToDate(weekEnd, format);\n\n\t\tif (weekStart === 'Invalid Date' || weekEnd === 'InvalidDate' || currentDate < weekStart || currentDate > weekEnd) {\n\t\t\treturn ''\n\t\t}\n\t\telse {\n\t\t\treturn 'lyteCalWeekSel';\n\t\t}\n\t}\n\n    isWeekend(date) {\n\t\tvar day = date.getDay(),\n\t\t\tweekends = this.getData('ltPropWeekends') || [];\n\n\t\treturn !!~weekends.indexOf( day );\n\t}\n\n\tgetHolidayDates() {\n\t\tvar holidayDates = this.getData( 'ltPropHolidays' );\n\n\t\treturn this.getDObjArrayFromStrings( holidayDates );\n\t}\n\n\tisHoliday(date, holidayDates) {\n\t\treturn this.isDateInArray( holidayDates, date );\n\t}\n\n    shouldActivateCell() {\n\t\tvar disableNavigation = this.getData( 'ltPropDisableNavigation' ),\n\t\t/* input can set the lt-prop-current-date - so don't activate during observer changes because input might lose focus */\n\t\tisObserverCall = this.isFromCurrentDateObserver,\n\n\t\t\t/* don't focus when previous/next buttons are pressed */\n\t\t\tnavigationButtonPressed = this.navigationButtonPressed;\n\n\t\tthis.isFromCurrentDateObserver = false;\n\n\t\tthis.navigationButtonPressed = false;\n\n\t\treturn !disableNavigation && !isObserverCall && !navigationButtonPressed;\n\t}\n\n    /** \n\t * get proper month from user defined value\n\t * @param {String} mon - The current month\n\t *\n\t */\n\n    getProperMonth(val) {\n\t\tvar sm = {\n\t\t\t'jan': 1,\n\t\t\t'feb': 2,\n\t\t\t'mar': 3,\n\t\t\t'apr': 4,\n\t\t\t'may': 5,\n\t\t\t'jun': 6,\n\t\t\t'jul': 7,\n\t\t\t'aug': 8,\n\t\t\t'sep': 9,\n\t\t\t'oct': 10,\n\t\t\t'nov': 11,\n\t\t\t'dec': 12\n\t\t}, lg = {\n\t\t\t'january': 1,\n\t\t\t'february': 2,\n\t\t\t'march': 3,\n\t\t\t'april': 4,\n\t\t\t'may': 5,\n\t\t\t'june': 6,\n\t\t\t'july': 7,\n\t\t\t'august': 8,\n\t\t\t'september': 9,\n\t\t\t'october': 10,\n\t\t\t'november': 11,\n\t\t\t'december': 12\n\t\t}, ret\n\n\t\tval = val.toLowerCase();\n\t\tret = sm[val] || lg[val];\n\n\t\tif (!ret && ret !== 0) {\n\t\t\treturn parseFloat(val) - 1;\n\t\t}\n\n\t\treturn ret-1;\n\t}\n\n    /**\n\t * Checks if the date is a proper date for the corresponding month and year\n\t * @param {Number} year - The year of the date object\n\t * @param {Number} month - The month of the date object\n\t * @param {Number} date - The date value of the date object\n\t *\n\t */\n\n    isProperDate(year, month, date) {\n\t\tvar daysInMonth = this.getNumber( month, year );\n\n\t\tif (date <= daysInMonth) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n    /**\n\t * Return the date object for the given string and format\n\t * @param {String} dateString - The current date in the form of a string\n\t * @param {String} format - The format of the dateString\n\t *\n\t */\n\n    getDateObjFromString(dateString, format) {\n\t\ttry {\n\t\t\tvar vals = dateString.match(/([\\da-z]+)/ig), year, month,\n\t\t\t\tformat = format.toUpperCase(),\n\t\t\t\tsep = format.match(/([a-z]+)/ig),\n\t\t\t\tdate = this.toDate(), i = 0, order = ['Y', 'M', 'D'];\n\t\t\tdate.setDate(1);  //initialize the day to be 1 to avoid error for eg: 30 Feb if passed will generate 1 Mar as result.\n\n\t\t\tif (vals.length !== 3) {\n\t\t\t\treturn 'Invalid Date';\n\t\t\t}\n\n\t\t\twhile (i < sep.length) {\n\t\t\t\tvar ind = this.getOrderIndex(sep, order[i]);\n\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tdate.setFullYear(year = vals[ind]);\n\t\t\t\t}\n\t\t\t\telse if (i == 1) {\n\t\t\t\t\tmonth = this.getProperMonth(vals[ind]);\n\n\t\t\t\t\tif (month < 0 || month > 11) {\n\t\t\t\t\t\treturn 'Invalid Date';\n\t\t\t\t\t}\n\n\t\t\t\t\tdate.setMonth(month);\n\t\t\t\t}\n\t\t\t\telse if (i == 2) {\n\t\t\t\t\tif (!this.isProperDate(year, month, vals[ind])) {\n\t\t\t\t\t\treturn 'Invalid Date';\n\t\t\t\t\t}\n\n\t\t\t\t\tdate.setDate(vals[ind]);\n\t\t\t\t}\n\n\t\t\t\tif (date.toString() === 'Invalid Date') {\n\t\t\t\t\treturn date.toString();\n\t\t\t\t}\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\treturn date;\n\t\t}\n\t\tcatch (e) {\n\t\t\treturn 'Invalid Date';\n\t\t}\n\t}\n\n    getDateObjFromMoment(dateString, format) {\n\t\tvar momentObj, ret;\n\n\t\tformat = this.getRelevantFormat(format);\n\n\t\tif (!dateString) {\n\t\t\treturn 'Invalid Date';\n\t\t}\n\n\t\ttry {\n\t\t\tmomentObj = this.moment(dateString, format);\n\t\t\tret = momentObj.getDObj();\n\t\t}\n\t\tcatch (e) {\n\t\t\tret = 'Invalid Date';\n\t\t}\n\n\t\tif (Object.prototype.toString.call(ret) === '[object Date]') {\n\t\t\tif (isNaN(ret.getTime())) {\n\t\t\t\tret = 'Invalid Date';\n\t\t\t}\n\t\t}\n\n\t\treturn ret || 'Invalid Date';\n\t}\n\n    /**\n\t * Convert the string to date object based on the format\n\t * @param {String} cur - The current date of the user passed\n\t * @param {String} format - The format of the dates\n\t *\n\t */\n\n    stringToDate(cur, format) {\n\t\tvar ret;\n\n\t\tcur = this.convertToEnglish(cur);\n\n\t\tif (this.isMomentSupported) {\n\t\t\tret = this.getDateObjFromMoment(cur, format);\n\t\t}\n\t\telse {\n\t\t\tret = this.getDateObjFromString(cur, format);\n\t\t}\n\n\t\treturn ret;\n\t}\n\n    findISO() {\n\t\tthis.isIso = this.getData('ltPropIso') ? true : false;\n\t}\n\n    isoToDate(cur) {\n\t\tvar ret = $L.moment(cur).getDObj();\n\t\tthis.data.ltPropCurrentDate = $L.moment(ret).format(this.getData('ltPropFormat'));\n\t\treturn ret;\n\t}\n\n    convertToEnglish(cur) {\n\t\tvar i18n = this.getData( 'ltPropI18n' ),\n\t\tformat = this.getData( 'ltPropFormat' );\n\n\t\tif (i18n) {\n\t\t\treturn this.moment(cur, format, { i18n: true }).format(format);\n\t\t}\n\n\t\treturn cur;\n\t}\n\n    getEnglishShorthand(cur) {\n\t\tvar months = this.getShortHands(), proper = -1, max = 0,\n\t\t\tshortHands = this.getData('shortHands');\n\n\t\tfor (var i = 0; i < months.length; i++) {\n\t\t\tif (!!~cur.indexOf(months[i]) && months[i].length > max) {\n\t\t\t\tproper = i;\n\t\t\t\tmax = months[i].length;\n\t\t\t}\n\t\t}\n\n\t\tif (proper !== -1) {\n\t\t\tcur = cur.replace(months[proper], this.getProperShortHand(shortHands[proper]));\n\t\t}\n\n\t\treturn cur;\n\t}\n\n    getShortHands() {\n\t\tvar shortHands = this.getData( 'shortHands' ), res = [];\n\n\t\tfor( var i = 0; i < shortHands.length; i++ ) {\n\t\t\tres.push( window._lyteUiUtils.i18n( shortHands[ i ] ) );\n\t\t}\n\n\t\treturn res;\n\t}\n\n    getProperShortHand(val) {\n\t\tif( val === 'short.may' ) {\n\t\t\treturn 'May';\n\t\t}\n\n\t\treturn val;\n\t}\n\n    getEnglishStandard(cur) {\n\t\tvar months = this.getStandardMonths(), englishMonths = this.getData( 'monthNames' ),\n\t\tproper = -1, max = 0;\n\n\t\tfor (var i = 0; i < months.length; i++) {\n\t\t\tif (!!~cur.indexOf(months[i]) && months[i].length > max) {\n\t\t\t\tproper = i;\n\t\t\t\tmax = months[i].length;\n\t\t\t}\n\t\t}\n\n\t\tif (proper !== -1) {\n\t\t\tcur = cur.replace(months[proper], englishMonths[proper]);\n\t\t}\n\n\t\treturn cur;\n\t}\n\n    getStandardMonths() {\n\t\tvar monthNames = this.getData( 'monthNames' ), res = [];\n\n\t\tfor( var i = 0; i < monthNames.length; i++ ) {\n\t\t\tres.push( window._lyteUiUtils.i18n( monthNames[ i ] ) );\n\t\t}\n\n\t\treturn res;\n\t}\n\n    getOrderIndex(objArr, match) {\n\t\tfor(var i = 0; i < objArr.length; i++){\n\t\t\tif(objArr[i].charAt(0) === match){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n    buildYears() {\n\t\t/*var yearBounds = this.buildMinAndMaxYear(),*/\n\t\tvar maxYear = 2100,\n\t\t\tminYear = 1900, i, years = [];\n\n\t\tfor (i = minYear; i <= maxYear; i++) {\n\t\t\tyears.push(i.toString());\n\t\t}\n\t\t// if(this.isIso){\n\t\t// \tyears.push( $L.moment(this.getData('ltPropIso')).get('fullYear') )\n\t\t// }\n\t\tthis.setData( 'years', years );\n\t}\n\n    /*buildMinAndMaxYear: function() {\n\t\t\t\n\t\tvar currentDate = this.toDate();\n\t\tvar isYYFormat = this.isYYFormat(),\n\t\tcurrentYear = currentDate.getFullYear(),\n\t\tdateBounds = this.isMomentSupported ? $L.moment() : { uL: 19, lL: 80 },\n\t\tvalueToAdd = dateBounds.uL,\n\t\tvalueToRemove = dateBounds.lL;\n\n\t\treturn {\n\t\t\tmaxYear: isYYFormat ? currentYear + valueToAdd : 2100,\n\t\t\tminYear: isYYFormat ? currentYear - valueToRemove : 1900\n\t\t};\n\n\t},*/\n\n    setAndBuildView(viewType, event, preventCallback) {\n\t\tvar oldView = this.getData( 'viewType' ),\n\t\tnewView = viewType;\n\n\t\tthis.setData('viewType', viewType);\n\n\t\tif (viewType === 'monthView') {\n\t\t\tthis.buildMonthView();\n\t\t}\n\t\telse if (viewType === 'decadeView') {\n\t\t\tthis.buildDecadeView();\n\t\t\tthis.setData('showToday', false);\n\t\t}\n\t\telse if (viewType === 'dateView') {\n\t\t\tthis.buildDateView();\n\t\t}\n\n\t\tif( this.getData('ltPropAlwaysShowToday') ){\n\t\t\tthis.setData( 'showToday', true );\n\t\t}\n\t\t// pressing the today button should not fire the viewChange when it is in the dateview\n\t\tif (!preventCallback && (oldView !== newView)) {\n\t\t\tif (this.getMethods('onViewChange')) {\n\t\t\t\tthis.executeMethod('onViewChange', event, viewType, this);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n    buildDateView() {\n\t\tthis.buildDateViewHeader();\n\t\tthis.buildDateViewContent();\n\t\tthis.showtoday();\n\t}\n\n    buildDateViewHeader() {\t\t\n\t\tvar viewDate = this.getData( 'viewDate' );\n\t\tvar year = viewDate.getFullYear();\n\t\tvar month = viewDate.getMonth();\n\t\tvar currentYear = viewDate.getFullYear();\n\t\tvar numberOfYearsFromDecadeStart = currentYear % 10;\n\t\tvar decadeStart = currentYear - numberOfYearsFromDecadeStart;\n\t\tvar decadeEnd = decadeStart + 9;\n\n\t\tthis.setData( 'monthHeader', this.getMonthHeader() );\n\t\tthis.setData( 'ltPropCurrentDisplayMonth', month );\n\t\tthis.setData( 'ltPropCurrentDisplayYear', year );\n\t\tthis.setData('ltPropCurrentDisplayDecade',decadeStart + '-' + decadeEnd);\n\n\t}\n\n    buildDateViewContent() {\n\t\tthis.setDatesFunction();\n\t}\n\n    buildMonthView() {\n\t\tthis.buildMonthViewHeader();\n\t\tthis.buildMonthViewContent();\n\t\tthis.showtoday();\n\t\tthis.activateCell( this.getActiveCell() );\n\t}\n\n    buildMonthViewHeader() {\n\t\tvar viewDate = this.getData( 'viewDate' );\n\t\tvar year = viewDate.getFullYear();\n\t\tvar currentYear = viewDate.getFullYear();\n\t\tvar numberOfYearsFromDecadeStart = currentYear % 10;\n\t\tvar decadeStart = currentYear - numberOfYearsFromDecadeStart;\n\t\tvar decadeEnd = decadeStart + 9;\n\n\t\tthis.setData( 'currentYear', year );\n\t\tthis.setData( 'ltPropCurrentDisplayYear', year );\n\t\tthis.setData('ltPropCurrentDisplayDecade',decadeStart + '-' + decadeEnd);\n\n\t}\n\n    buildMonthViewContent() {\n\t\tvar systemValues = this.getData( 'monthSystemValues' ),\n\t\tdisplayValue = this.getData( 'shortHands' ),\n\t\trowCount = 3, columnCount = 4,\n\t\trowIterator = 0, columnIterator,\n\t\tresult = [], indexOfMonth;\n\n\t\tfor (; rowIterator < rowCount; rowIterator++) {\n\t\t\tresult.push([]);\n\n\t\t\tfor (columnIterator = 0; columnIterator < columnCount; columnIterator++) {\n\t\t\t\tindexOfMonth = (rowIterator * columnCount) + columnIterator;\n\n\t\t\t\tresult[rowIterator].push(\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayValue: window._lyteUiUtils.i18n( displayValue[ indexOfMonth ] ),\n\t\t\t\t\t\tsystemValue: systemValues[ indexOfMonth ],\n\t\t\t\t\t\tclass: this.getProperClassForMonthView( indexOfMonth )\n\t\t\t\t\t} \n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tthis.setData( 'monthViewData', result );\n\t}\n\n    getProperClassForMonthView(month) {\n\t\tvar viewDate = this.getData( 'viewDate' ),\n\t\tviewYear = viewDate.getFullYear(),\n\t\ttodayMonth = this.getCurrentMonth(),\n\t\ttodayYear = this.getCurrentYear(),\n\t\tformat = this.getData( 'ltPropFormat' ),\n\t\tcurDate = this.stringToDate( this.getData( 'ltPropCurrentDate' ), format ),\n\t\tpreviousActiveDate = this.getData( 'previousActiveCellDate' ) || '',\n\t\tpreviousActiveMonth = this.getData( 'monthSystemValues' ).indexOf( previousActiveDate ),\n\t\tret = 'lyteCalTableCell', curMonth, selectedMonth = this.getData( 'ltPropCurrentMonth' );\n\n\t\tret += todayYear === viewYear && month === todayMonth ? ' lyteDrillCalCurrentMonth' : '';\n\n\t\tif (previousActiveMonth !== -1) {\n\t\t\tret += month === previousActiveMonth ? ' lyteCalNavCell' : '';\n\t\t}\n\t\telse if (curDate !== 'Invalid Date') {\n\t\t\tcurMonth = curDate.getMonth();\n\t\t\tret += month === curMonth ? ' lyteCalNavCell' : '';\n\t\t}\n\t\telse {\n\t\t\tret += month === todayMonth ? ' lyteCalNavCell' : '';\n\t\t}\n\n\t\tif (selectedMonth === (month + 1).toString()) {\n\t\t\tret += ' lyteCalMonthSel';\n\t\t}\n\n\n\t\treturn ret;\n\t}\n\n    getCurrentYear() {\n\t\tvar date = this.toDate();\n\n\t\treturn date.getFullYear();\n\t}\n\n    getCurrentMonth() {\n\t\tvar date = this.toDate();\n\n\t\treturn date.getMonth();\n\t}\n\n    buildDecadeView() {\n\t\tthis.buildDecadeViewHeader();\n\t\tthis.buildDecadeViewContent();\n\t\tthis.activateCell( this.getActiveCell() );\n\t}\n\n    buildDecadeViewHeader() {\n\t\tvar viewDate = this.getData( 'viewDate' ),\n\t\tcurrentYear = viewDate.getFullYear(),\n\t\tnumberOfYearsFromDecadeStart = currentYear % 10,\n\t\tdecadeStart = currentYear - numberOfYearsFromDecadeStart,\n\t\tdecadeEnd = decadeStart + 9;\n\n\t\tthis.setData( 'decadeStart', decadeStart );\n\t\tthis.setData( 'decadeEnd', decadeEnd );\n\t\tthis.setData('ltPropCurrentDisplayDecade',decadeStart + '-' + decadeEnd);\n\t}\n\n    buildDecadeViewContent() {\n\t\tvar viewDate = this.getData( 'viewDate' ),\n\t\tcurrentYear = viewDate.getFullYear(),\n\t\tnumberOfYearsFromDecadeStart = currentYear % 10,\n\t\tdecadeStart = currentYear - numberOfYearsFromDecadeStart,\n\t\tyearBounds = {minYear:1900 , maxYear:2100},\t\n\t\tisYYFormat = this.isYYFormat(),\n\t\tminYear = yearBounds.minYear, maxYear = yearBounds.maxYear,\t\n\t\trows = 3, columns = 4, i, j, result = [], year;\n\n\t\tfor( i = 0; i < rows; i++ ) {\n\t\t\tresult.push( [] );\n\n\t\t\tfor (j = 0; j < columns; j++) {\n\n\t\t\t\tyear = (decadeStart + i * 4 + j) - 1;\n\n\t\t\t\tif (isYYFormat) {\n\t\t\t\t\tresult[i].push(\n\t\t\t\t\t\t(year > maxYear || year < minYear) ? this.emptyCell() : this.currentYearCell(year, decadeStart)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresult[i].push(this.currentYearCell(year, decadeStart));\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tthis.setActiveDecadeCell(result);\n\n\t\tthis.setData( 'decadeViewData', result );\n\t}\n\n    emptyCell() {\n\t\treturn {\n\t\t\temptyBlock: true\n\t\t};\n\t}\n\n    currentYearCell(year, decadeStart) {\n\t\tvar decadeEnd = decadeStart + 9,\n\t\t\tclassVal = [], todayYear = this.getCurrentYear(),\n\t\t\tselectedYear = this.getData('ltPropCurrentYear');\n\n\t\tif (year < decadeStart || year > decadeEnd) {\n\t\t\tclassVal.push('lyteCalOtherDecadeCell');\n\t\t}\n\n\t\tif (todayYear === year) {\n\t\t\tclassVal.push('lyteDrillCalCurrentYear');\n\t\t}\n\n\t\tif (selectedYear === year.toString()) {\n\t\t\tclassVal.push('lyteCalYearSel')\n\t\t}\n\n\t\treturn {\n\t\t\tyear: year,\n\t\t\temptyBlock: false,\n\t\t\tclass: classVal.join(' ')\n\t\t}\n\t}\n\n    setActiveDecadeCell(result) {\n\t\tvar currentDate = this.getData( 'ltPropCurrentDate' ),\n\t\tformat = this.getData( 'ltPropFormat' ),\n\t\tcurrentDateObj = this.stringToDate( currentDate, format ),\n\t\tpreviousActiveDate = this.getData( 'previousActiveCellDate' ),\n\t\ttodayYear = this.getCurrentYear(),\n\t\tyearToUse = !isNaN( previousActiveDate ) ? +previousActiveDate : ( currentDateObj !== 'Invalid Date' ? currentDateObj.getFullYear() : todayYear ),\n\t\tfirstCell = result[ 0 ][ 0 ], firstRenderedYear = firstCell.year, lastCell = result[ result.length - 1 ][ result[ result.length - 1 ].length - 1 ], lastRenderedYear = lastCell.year, activeCellIndex;\n\n\t\tif (yearToUse >= firstRenderedYear && yearToUse <= lastRenderedYear) {\n\t\t\tresult[Math.floor((yearToUse - firstRenderedYear) / 4)][(yearToUse - firstRenderedYear) % 4].class += ' lyteCalNavCell';\n\t\t}\n\t\telse {\n\t\t\tif (yearToUse % 10 === 9) {\n\t\t\t\tactiveCellIndex = Math.abs(yearToUse - firstRenderedYear) < Math.abs(yearToUse - lastRenderedYear) ? 0 : 10;\n\t\t\t}\n\t\t\telse if (yearToUse % 10 === 0) {\n\t\t\t\tactiveCellIndex = Math.abs(yearToUse - firstRenderedYear) < Math.abs(yearToUse - lastRenderedYear) ? 1 : 11;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tactiveCellIndex = (yearToUse % 10) + 1;\n\t\t\t}\n\n\n\t\t\tresult[Math.floor(activeCellIndex / 4)][activeCellIndex % 4].class += ' lyteCalNavCell';\n\t\t}\n\t}\n\n    buildNavigationalUI() {\n\t\tvar type = this.getData( 'ltPropHeaderType' );\n\n\t\tif (this.isDropdownHeader()) {\n\t\t\tthis.buildYears();\n\t\t}\n\t}\n\n    init() {\n\t\tthis.findISO();\n\t}\n\n    setCalendarIdsForAria() {\n\t\tthis.setData( 'headerId', this.generateRandomId() );\n\t\tthis.setData( 'monthDropdownId', this.generateRandomId() );\n\t\tthis.setData( 'yearDropdownId', this.generateRandomId() );\n\t\tthis.setData( 'monthAriaObj', { 'aria-labelledby': this.getData( 'monthDropdownId' ) } );\n\t\tthis.setData( 'yearAriaObj', { 'aria-labelledby': this.getData( 'yearDropdownId' ) } );\n\t}\n\n    revertToSelected() {\n\t\tvar from = new Date( this.getData( 'viewDate' ).getTime() ), \n\t\tcur = this.getData( 'ltPropCurrentDate' ),\n\t\tformat = this.getData( 'ltPropFormat' ),\n\t\tcurDate = cur ? this.stringToDate( cur, format ) : this.toDate(),\n\t\ttoday = this.toDate(), event = {};\n\n\t\tif( curDate === 'Invalid Date' ) {\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tcurDate.setDate(1);\n\n\t\tvar to = new Date(curDate.getTime());\n\n\t\tthis.setData('viewDate', curDate);\n\t\tthis.setAndBuildView('dateView', event);\n\n\t\tif (to.getMonth() === today.getMonth() && to.getFullYear() === today.getFullYear()) {\n\t\t\tthis.setData('showToday', false);\n\t\t}\n\t\telse {\n\t\t\tthis.setData('showToday', true);\n\t\t}\n\t\t\n\t\tif( this.getData('ltPropAlwaysShowToday') ){\n\t\t\tthis.setData( 'showToday',true );\n\t\t}\n\t\tif( this.getMethods( 'onNavigate' ) \n\t\t\t&& ( from.getMonth() !== to.getMonth() \n\t\t\t|| from.getFullYear() !== to.getFullYear() ) \n\t\t) {\n\t\t\tthis.executeMethod('onNavigate', event, this.getDateFromFormat(from, this.getData('ltPropFormat')), this.getDateFromFormat(to, this.getData('ltPropFormat')), this);\n\t\t}\n\t}\n\n    addContainerClass() {\n\t\tvar type = this.getData( 'ltPropHeaderType' ),\n\t\tclassVal = [ 'lyteCalendarPopup' ];\n\n\t\tif (type === 'drilldown') {\n\t\t\tclassVal.push('lyteDrillDownCalendar');\n\t\t}\n\n\t\tthis.setData( 'containerClass', classVal.join( ' ' ) );\n\t}\n\n    checkForMoment() {\n\t\tthis.isMomentSupported = $L && $L.moment ? true : false; \n\t\tthis.isHavingTimezone = this.isMomentSupported && !!$L.moment()._timezone;\n\t}\n\n    buildViewDate() {\n\t\tif(this.isIso){\n\t\t\tvar viewDate = this.isoToDate( this.getData('ltPropIso') );\n\t\t}else{\n\t\t\tvar viewDate = this.determineViewDateFromUserInput();\n\t\t}\n\n\t\tif( viewDate === 'Invalid Date' ) {\n\t\t\tviewDate = this.toDate();\n\t\t}\n\n\t\tviewDate.setDate( 1 );\n\t\tthis.setData( 'viewDate', viewDate );\n\t}\n\n    determineViewDateFromUserInput() {\n\t\tvar viewDate, selectionType = this.getData( 'ltPropSelectionType' ), currentWeek, startDay;\n\n\t\tif( selectionType === 'week' ) {\n\t\t\tcurrentWeek = this.getData( 'ltPropCurrentWeek' ) || [];\n\n\t\t\tstartDay = currentWeek[ 0 ];\n\n\t\t\tviewDate = startDay ? \n\t\t\t\t\t\tthis.stringToDate( startDay, this.getData( 'ltPropFormat' ) ) \n\t\t\t\t\t\t: this.toDate();\n\t\t}\n\t\telse {\n\t\t\tviewDate = this.getData( 'ltPropCurrentDate' ) ? \n\t\t\t\t\t\tthis.stringToDate( this.getData( 'ltPropCurrentDate' ), this.getData( 'ltPropFormat' ) ) \n\t\t\t\t\t\t: this.toDate();\n\t\t}\n\t\t\n\t\treturn viewDate;\n\t}\n\n    initializeCalendar() {\n\t\t\n\t\tthis.buildNavigationalUI();\n\t\tthis.decideView();\n\t\t\t\n\t}\n\n\tdecideView() {\n\t\tvar selectionType = this.getData('ltPropSelectionType') || 'day';\n\n\t\tif (selectionType === 'day' || selectionType === 'week') {\n\t\t\tthis.setAndBuildView('dateView', undefined, true);\n\t\t}\n\t\telse if (selectionType === 'month') {\n\t\t\tthis.setAndBuildView('monthView', undefined, true);\n\t\t}\n\t\telse if( selectionType === 'year' ){\n\t\t\tthis.setAndBuildView( 'decadeView', undefined, true );\n\t\t}\n\t\telse{\n\t\t\tthis.setAndBuildView( 'dateView', undefined, true );\n\t\t}\n\t}\n\n    isDrilldown() {\n\t\tvar type = this.getData( 'ltPropHeaderType' );\n\n\t\treturn type === 'drilldown';\n\t}\n\n    didConnect() {\n\n\t\tif (!this.getData('navYield') && this.isDropdownHeader()) {\n\t\t\tthis.setData('monthDD', this.getMonthDropdown());\n\t\t\tthis.setData('yearDD', this.getYearDropdown());\n\t\t\tthis.setData('callFrmDidcnct', true);\n\t\t}\n\n\t\tif( this.getMethods('onDateHover') || this.getMethods('onMonthHover') || this.getMethods('onYearHover') ){\n\t\t\tthis.addListenerForHoverEvent();\n\t\t}\n\t}\n\n\taddListenerForHoverEvent() {\n\t\tvar parDiv = $L('div.lyteCalTableRowGroup')[0];\n\t\tparDiv.addEventListener('mouseover', function( event ){\n\t\t\tvar viewType = this.getData('viewType');\n\t\t\tif( event.target.classList.contains('lyteCalTableCell') ){\n\t\t\t\tvar target = event.target;\n\t\t\t\tif( this.getMethods('onDateHover') && viewType === 'dateView' ){\n\t\t\t\t\tthis.executeMethod('onDateHover', event, target.getAttribute('data-date'), this);\n\t\t\t\t}\n\t\t\t\telse if( this.getMethods('onMonthHover') && viewType === 'monthView' ){\n\t\t\t\t\tvar currentSelectedMonth = this.getData('monthSystemValues').indexOf(target.getAttribute('data-date')) + 1;\n\t\t\t\t\tthis.executeMethod('onMonthHover', event, currentSelectedMonth, this);\n\t\t\t\t}\n\t\t\t\telse if( this.getMethods('onYearHover') && viewType === 'decadeView' ){\n\t\t\t\t\tthis.executeMethod('onYearHover', event, target.getAttribute('data-date'), this);\n\t\t\t\t}\n\t\t\t}\n\t\t}.bind(this));\n\t}\n\n    isDropdownHeader() {\n\t\tvar type = this.getData( 'ltPropHeaderType' );\n\n\t\treturn type === 'picklist' || type === 'dropdown';\n\t}\n\n    getYearDropdown() {\n\t\tvar type = this.getData( 'ltPropHeaderType' ), \n\t\tret = this.$node.querySelector( '.lyteCalYearDD' );\n\n\t\tif (type === 'picklist') {\n\t\t\tret = ret.querySelector('lyte-dropdown');\n\t\t}\n\n\t\treturn ret;\n\t}\n\n    getMonthDropdown() {\n\t\treturn this.$node.querySelector( '.lyteCalMonthDD' );\n\t}\n\n    isWithinAllowedYears(date) {\n\t\tvar year = date.getFullYear();\n\n\t\tif (year >= 1900 && year <= 2100) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n    changeCurrentDate(set, val, event) {\n\t\tvar inter, to, from = new Date( this.getData( 'viewDate' ).getTime() ), \n\t\tfromDate, toDate, formattedDate, format = this.getData( 'ltPropFormat' ),\n\t\tisYYFormat = this.isYYFormat();\n\n\t\tif (set === 'Y') {\n\t\t\tinter = this.getData('viewDate');\n\t\t\tif (this.isIso) {\n\t\t\t\tformattedDate = $L.moment(this.getData('viewDate'));\n\t\t\t\tisYYFormat = false;\n\t\t\t} else {\n\t\t\t\tformattedDate = this.moment(this.getDateFromFormat(inter, format), format);\n\t\t\t}\n\n\t\t\tif (this.isMomentSupported) {\n\t\t\t\tif (val > 0) {\n\t\t\t\t\tto = this.moment(formattedDate, format).add(val, 'fullYear', isYYFormat).getDObj();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tto = this.moment(formattedDate, format).add(val, 'fullYear', isYYFormat).getDObj();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinter.setYear(inter.getFullYear() + val)\n\t\t\t\tto = new Date(inter.getTime())\n\t\t\t}\n\n\t\t\tthis.setData('viewDate', to);\n\t\t\tthis.buildDateView();\n\t\t}\n\t\telse if (set === 'M') {\n\t\t\tinter = this.getData('viewDate');\n\t\t\tif (this.isIso) {\n\t\t\t\tformattedDate = $L.moment(this.getData('viewDate'));\n\t\t\t\tisYYFormat = false;\n\t\t\t} else {\n\t\t\t\tformattedDate = this.moment(this.getDateFromFormat(inter, format), format);\n\t\t\t}\n\t\t\tif (this.isMomentSupported) {\n\t\t\t\tif (val > 0) {\n\t\t\t\t\tto = formattedDate.add(val, 'month', isYYFormat).getDObj();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tto = formattedDate.add(val, 'month', isYYFormat).getDObj();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinter.setMonth(inter.getMonth() + val)\n\t\t\t\tto = new Date(inter.getTime())\n\t\t\t}\n\n\t\t\tthis.setData('viewDate', to)\n\t\t\tthis.buildDateView();\n\t\t}\n\n\t\tfromDate = this.getDateFromFormat(from, this.getData('ltPropFormat'));\n\t\ttoDate = this.getDateFromFormat(to, this.getData('ltPropFormat'));\n\n\t\tif (this.getMethods('onNavigate')) {\n\t\t\tthis.executeMethod('onNavigate', event, fromDate, toDate, this)\n\t\t}\n\t}\n\n    changeCurrentYear(val, event) {\n\t\tvar viewDate = this.getData( 'viewDate' ),\n\t\tisMomentSupported = this.isMomentSupported,\n\t\tfullYear = viewDate.getFullYear(),\n\t\tformat = this.getData( 'ltPropFormat' ),\n\t\tisYYFormat = this.isYYFormat(),\n\t\tformattedDate = this.getDateFromFormat( viewDate, format ),\n\t\tfromDate = formattedDate,\n\t\ttoDate;\n\t\tif( isMomentSupported ) {\n\t\t\tformat = this.getRelevantFormat( format );\n\t\t\tif(this.isIso){\n\t\t\t\tformattedDate = this.moment(this.getData('viewDate'));\n\t\t\t\tisYYFormat = false;\n\t\t\t} else {\n\t\t\t\tformattedDate = this.moment(formattedDate, format);\n\t\t\t}\n\t\t\tviewDate = formattedDate.add(val, 'fullYear', isYYFormat).getDObj();\n\t\t}\n\t\telse {\n\t\t\tviewDate.setFullYear(fullYear + val);\n\t\t}\n\n\t\ttoDate = this.getDateFromFormat(viewDate, format);\n\n\t\tthis.setData('viewDate', viewDate);\n\n\t\tif (this.getMethods('onNavigate')) {\n\t\t\tthis.executeMethod('onNavigate', event, fromDate, toDate, this);\n\t\t}\n\t}\n\n    changeCurrentDecade(val, event) {\n\t\tvar viewDate = this.getData( 'viewDate' ),\n\t\tformat = this.getData( 'ltPropFormat' ),\n\t\tisMomentSupported = this.isMomentSupported,\n\t\tformattedDate = this.getDateFromFormat( viewDate, format ),\n\t\tisYYFormat = this.isYYFormat(),\n\t\tcurrentYear = viewDate.getFullYear(),\n\t\tfromDate = formattedDate,\n\t\ttoDate;\n\n\t\tformat = this.getRelevantFormat(format);\n\n\t\tif (isMomentSupported) {\n\t\t\tif (this.isIso) {\n\t\t\t\tformattedDate = this.moment(this.getData('viewDate'));\n\t\t\t\tisYYFormat = false;\n\t\t\t} else {\n\t\t\t\tformattedDate = this.moment(formattedDate, format);\n\t\t\t}\n\t\t\t// viewDate = formattedDate.add( val, 'fullYear', isYYFormat ).getDObj();\n\t\t\tviewDate = formattedDate.add(val * 10, 'fullYear', isYYFormat).getDObj();\n\t\t}\n\t\telse {\n\t\t\tviewDate.setFullYear(currentYear + 10 * val);\n\t\t}\n\n\t\ttoDate = this.getDateFromFormat(viewDate, format);\n\t\tthis.setData('viewDate', viewDate);\n\n\t\tif (this.getMethods('onNavigate')) {\n\t\t\tthis.executeMethod('onNavigate', event, fromDate, toDate, this);\n\t\t}\n\t}\n\n    /** \n\t * Get the proper calendar date item that was clicked\n\t * @param {Element} elem - represents the element that was clickedd\n\t *\n\t */\n    getProper(elem) {\n\t\twhile( elem \n\t\t\t&& !elem.classList.contains( 'lyteCalTableCell' ) \n\t\t) {\n\t\t\telem = elem.parentElement;\n\t\t}\n\n\t\treturn elem;\n\t}\n\n    convertToLang(val) {\n\t\tvar i18n = this.getData( 'ltPropI18n' ),\n\t\tformat = this.getData( 'ltPropFormat' );\n\n\t\tif (i18n) {\n\t\t\treturn this.moment(val, format).i18N(format);\n\t\t}\n\n\t\treturn val;\n\t}\n\n    moveToPrevious(val, event) {\n\t\tvar viewType = this.getData( 'viewType' );\n\n\t\tif (viewType === 'dateView') {\n\t\t\tthis.navigationButtonPressed = true;\n\t\t\tthis.changeCurrentDate(val, -1, event);\n\t\t}\n\t\telse if (viewType === 'monthView') {\n\t\t\tthis.changeCurrentYear(-1, event);\n\t\t\tthis.buildMonthView();\n\t\t}\n\t\telse if (viewType === 'decadeView') {\n\t\t\tthis.changeCurrentDecade(-1, event);\n\t\t\tthis.buildDecadeView();\n\t\t}\n\t}\n\n    moveToNext(val, event) {\n\n\t\tvar viewType = this.getData('viewType');\n\n\t\tif (viewType === 'dateView') {\n\t\t\tthis.navigationButtonPressed = true;\n\t\t\tthis.changeCurrentDate(val, 1, event);\n\t\t}\n\t\telse if (viewType === 'monthView') {\n\t\t\tthis.changeCurrentYear(1, event);\n\t\t\tthis.buildMonthView();\n\t\t}\n\t\telse if (viewType === 'decadeView') {\n\t\t\tthis.changeCurrentDecade(1, event);\n\t\t\tthis.buildDecadeView();\n\t\t}\n\t}\n\n    changeToMonthView(event) {\n\t\tthis.setAndBuildView( 'monthView', event );\n\t}\n\n    changeToDecadeView(event) {\n\t\tthis.setAndBuildView( 'decadeView', event );\n\t}\n\n    selectHighlightedCell(event) {\n\t\tvar viewType = this.getData( 'viewType' ),\n\t\theaderType = this.getData( 'ltPropHeaderType' );\n\n\t\tif (headerType !== 'drilldown' || viewType === 'dateView') {\n\t\t\tthis.makeSelection(event);\n\t\t}\n\t\telse if (viewType === 'monthView') {\n\t\t\tthis.monthSelected(event);\n\t\t}\n\t\telse {\n\t\t\tthis.yearSelected(event);\n\t\t}\n\t}\n\n    selectDate(event) {\n\t\tvar isMultiple = this.getData( 'ltPropMultiple' );\n\n\t\tif (isMultiple) {\n\t\t\tthis.selectMultiple(event);\n\t\t}\n\t\telse {\n\t\t\tthis.selectSingle(event);\n\t\t}\n\t}\n\n    selectMultiple(event) {\n\t\tvar dateCell = this.getProper( event.target );\n\n\t\tif (this.terminateSelection(this.fireBeforeCallback(event, dateCell))) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.alreadySelected(dateCell)) {\n\t\t\tthis.removeSelectedCell(dateCell);\n\t\t\tthis.removeSelected(dateCell);\n\n\t\t\tif (this.getMethods('onDateRemoved')) {\n\t\t\t\tthis.executeMethod('onDateRemoved', event, dateCell.getAttribute('data-date'), this);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis.selectCell(event);\n\t\t}\n\t}\n\n    terminateSelection(beforeCallbackReturnValue) {\n\t\treturn beforeCallbackReturnValue === false;\n\t}\n\n    fireBeforeCallback(event, dateCell) {\n\t\tif( this.alreadySelected( dateCell ) ) {\n\t\t\treturn this.fireBeforeRemove( event, dateCell );\n\t\t}\n\n\t\treturn this.fireBeforeAdd( event, dateCell );\n\t}\n\n    fireBeforeRemove(event, dateCell) {\n\t\tif( this.getMethods( 'onBeforeRemove' ) ) {\n\t\t\treturn this.executeMethod( 'onBeforeRemove', event, dateCell.getAttribute( 'data-date' ), this );\n\t\t}\n\t}\n\n    fireBeforeAdd(event, dateCell) {\n\t\tif( this.getMethods( 'onBeforeAdd' ) ) {\n\t\t\treturn this.executeMethod( 'onBeforeAdd', event, dateCell.getAttribute( 'data-date' ), this );\n\t\t}\n\t}\n\n    alreadySelected(cell) {\n\t\treturn cell.classList.contains( 'lyteCalSel' );\n\t}\n\n    removeSelected(cell) {\n\t\tvar dateToRemove = cell.getAttribute( 'data-date' ),\n\t\tselectedDates = this.getData( 'ltPropCurrentDates' ) || [],\n\t\tindexToRemove = selectedDates.indexOf( dateToRemove );\n\n\t\tif( !!~indexToRemove ) {\n\t\t\tthis.$addon.arrayUtils( selectedDates, 'removeAt', indexToRemove );\n\t\t}\n\t}\n\n    selectSingle(event) {\n\t\tthis.removeDayHighlights();\n\t\tthis.selectCell( event );\n\t}\n\n    selectCell(event) {\n\t\tvar target = this.getProper( event.target );\n\t\t\n\t\tthis.setSelected( target );\n\n\t\ttarget.classList.add('lyteCalSel');\n\t\ttarget.setAttribute('aria-selected', 'true');\n\t\ttarget.setAttribute('tabindex', '1');\n\n\t\tif (this.getMethods('onDateSelected')) {\n\t\t\tthis.executeMethod('onDateSelected', event, target.getAttribute('data-date'), this);\n\t\t}\n\t}\n\n    setSelected(cell) {\n\t\tvar isMultiple = this.getData( 'ltPropMultiple' ),\n\t\tcurDate = this.convertToLang( cell.getAttribute( 'data-date' ) );\n\n\t\tthis.setData('preventObs', true);\n\n\t\tif( isMultiple ) {\n\t\t\tthis.$addon.arrayUtils( this.getData( 'ltPropCurrentDates' ), 'push', curDate );\n\t\t}\n\t\telse {\n\t\t\tthis.setData('ltPropCurrentDate', curDate);\n\t\t}\n\t\t\n\t\tthis.setData( 'preventObs', false );\n\t}\n\n\tmonthSelected(event) {\n\t\tvar viewDate = this.getData('viewDate'),\n\t\t\tcurrentYear = viewDate.getFullYear(),\n\t\t\ttarget = this.getProper(event.target),\n\t\t\tcurrentSelectedMonth = target.getAttribute('data-date'),\n\t\t\tisDrilldown = this.getData('ltPropHeaderType') === 'drilldown';\n\n\t\tcurrentSelectedMonth = this.getData('monthSystemValues').indexOf(currentSelectedMonth) + 1;\n\n\t\tthis.setData('viewDate', new Date(currentSelectedMonth + '/1/' + currentYear));\n\n\t\tif (isDrilldown) {\n\t\t\tthis.setAndBuildView('dateView', event);\n\t\t}\n\n\t\tthis.removeMonthHighlight();\n\t\tthis.addMonthHighlight(target);\n\n\t\tthis.setData('ltPropCurrentMonth', currentSelectedMonth);\n\n\t\tif (this.getMethods('onMonthSelected')) {\n\t\t\tthis.executeMethod('onMonthSelected', event, (currentSelectedMonth || \"\").toString(), this);\n\t\t}\n\n\t\tthis.focusActiveCell();\n\t}\n\n    removeMonthHighlight() {\n\t\tvar month = this.$node.querySelector( '.lyteCalMonthSel' );\n\n\t\tif (month) {\n\t\t\tmonth.classList.remove('lyteCalMonthSel');\n\t\t\tmonth.removeAttribute('aria-selected');\n\t\t}\n\t}\n\n    addMonthHighlight(cell) {\n\t\tcell.classList.add( 'lyteCalMonthSel' );\n\t\tcell.setAttribute( 'aria-selected', 'true' );\n\t}\n\n    yearSelected(event) {\n\t\tvar viewDate = this.getData( 'viewDate' ),\n\t\ttarget = this.getProper( event.target ),\n\t\tcurrentSelectedYear = target.getAttribute( 'data-date' ),\n\t\tisDrilldown = this.getData( 'ltPropHeaderType' ) === 'drilldown';\n\n\t\tviewDate.setYear(currentSelectedYear);\n\t\tthis.setData('viewDate', viewDate);\n\n\t\tif (isDrilldown) {\n\t\t\tthis.setAndBuildView('monthView', event);\n\t\t}\n\n\t\tthis.removeYearHighlight();\n\t\tthis.addYearHighlight(target);\n\n\t\tthis.setData('ltPropCurrentYear', currentSelectedYear);\n\n\t\tif (this.getMethods('onYearSelected')) {\n\t\t\tthis.executeMethod('onYearSelected', event, currentSelectedYear, this);\n\t\t}\n\n\t\tthis.focusActiveCell();\n\t}\n\n    removeYearHighlight() {\n\t\tvar year = this.$node.querySelector( '.lyteCalYearSel' );\n\n\t\tif (year) {\n\t\t\tyear.classList.remove('lyteCalYearSel');\n\t\t\tyear.removeAttribute('aria-selected');\n\t\t}\n\t}\n\n    addYearHighlight(cell) {\n\t\tcell.classList.add( 'lyteCalYearSel' );\n\t\tcell.setAttribute( 'aria-selected', 'true' );\n\t}\n\n    focusDrillDownButton() {\n\t\tvar button = this.$node.querySelector( '.lyteDrillCalHeaderButton' );\n\n\t\tif (button) {\n\t\t\tbutton.focus();\n\t\t}\n\t}\n\n    makeSelection(event) {\n\t\tvar selectionType = this.getData( 'ltPropSelectionType' );\n\n\t\tif (selectionType === 'day') {\n\t\t\tthis.selectDate(event);\n\t\t}\n\t\telse {\n\t\t\tthis.selectWeek(event);\n\t\t}\n\t}\n\n    selectWeek(event) {\n\t\tif( !event ){\n\t\t\tvar dateCell = this.$node.querySelector('.lyteCalToday');\n\t\t}\n\t\telse {\n\t\t\tvar dateCell = this.getProper( event.target );\n\t\t}\n\n\t\tvar firstDayOfWeek = this.getFirstSelectableDay( dateCell ).getAttribute( 'data-date' ),\n\t\tlastDayOfWeek = this.getLastSelectableDay( dateCell ).getAttribute( 'data-date' );\n\n\t\tthis.removeDayHighlights();\n\t\tthis.addWeekHighlight(dateCell);\n\t\tthis.setData('ltPropCurrentWeek', [this.convertToLang(firstDayOfWeek), this.convertToLang(lastDayOfWeek)]);\n\n\t\tif (this.getMethods('onWeekSelected')) {\n\t\t\tthis.executeMethod('onWeekSelected', event, firstDayOfWeek, lastDayOfWeek, this);\n\t\t}\n\t}\n\n    removeDayHighlights() {\n\t\tthis.removeSelectedCell();\n\t\tthis.removeWeekHighlight();\n\t}\n\n    removeSelectedCell(cell) {\n\t\tvar node = cell || this.getSelectedCell();\n\n\t\tif (node) {\n\t\t\tnode.classList.remove('lyteCalSel');\n\t\t\tnode.removeAttribute('aria-selected');\n\t\t\tnode.setAttribute('tabindex', '-1');\n\t\t}\n\t}\n\n    getSelectedCell() {\n\t\treturn this.$node.querySelector( '.lyteCalSel' );\n\t}\n\n    removeWeekHighlight() {\n\t\tvar highlightedDays = this.$node.querySelectorAll( '.lyteCalWeekSel' );\n\t\tvar highlightedWeekNum = this.$node.querySelectorAll('.lyteCalWeekNumberSel');\n\n\t\tfor( var i = 0; i < highlightedDays.length; i++ ) {\n\t\t\thighlightedDays[ i ].classList.remove( 'lyteCalWeekSel' );\n\t\t\thighlightedDays[ i ].removeAttribute( 'aria-selected' );\n\t\t} \n\n\t\tfor( var i = 0; i < highlightedWeekNum.length; i++ ) {\n\t\t\thighlightedWeekNum[ i ].classList.remove( 'lyteCalWeekNumberSel' );\n\t\t\thighlightedWeekNum[ i ].removeAttribute( 'aria-selected' );\n\t\t} \n\t\t\n\t}\n\n    addWeekHighlight(dateCell) {\n\t\tvar firstSelectableDayOfWeek = this.getFirstSelectableDay( dateCell );\n\n\t\tvar day = firstSelectableDayOfWeek;\n\n\t\tif( this.getData('ltPropWeekNumber') ){\n\t\t\tvar parent = dateCell.parentElement;\n\t\t\tvar target = parent.querySelector('.lyteWeekNumberGrid');\n\n\t\t\tif( target ){\n\t\t\t\ttarget.classList.add('lyteCalWeekNumberSel');\n\t\t\t\ttarget.setAttribute( 'aria-selected', 'true' );\n\t\t\t}\n\t\t}\n\n\t\tdo {\n\t\t\tday.classList.add( 'lyteCalWeekSel' );\n\t\t\tday.setAttribute( 'aria-selected', 'true' );\n\n\t\t\tday = day.nextElementSibling;\n\t\t}while( day && day.getAttribute( 'data-selectable' ) === 'true' );\n\t}\n\n    getFirstSelectableDay(cell) {\n\t\tvar rowCells = cell.parentElement.children;\n\n\t\tfor( var i = 0; i < rowCells.length; i++ ) {\n\t\t\tif( rowCells[ i ].getAttribute( 'data-selectable' ) === \"true\" ) {\n\t\t\t\treturn rowCells[ i ];\n\t\t\t}\n\t\t}\n\t}\n\n    getLastSelectableDay(cell) {\n\t\tvar rowCells = cell.parentElement.children;\n\n\t\tfor( var i = rowCells.length - 1; i > -1; i-- ) {\n\t\t\tif( rowCells[ i ].getAttribute( 'data-selectable' ) === \"true\" ) {\n\t\t\t\treturn rowCells[ i ];\n\t\t\t}\n\t\t}\n\t}\n\n    getCurrentWeekNumber(currentDateObj) {\n\t\tvar curDateObj = new Date( currentDateObj );\t//clone\n\t\tvar weekNumCriteria = this.getData('ltPropWeekNumCriteria');\n\t\tvar startDate = 1;\n\t\tvar startWeekDay = this.getData('ltPropStartWeekDay');\n\t\tvar weekNum = 0;\n\n\t\tswitch( weekNumCriteria ){\n\t\t\tcase 1:\n\t\t\t\tstartDate = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t//find first thursday date( can provide option for user to select 'any' day instead of thursday )\n\t\t\t\tstartDate = this.getDateOfFirstDay( currentDateObj.getFullYear(), 4 ); // 4 -> thursday\n\t\t\t\tbreak;\n\n\t\t\tcase 3: \n\t\t\t\t//find first full week's first date\n\t\t\t\tstartDate = this.getDateOfFirstDay( currentDateObj.getFullYear(), this.getData('ltPropStartWeekDay') ); \n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tvar startDateObj = new Date( currentDateObj.getFullYear(), 0, startDate );\n\n\t\tthis.getDateObjToStartDay( curDateObj );\n\t\tthis.getDateObjToStartDay( startDateObj );\n\n\t\tvar itrDateObj = new Date( startDateObj );\n\n\t\twhile (itrDateObj <= curDateObj) {\n\t\t\tif (itrDateObj.getDay() === startWeekDay) { \n\t\t\t\tweekNum += 1;\n\t\t\t}\n\t\t\titrDateObj.setDate(itrDateObj.getDate() + 1); \n\t\t}\n\n\t\treturn weekNum;\n\t}\n\n    getDateOfFirstDay(year, day) {\n\t\tvar currDateObj = new Date( year, 0, 1 );\n\t\tfor( var i=0; i<7; i++ ){\n\t\t\tif( currDateObj.getDay() === day ){\n\t\t\t\tbreak;\n\t\t\t}  \n\t\t\tcurrDateObj.setDate( currDateObj.getDate()+1 );\n\t\t}\n\n\t\treturn currDateObj.getDate();\n\t}\n\n    getDateObjToStartDay(curDateObj) {\n\t\tvar startOfWeekDay = this.getData('ltPropStartWeekDay');\n\t\tfor( var it=0;it<7;it++ ){\n\t\t\tif( curDateObj.getDay() == startOfWeekDay ){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcurDateObj.setDate( curDateObj.getDate() - 1 );\n\t\t}\n\t}\n\n    static actions() {\n        return {\n            changeToMonthView: function( event ) {\n                this.changeToMonthView( event );\n                this.focusDrillDownButton();\t\n            },\n\n            changeToMonthViewOnKeys: function( event ) {\n                var keyCode = event.keyCode,\n                SPACE_KEY = 32,\n                ENTER_KEY = 13;\n\n                if( keyCode === ENTER_KEY || keyCode === SPACE_KEY ) {\n                    this.changeToMonthView( event );\n                    this.focusDrillDownButton();\t\n                }\n            },\n\n            changeToDecadeView: function( event ) {\n                this.changeToDecadeView( event );\n                this.focusActiveCell();\n            },\n\n            changeToDecadeViewOnKeys: function( event ) {\n                var keyCode = event.keyCode,\n                SPACE_KEY = 32,\n                ENTER_KEY = 13;\n\n                if( keyCode === ENTER_KEY || keyCode === SPACE_KEY ) {\n                    this.changeToDecadeView( event );\n                    this.focusActiveCell();\n                }\n            },\n\n            // Detecting a one finger swipe\n            record: function( event ) {\n                // This is stupid\n                this.setData( 'prev', false );\n\n                if( event.touches.length > 1 ) {\n                    this.setData( 'prev', true );\n\n                    return ;\n                }\n\n                var touch = event.targetTouches[ 0 ],\n                cords = {\n                    x: touch.clientX,\n                    y: touch.clientY\n                },\n                start = this.toDate().getTime();\n\n                this.setData( 'cords', cords );\n                this.setData( 'start', start );\n            },\n\n            decide: function( event ) {\n                var prev = this.getData( 'prev' );\n\n                // prev will be false only when you do a single finger swipe\n                // Multi finger swipes return out of execution\n                if( prev ) {\n                    return ;\n                }\n\n                var start = this.getData( 'cords' ),\n                x = start.x, y = start.y,\n                touch = event.changedTouches[ 0 ],\n                diffX = x - touch.clientX,\n                diffY = y - touch.clientY,\n                parent = this.$node.querySelector( '.lyteCalendarPopup' ),\n                rect = parent.getBoundingClientRect(),\n                width = rect.width,\n                height = rect.height,\n                xTolerance = width * 0.2,\n                yTolerance = height * 0.15,\n                begin = this.getData( 'start' ),\n                delay = ( this.toDate().getTime() ) - begin;\n\n                if( yTolerance > Math.abs( diffY ) \n                    && xTolerance < Math.abs( diffX ) \n                    && delay < 1000 \n                ) {\n                    if( diffX < 0 ) {\n                        this.changeCurrentDate( \"M\", -1, event );\n                    }\n                    else if( diffX > 0 ) {\n                        this.changeCurrentDate( \"M\", 1, event );\n                    }\n                }\n                \n            },\n\n            previousOnKeys: function( val, event ) {\n                var ENTER_KEY = 13, SPACE_KEY = 32, keyCode = event.keyCode;\n\n                if( event.keyCode === ENTER_KEY || event.keyCode === SPACE_KEY ) {\n                    this.moveToPrevious( val, event );\n                }\n\n            },\n\n            nextOnKeys: function( val, event ) {\n                var ENTER_KEY = 13, SPACE_KEY = 32, keyCode = event.keyCode;\n\n                if( keyCode === ENTER_KEY || keyCode === SPACE_KEY ) {\n                    this.moveToNext( val, event );\n                }\n            },\n\n            previous: function( val, event ) {\n                this.moveToPrevious( val, event );\n            },\n\n            next: function( val, event ) {\n                this.moveToNext( val, event );\n            },\n\n            yearSelected: function( event ) {\n                this.yearSelected( event );\n            },\n\n            monthSelected: function( event ) {\n                this.monthSelected( event );\n            },\n\n            dateSelected: function( event ) {\n                if( event.button !== 0 ) {\n                    return ;\n                }\n\n                this.makeSelection( event );\n            },\n\n            performNavigation: function( event ) {\n                var keyCode = event.keyCode,\n                ARROW_UP = 38,\n                ARROW_DOWN = 40,\n                ARROW_LEFT = 37,\n                ARROW_RIGHT = 39,\n                SPACE_KEY = 32, \n                ENTER_KEY = 13,\n                HOME_KEY = 36,\n                END_KEY = 35,\n                PAGE_UP = 33,\n                PAGE_DOWN = 34,\n                MONTH = 'M',\n                navDirection, cellsToMove, cell = event.target, actionType;\n\n                if( this.getData( 'ltPropDisableNavigation' ) ) {\n                    return ;\n                }\n\n                switch( keyCode ) {\n                    case ARROW_UP:\n                        navDirection = 'previous';\n                        actionType = 'up';\n                        cellsToMove = this.getCellsToMove( navDirection, actionType );\n                        this.moveBackward( event, navDirection, cellsToMove );\n                        event.preventDefault();\n                        break;\n\n                    case ARROW_DOWN:\n                        navDirection = 'next';\n                        actionType = 'down';\n                        cellsToMove = this.getCellsToMove( navDirection, actionType );\n                        this.moveForward( event, navDirection, cellsToMove );\n                        event.preventDefault();\n                        break;\n\n                    case ARROW_LEFT:\n                        navDirection = 'previous';\n                        cellsToMove = -1;\n                        this.moveBackward( event, navDirection, cellsToMove );\n                        event.preventDefault();\n                        break;\n\n                    case ARROW_RIGHT:\n                        navDirection = 'next';\n                        cellsToMove = 1;\n                        this.moveForward( event, navDirection, cellsToMove );\n                        event.preventDefault();\n                        break;\n                    case SPACE_KEY:\n                    case ENTER_KEY:\n                        if( this.isDisabledCell( cell ) ) {\n                            return ;\n                        }\n\n                        this.selectHighlightedCell( event );\n                        event.preventDefault();\n                        break;\n                    case HOME_KEY:\n                        navDirection = 'previous';\n                        this.moveToFirstCell( event, navDirection );\n                        event.preventDefault();\n                        break;\n                    case END_KEY:\n                        navDirection = 'next';\n                        this.moveToLastCell( event, navDirection );\n                        event.preventDefault();\n                        break;\n                    case PAGE_UP:\n                        this.previousNavigation( MONTH, event );\n                        event.preventDefault();\n                        break;\n                    case PAGE_DOWN:\n                        this.nextNavigation( MONTH, event );\n                        event.preventDefault();\n                        break;\n                }\n            },\n\n            today: function( event ) {\n                this.revert( event );\n                this.focusActiveCell();\n            },\n\n            todayOnKey: function( event ) {\n                var keyCode = event.keyCode,\n                SPACE_KEY = 32,\n                ENTER_KEY = 13;\n\n                if( keyCode === ENTER_KEY || keyCode === SPACE_KEY ) {\n                    this.revert( event );\n                    this.focusActiveCell();\n                }\n            },\n\n            curWeek: function( event ) {\n                //should entire row be focused? its been selected for now\n                \n                this.revert( event );\n                this.selectWeek();\n                // this.focusActiveRow();\n            },\n\n            curWeekOnKey: function( event ) {\n                var keyCodes = event.keyCode;\n\n                if( keyCodes === 13 || keyCodes === 32 ) {\n                    this.revert( event );\n                    this.selectWeek();\n                    // this.focusActiveRow();\n\n                }\n            },\n\n            curMonth: function( event ) {\n                this.revertToMonth( event );\n                // this.focusActiveCell();\n            },\n\n            curMonthOnKey: function( event ) {\n                var keycode = event.keyCode;\n\n                if( keycode === 13 || keycode === 32 ) {\n                    this.revertToMonth( event );\n                    // this.focusActiveCell();\n                }\n            },\n\n            curYear: function( event ) {\n                this.revertToYear( event );\n                // this.focusActiveCell();\n            },\n\n            curYearOnKey: function( event ) {\n                var keycode = event.keyCode;\n\n                if( keycode === 13 || keycode === 32 ) {\n                    this.revertToYear( event );\n                    // this.focusActiveCell();\n                }\n            }\n        };\n    }\n\n    static methods() {\n        return {\n            optionSelected : function(prop,event,selected,comp){\n                this.navigationButtonPressed = true;\n\n                if(prop == 'M') {\n                    // var index = comp.getData('ltPropOptions').indexOf(selected);\n                    var index = this.getData('monthNames').indexOf(selected);\n\n                    this.changeCurrentDate(prop, index - this.getData('viewDate').getMonth(),event);\n                }\n                else if(prop == 'Y') {\n                    this.changeCurrentDate(prop, parseInt(selected) - this.getData('viewDate').getFullYear(),event);\n                }\n            },\n\n            setClass: function( ev, comp ) {\n                var drop = comp.childComp,\n                rtl = window._lyteUiUtils.getRTL(),\n                dir = rtl ? 'right' : 'left',\n                arrow = drop.querySelector( '.lyteArrow' );\n\n                drop.classList.add( 'lyteCalendarDropdown' )\n                arrow.style[ dir ] = '20%';\n\n                if( rtl ) {\n                    arrow.style.left = 'auto';\n                }\n            }\n        };\n    }\n\n    static observers() {\n        return {\n            changeBodyContainerClass: function() {\n                var container = this.$node.querySelector( '.lyteCalTableContainer' ),\n                viewType = this.getData( 'viewType' ),\n                selectionType = this.getData( 'ltPropSelectionType' );\n\t\t\t\tvar isDrilldown = this.isDrilldown();\n\n                if( isDrilldown ) {\n                    if( viewType === 'dateView' ) {\n                        container.classList.remove( 'lyteDrillCalMonthView' );\n                        container.classList.remove( 'lyteDrillCalYearView' );\n                    }\n                    else if( viewType === 'monthView' ) {\n                        container.classList.add( 'lyteDrillCalMonthView' );\n                        container.classList.remove( 'lyteDrillCalYearView' );\n                    }\n                    else if( viewType === 'decadeView' ) {\n                        container.classList.remove( 'lyteDrillCalMonthView' );\n                        container.classList.add( 'lyteDrillCalYearView' );\n                    }\n                }\n\n\t\t\t\tthis.removeSelectionStyles();\n\t\t\t\tif( !isDrilldown ){\n\t\t\t\t\tif( selectionType === 'day' ) {\n\t\t\t\t\t\tcontainer.classList.add( 'lyteCalDaySelType' );\n\t\t\t\t\t}\n\t\t\t\t\telse if( selectionType === 'week' ) {\n\t\t\t\t\t\tcontainer.classList.add( 'lyteCalWeekSelType' );\n\t\t\t\t\t}\n\t\t\t\t\telse if( selectionType === 'month' ) {\n\t\t\t\t\t\tcontainer.classList.add( 'lyteCalMonthSelType' );\n\t\t\t\t\t}\n\t\t\t\t\telse if( selectionType === 'year' ){\n\t\t\t\t\t\tcontainer.classList.add( 'lyteCalYearSelType' );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.setData('ltPropSelectionType','day');\n\t\t\t\t\t\tcontainer.classList.add( 'lyteCalDaySelType' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if( viewType === 'dateView' ){\n\t\t\t\t\tif( selectionType === 'day' ) {\n\t\t\t\t\t\tcontainer.classList.add( 'lyteCalDaySelType' );\n\t\t\t\t\t}\n\t\t\t\t\telse if( selectionType === 'week' ) {\n\t\t\t\t\t\tcontainer.classList.add( 'lyteCalWeekSelType' );\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tthis.setData('ltPropSelectionType','day');\n\t\t\t\t\t\tcontainer.classList.add( 'lyteCalDaySelType' );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.setShowYearAccToView();\n                \n            }.observes( 'viewType', 'ltPropSelectionType' ).on( 'didConnect' ),\n\n\n\t\t\tyearObserver: function() {\n\t\t\t\tthis.setShowYearAccToView();\n\t\t\t}.observes( 'ltPropYear' ),\n\n            activateNavigation: function() {\n                if( !this.getData( 'ltPropActivateNavigation' ) ) {\n                    return ;\n                }\n\n                this.activateRelevantCell();\n\n                this.setData( 'ltPropActivateNavigation', false );\n\n            }.observes( 'ltPropActivateNavigation' ),\n\n            setMonthAndYearDropdown : function(){\n                if(!this.getData('navYield') && this.isDropdownHeader() && this.getData('monthDD') && this.getData('yearDD')){\n                    var monthHeaders = this.getData('monthHeader').split( ' ' ),\n                    format = this.getData( 'ltPropMonthHeaderFormat' ), \n                    lmd = /MMMM YYYY/ig,\n                    ld = /MMM YYYY/ig,\n                    monthArray = [],\n                    monthNames, value;\n\n                    if(arguments[0].item == \"callFrmDidcnct\"){\n                        if(lmd.test( format )){\n                            monthNames = this.getData('monthNames');\n                        }\n                        else if(ld.test(format)){\n                            monthNames = this.getData('shortHands');\n                        }\n                        for(var i=0;i<monthNames.length; i++){\n                            monthArray[i] = window._lyteUiUtils.i18n(monthNames[i]);\n                        }\n                        this.setData('monthNames',monthArray);\n                    }\n\n                    value = parseInt( monthHeaders[ 1 ] );\n\n                    this.removeOutOfRangeOption();\n                    \n                    if( this.outOfRange( value ) ) {\n                        this.addOutOfRangeOption( value );\n                    }\n                    // this.getData('monthDD').component.setData('ltPropOptions',monthArray);\n                    this.getData('monthDD').component.setData('ltPropSelected',monthHeaders[0]);\n                    this.getData('yearDD').component.setData('ltPropSelected',monthHeaders[1]);\n                }\n            }.observes('monthHeader','callFrmDidcnct'),\n\n            startWeekDayObserver: function() {\n                this.changeDaysOfWeek();\n            }.observes( 'ltPropStartWeekDay' ),\n\n            monthHeaderObserver: function() {\n                this.buildDateViewHeader();\n            }.observes( 'monthNames.[]' ),\n\n            numberOfRowsChange: function() {\n                // https://stackoverflow.com/questions/19727905/in-javascript-is-it-expensive-to-use-try-catch-blocks-even-if-an-exception-is-n\n                // No penalty in chrome >= 60\n                var numberOfRows = this.getData( 'ltPropNumberOfRows' );\n\n                try {\n                    if( numberOfRows < 5 ) {\n                        throw \"Calendar failed to render. The number of rows should be greater than 4.\";\n                    }\n                }\n                catch( e ) {\n                    console.error( e );\n                    return ;\n                }\n\n                this.setDatesFunction();\n            }.observes( 'ltPropNumberOfRows' ),\n\n            setDates: function( arg ) {\n                if( this.__ignoremin && arg.item == \"ltPropMinDate\" ){\n                    return;\n                }\n                this.setDatesFunction();\n            }.observes( \n                'ltPropStartDate', \n                'ltPropEndDate', \n                'changeData', \n                'ltPropMinDate', \n                'ltPropMaxDate',\n                'ltPropFormat',\n                'ltPropStartWeekDay'\n            ),\n\n            executeViewDateChanges : function() {\n                if( this.getMethods( 'onViewdateChange' ) ) {\n                    this.executeMethod( 'onViewdateChange', this, this.getData( 'viewDate' ) );\n                }\n            }.observes( 'viewDate' ),\n\n            initFn: function() {\n                var self = this;\n                \n                this.addContainerClass();\n                this.checkForMoment();\t\t\n                this.buildViewDate();\n                this.changeDaysOfWeek();\n                this.initializeCalendar();\n                this.setCalendarIdsForAria();\n\n                // set revert\n                this.$node.revertToToday = function() {\n                    self.revert();\n                };\n\n                this.$node.focusCalendar = function() {\n                    self.setData( 'ltPropActivateNavigation', true );\n                }\n\n                this.$node.revertToSelected = function() {\n                    self.revertToSelected();\n                }\n\n                // This is being internally used by CRM for their calendar\n                this.$node.getDateArray = function( viewDate ) {\n                    self.setData( 'viewDate', viewDate );\n                    self.buildDateViewContent();\n\n                    return self.getData( 'matrix' );\n                }\n\n            }.observes( 'currentDatechanged' ).on( 'init' ),\n\n            selectionTypeObserver: function() {\n                if( !this.isDrilldown() ) {\n                    this.data.ltPropCurrentDate = '';\n                    this.data.ltPropCurrentWeek = [];\n                    this.data.ltPropCurrentMonth = '';\n                    this.data.ltPropCurrentYear = '';\n                }\n\n                this.decideView();\n            }.observes( 'ltPropSelectionType' ),\n\n            changeIso : function(){\n                \n                this.isIso = true;\n                var newDate = $L.moment(this.getData('ltPropIso')).getDObj();\n                this.setData( 'viewDate', newDate );\n                if( this.isDropdownHeader() ) {\n                    this.buildYears();\t\n                }\n                this.data.ltPropCurrentDate = $L.moment(this.getData('ltPropIso')).format(this.getData('ltPropFormat'),this.isYYFormat());\n                this.buildDateView();\n            }.observes('ltPropIso'),\n\n            changeViewDate: function( val ) {\n                this.isIso = false;\n                var cur = this.getData( 'ltPropCurrentDate' );\n\n                if( this.getData( 'preventObs' ) ) {\n                    return ;\n                }\n\n                // Current Date is set to empty\n                if( !cur ) {\n                    this.removeSelectedCell();\n                    return ;\n                }\n\n                // Bad current date\n                if( this.stringToDate( cur, this.getData( 'ltPropFormat' ) ) === 'Invalid Date' ) {\n                    this.removeSelectedCell();\n                    return ;\n                }\n\n                var val = this.getData( 'ltPropCurrentDate' );\n                var newDate = this.stringToDate( val, this.getData( 'ltPropFormat' ) );\n                newDate.setDate( 1 );\n\n                // if( type === 'dropdown' && !this.isWithinAllowedYears( newDate ) ) {\n                // \treturn ;\n                // }\n\n                this.setData( 'viewDate', newDate );\n                if(this.isMomentSupported){\n                    this.data.ltPropIso = this.moment(newDate).format();\n                }\n                this.isFromCurrentDateObserver = true;\n                this.buildDateView();\n            }.observes( 'ltPropCurrentDate' ),\n\n            selectedDatesChanged: function() {\n                if( this.getData( 'preventObs' ) ) {\n                    return ;\n                }\n\n                // Handling invalid dates is a bit expensive\n\n                this.isFromCurrentDateObserver = true;\n                this.buildDateView();\n\n            }.observes( 'ltPropCurrentDates.[]' ),\n\n            disabledDatesChanged: function() {\n                this.isFromCurrentDateObserver = true;\n                this.buildDateView();\n            }.observes( 'ltPropDisabledDates.[]' ),\n\n            monthHeaderFormatObserver: function() {\n                this.buildDateViewHeader();\n            }.observes( 'ltPropMonthHeaderFormat' ),\n\n            weekNumberObserver: function() {\n                var parCalendar = this.$node;\n\n                if( this.getData('ltPropWeekNumber') && this.getData('viewType') === 'dateView' ){\n\t\t\t\t\tif( !parCalendar.classList.contains('lyteWeekNumContainer')){\n                    \tparCalendar.classList.add( 'lyteWeekNumContainer' );\n\t\t\t\t\t}\n                }\n                else {\n                    parCalendar.classList.remove( 'lyteWeekNumContainer' );\n                }\n\n            }.observes( 'ltPropWeekNumber', 'viewType' ).on( 'didConnect' )\n        };\n    }\n}\n\n/**\n * @syntax nonYielded\n * <lyte-calendar></lyte-calendar>\n */\n\n/**\n * @syntax yielded\n * <lyte-calendar>\n *     <template is=\"registerYield\" yield-name=\"footer\">\n *         <span>Footer Of The Calendar</span>\n *     </template>\n * </lyte-calendar>\n */\n\nexport { LyteCalendarComponent };\n","import { prop } from \"@slyte/core\";\nimport { Component, LyteUiComponentComponentRegistry } from \"../component.js\";\nimport $L from \"@zoho/lyte-dom\"\n/**\n * Renders a Carousel\n * @component lyte-carousel\n * @version  3.0.0\n * @methods onBeforePrev,onBeforeNext,onAfterNext,onAfterPrev\n * @utility moveSlideByIndex,reset,getActiveSlideIndex\n */\nclass LyteCarouselComponent extends Component {\n    constructor() {\n        super();\n    }\n\n    data() {\n\t\treturn {\n\t\t\t/** \n\t\t\t * @componentProperty {boolean} ltPropAutoPlay\n\t\t\t * @version 3.0.0\n\t\t\t * @default false\n\t\t\t */\n\t\t\tltPropAutoPlay : prop( 'boolean', {\n\t\t\t 'default' :  window._lyteUiUtils.resolveDefaultValue( 'lyte-carousel', 'autoPlay', false )\n\t\t\t  }),\n\t\t\t/** \n\t\t\t * @componentProperty {slide | fade} ltPropEffect\n\t\t\t * @version 3.0.0\n\t\t\t * @default slide\n\t\t\t */\n\t\t\tltPropEffect : prop( 'string', { \n\t\t\t 'default' :  window._lyteUiUtils.resolveDefaultValue( 'lyte-carousel', 'effect', 'slide' ) \n\t\t\t}),\n\t\t\t/** \n\t\t\t * @componentProperty {number} ltPropActiveIndex\n\t\t\t * @version 3.0.0\n\t\t\t * @default 0\n\t\t\t */\n\n\t\t\tltPropActiveIndex : prop( 'number', {\n\t\t\t 'default' : 0\n\t\t\t}),\n\t\t\t/** \n\t\t\t * @componentProperty {boolean} ltPropMoreRecords\n\t\t\t * @version 3.0.0\n\t\t\t * @default false\n\t\t\t */\n\t\t\tltPropMoreRecords : prop( 'boolean', {\n\t\t\t 'default' : false\n\t\t\t}),\n\t\t\t/** \n\t\t\t * @componentProperty {number} ltPropRecords\n\t\t\t * @version 3.0.0\n\t\t\t */\n\t\t\tltPropRecords : prop( 'number', {\n\t\t\t 'default' : undefined\n\t\t\t}),\n\t\t\t/** \n\t\t\t * @componentProperty {number} ltPropAutoPlayDuration\n\t\t\t * @version 3.0.0\n\t\t\t * @default 3000\n\t\t\t */\n\t\t\tltPropAutoPlayDuration : prop('number',{\n\t\t\t'default' :  window._lyteUiUtils.resolveDefaultValue( 'lyte-carousel', 'autoPlayDuration', 3000 )\n\t\t\t}),\n\t\t\t/** \n\t\t\t * @componentProperty {boolean} ltPropAutoPlayPause\n\t\t\t * @version 3.0.0\n\t\t\t * @default false\n\t\t\t */\n\t\t\tltPropAutoPlayPause : prop( 'boolean', {\n\t\t\t 'default' :  window._lyteUiUtils.resolveDefaultValue( 'lyte-carousel', 'autoPlayPause', false )\n\t\t\t}),\n\t\t\t/** \n\t\t\t * @componentProperty {array} ltPropData\n\t\t\t * @version 3.0.0\n\t\t\t * @default []\n             *\n\t\t\t */\n\t\t\tltPropData : prop( 'array', {\n\t\t\t 'default' : []\n\t\t\t}),\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropAria\n\t\t\t * @version 3.1.0\n\t\t\t * @default true\n\t\t\t */\n\t\t\tltPropAria : prop( 'boolean', {\n\t\t\t\t'default':true\n\t\t\t}),\n\t\t\t/**\n\t\t\t * @componentProperty {object} ltPropAriaAttributes\n\t\t\t * @version 3.1.0\n\t\t\t * @default {}\n\t\t\t */\n\t\t\tltPropAriaAttributes : prop( 'object', { \n\t\t\t\t'default': {}\n\t\t\t}),\n\t\t\t/**\n\t\t\t * @componentProperty {horizontal | vertical} ltPropOrientation\n\t\t\t * @version 3.82.0\n\t\t\t * @default \"horizontal\"\n\t\t\t */\n\t\t\tltPropOrientation : prop( 'string', { \n\t\t\t\t'default': \"horizontal\"\n\t\t\t}),\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropTabIndex\n\t\t\t * @version 3.82.0\n\t\t\t * @default 0\n\t\t\t */\n\t\t\tltPropTabIndex : prop( 'string', {\n\t\t\t\t'default' : '3'\n\t\t\t}),\n\t\t\tltPropDataTabIndex : prop( 'number', {\n\t\t\t\t'default' : 1\n\t\t\t}),\n\t\t\tltPropArrowKey : prop( 'boolean',{\n\t\t\t\tdefault : false\n\t\t\t}),\n\t\t\tcoordinates : prop( 'object',{\n\t\t\t\t'default': {}\n\t\t\t}),\n\t\t\tcurrentActiveIndex : prop( 'number', {\n\t\t\t 'default' : 0\n\t\t\t}),\n\t\t\tprev : prop( 'boolean',{\n\t\t\t\t'default' : false\n\t\t\t}),\n\t\t\t'start': prop( 'number' )\n\n\t\t};\t\t\n\t}\n\n    didConnect() {\n\t\tvar carouselContent = this.$node.querySelector('lyte-carousel-content');\n\t\tvar activeIndex = this.getData( 'ltPropActiveIndex' );\n\n\t\tif(this.getData('ltPropAria') && carouselContent){\n\t\t\tcarouselContent.setAttribute('aria-live', this.getData('ltPropAutoPlay') ? 'off' : 'polite') \n\t\t}\n\t\tif( activeIndex ) {\n\t\t\tthis.setData( 'currentActiveIndex', activeIndex )\n\t\t}\n\t\tif( this.getData( 'ltPropRecords' ) >= 1 ) {\n\t\t\tthis.setActiveItem()\n\t\t}\n\t\t// if( this.getData( 'ltPropRecords' ) > 1 ) {\n\t\t\tthis.setMethod();\n\t\t// }\n\t\tthis.$node.moveSlideByIndex = function(index){\n\t\t\tvar activeIndex = this.getData( 'currentActiveIndex' ),\n\t\t\titemList = this.$node.getElementsByTagName( 'lyte-carousel-item' ),\n\t\t \tindicatorList= this.$node.querySelector( ' lyte-carousel-indicator-item[data-value=\"'+ activeIndex +'\"] ' );\n\t\t\tif( activeIndex >= 0 && activeIndex < itemList.length ){\n\t\t\t\titemList[activeIndex].classList.remove('lyteActive')\n\t\t\t\titemList[activeIndex].setAttribute('tabindex', -1)\n\t\t\t\titemList[activeIndex].setAttribute('data-tabindex', -1)\n\t\t\t\titemList[activeIndex].setAttribute('aria-hidden', false)\n\t\t\t\tif(indicatorList) {\n\t\t\t\t\tindicatorList.classList.remove('lyteActive')\n\t\t\t\t\tindicatorList.setAttribute('tabindex',-1)\n\t\t\t\t\tindicatorList.setAttribute('data-tabindex',-1)\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tclearTimeout( this._nextTimeout )\n\t\t\tclearTimeout( this._nextFadeTimeout )\n\t\t\tthis.setData( 'currentActiveIndex', index )\n\t\t\tthis.setActiveItem()\n\t\t}.bind( this ) \n\t\tthis.$node.reset = function(){\n\t\t\tsetTimeout( function() {\n\t\t\t\tvar activeIndex = this.getData( 'currentActiveIndex' ),\n\t\t\t\titemList = this.$node.getElementsByTagName( 'lyte-carousel-item' ),\n\t\t\t \tindicatorList= this.$node.querySelector( ' lyte-carousel-indicator-item[data-value=\"'+ activeIndex +'\"] ' );\n\t\t\t\tif( activeIndex >= 0 && activeIndex < itemList.length ){\n\t\t\t\t\titemList[activeIndex].classList.remove('lyteActive')\n\t\t\t\t\titemList[activeIndex].setAttribute('tabindex',-1)\n\t\t\t\t\titemList[activeIndex].setAttribute('data-tabindex',-1)\n\t\t\t\t\titemList[activeIndex].setAttribute('aria-hidden', false)\n\n\t\t\t\t\tif(indicatorList) {\n\t\t\t\t\t\tindicatorList.classList.remove('lyteActive')\n\t\t\t\t\t\tindicatorList.setAttribute('tabindex',-1)\n\t\t\t\t\t\tindicatorList.setAttribute('data-tabindex',-1)\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tclearTimeout( this._nextTimeout )\n\t\t\t\tclearTimeout( this._nextFadeTimeout )\n\t\t\t\tthis.setData( 'currentActiveIndex',this.getData( 'ltPropActiveIndex' ) )\n\t\t\t\tthis.setActiveItem()\n\n\t\t\t\tthis.setMethod();\n\t\t\t}.bind( this ) )\n\t\t}.bind( this ) \n\t\tthis.$node.getActiveSlideIndex =function(){\n\t\t\treturn this.getData('currentActiveIndex')\n\t\t}.bind(this)\n\t\tthis.$node.focus =function(){\n\t\t\tdocument.addEventListener('keyup', this._keyupEvents)\n\t\t}.bind(this)\n\t\tif( this.getData('ltPropEffect') === \"swipe\" ){\n\t\t\tthis._carouselTochStart = this.carouselTouchStart.bind(this,carouselContent)\n\t\t\tcarouselContent.addEventListener( 'touchstart', this._carouselTochStart)\n\t\t}\n\t\tif(this.getData('ltPropArrowKey')){\n\t\t\tthis._carouselClick = this.carouselClick.bind(this)\n\t\t\tdocument.addEventListener('click', this._carouselClick)\n\t\t}\n\t\tthis._keyupEvents = this.keyupEvents.bind(this)\n\n\t}\n\n    carouselClick(event) {\n\t\tconst target = event.target\n\t\tif(target === this.$node || this.$node.contains(target)){\n\t\t\tdocument.addEventListener('keyup', this._keyupEvents)\n\t\t} else{\n\t\t\tdocument.removeEventListener('keyup', this._keyupEvents)\n\t\t}\n\t}\n\n    keyupEvents(event) {\n\t\tconst key = (event.keyCode || event.which)\n\t\tconst effect  = this.getData('ltPropEffect').toLowerCase()\n\t\tif(key == 37){\n\t\t\tif(effect !== 'fade'){\n\t\t\t\tthis.prevClick(event)\n\t\t\t} else{\n\t\t\t\tthis.prevFadeClick(event)\n\t\t\t}\n\t\t} else if(key == 39){\n\t\t\tif(effect !== 'fade'){\n\t\t\t\tthis.nextClick(event)\n\t\t\t} else{\n\t\t\t\tthis.nextFadeClick(event)\n\t\t\t}\n\t\t}\n\t}\n\n    didDestroy() {\n\t\tif(this.getData('ltPropArrowKey')){\n\t\t\tdocument.removeEventListener('click', this._carouselClick)\n\t\t}\n\t\tclearInterval( this._autoId )\n\t\tdelete this._autoId\n\t}\n\n    carouselTouchStart(carouselContent, event) {\n\t\tthis.setData( 'prev', false );\n\n\t\tif( event.touches.length > 1 ) {\n\t\t\t\tthis.setData( 'prev', true );\n\n\t\t\t\treturn ;\n\t\t}\n\n\t\tvar touch = event.targetTouches[ 0 ],\n\t\tcords = {\n\t\t\t\tx: touch.clientX,\n\t\t\t\ty: touch.clientY\n\t\t}\n\t\tthis.setData('coordinates',cords)\n\t\twindow.start = new Date().getTime();\n\t\tthis.setData('start', start)\n\t\tthis._carouselTouchEnd = this.carouselTouchEnd.bind(this,carouselContent)\n\t\t// carouselContent.addEventListener('touchmove',this._carouselTouchMove )\n\t\tcarouselContent.addEventListener('touchend',this._carouselTouchEnd)\n\t}\n\n    carouselTouchMove(carouselContent, event) {\n\t\tevent.preventDefault()\n\t}\n\n    carouselTouchEnd(carouselContent, event) {\n\t\tvar prev = this.getData( 'prev' );\n\n\t\t\t// prev will be false only when you do a single finger swipe\n\t\t\t// Multi finger swipes return out of execution\n\t\t\tif( prev ) {\n\t\t\t\treturn ;\n\t\t\t}\n\n\t\t\tvar start = this.getData( 'coordinates' ),\n\t\t\tx = start.x, y = start.y,\n\t\t\ttouch = event.changedTouches[ 0 ],\n\t\t\tdiffX = x - touch.clientX\n\t\t\twindow.diffY = y - touch.clientY\n\t\t\twindow.parent = this.$node.querySelector( 'lyte-carousel-content' ),\n\t\t\twindow.rect = parent.getBoundingClientRect(),\n\t\t\twindow.width = rect.width,\n\t\t\twindow.height = rect.height,\n\t\t\twindow.xTolerance = width * 0.2,\n\t\t\twindow.yTolerance = height * 0.15,\n\t\t\twindow.begin = this.getData('start'),\n\t\t\twindow.delay = (new Date().getTime()) - begin;\n\t\t\tvar orientation = this.getData(\"ltPropOrientation\");\n\t\t\t\tif (!orientation || orientation === \"horizontal\" || orientation !== \"vertical\") {\n\t\t\t\t\tif (delay < 1000 && Math.abs(diffX) > 150) {\n\t\t\t\t\t\tif (diffX < 0) {\n\t\t\t\t\t\t\tthis.prevClick();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (diffX > 0) {\n\t\t\t\t\t\t\tthis.nextClick();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (orientation && orientation === \"vertical\") { \n\t\t\t\t\tif (delay < 1000 && Math.abs(diffY) > 120) {\n\t\t\t\t\t\tif (diffY < 0) {\n\t\t\t\t\t\t\tthis.prevClick();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (diffY > 0) {\n\t\t\t\t\t\t\tthis.nextClick();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t}\n\n    getCarouselWidget() {\n\t\treturn this.$node.querySelector( '.lyteCarouselWrapper' );\n\t}\n\tcheckRecordCountEqualsOne(){\n\t\tif( this.getData('ltPropRecords') <= 1 ){\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n    setMethod() {\n\t\tif(this.getData('ltPropRecords') > 1 || (this.getData('ltPropData') && this.getData('ltPropData').length >1) || this.getData('ltPropMoreRecords')){\n\t\t\n\t\tvar prev =this.$node.getElementsByTagName( 'lyte-carousel-prev' )[ 0 ],\n\t\t\tnext = this.$node.getElementsByTagName( 'lyte-carousel-next' )[ 0 ],\n\t\t\tindicator = this.$node.getElementsByTagName( 'lyte-carousel-indicator' )[ 0 ];\n\t\t\tif( this.getData( 'ltPropEffect' ).toLowerCase() ==  \"fade\" ) {\n\t\t\t\tthis.$node.classList.add( 'lyteFade' )\n\t\t\t\tif( prev && this.getData('ltPropRecords') > 1 ) {\n\t\t\t\t\tthis._prevFadeClick = this.prevFadeClick.bind( this )\n\t\t\t\t\tprev.addEventListener( 'click', this._prevFadeClick )\n\t\t\t\t}\n\t\t\t\tif( next && !this._nextFadeClick ) {\n\t\t\t\t\tthis._nextFadeClick = this.nextFadeClick.bind( this )\n\t\t\t\t\tnext.addEventListener( 'click', this._nextFadeClick )\n\t\t\t\t}\n\t\t\t\tif( indicator && this.getData('ltPropRecords') > 1 ) {\n\t\t\t\t\tthis._indicatorFadeClick = this.indicatorFadeClick.bind( this )\n\t\t\t\t\tindicator.addEventListener( 'click', this._indicatorFadeClick )\n\t\t\t\t}\n\t\t\t\tthis._zeroOpacityTransition = this.zeroOpacityTransition.bind( this )\n\t\t\t}\n\t\t\telse{\n\t\t\t\tthis.$node.classList.add( 'lyteScroll' )\n\t\t\t\tif( prev && this.getData('ltPropRecords') > 1 ) {\n\t\t\t\t\tthis._prevClick = this.prevClick.bind( this )\n\t\t\t\t\tprev.addEventListener( 'click', this._prevClick )\n\t\t\t\t}\n\t\t\t\tif( next && !this._nextClick) {\n\t\t\t\t\tthis._nextClick = this.nextClick.bind( this )\n\t\t\t\t\tnext.addEventListener( 'click', this._nextClick )\n\t\t\t\t}\n\t\t\t\tif( indicator && this.getData('ltPropRecords') > 1 ) {\n\t\t\t\t\tthis._indicatorClick = this.indicatorClick.bind( this );\n\t\t\t\t\tindicator.addEventListener( 'click', this._indicatorClick )\n\t\t\t\t}\n\t\t\t\tthis._removePrevClass = this.removePrevClass.bind( this )\n\t\t\t\tthis._removeNextClass = this.removeNextClass.bind( this )\n\t\t\t}\n\t\t}\n\t}\n\tclearTimeoutAndInterval(){\n\t\tclearInterval( this._autoId )\n\t\tdelete this._autoId\n\t\tclearTimeout( this._timeOut1)\n\t\tdelete this._timeOut1\n\t}\n\n    carouselContentFocus() {\n\t\tvar carouselWrapper = this.$node.querySelector( '.lyteCarouselWrapper' );\n\t\tvar carouselContent = this.$node.querySelector('lyte-carousel-content')\n\t\tcarouselContent.setAttribute('aria-live','polite')\n\t\tthis.clearTimeoutAndInterval()\n\n\t\tthis._carouselContentFocusOut = this.carouselContentFocusOut.bind( this, carouselWrapper, carouselContent )\n\t\tcarouselWrapper.addEventListener( 'mouseleave',  this._carouselContentFocusOut)\n\t}\n\n    carouselContentFocusOut(carouselWrapper, carouselContent) {\n\t\tcarouselContent.setAttribute('aria-live','off')\n\n\t\tcarouselWrapper.removeEventListener( 'mouseleave', this._carouselContentFocusOut )\n\t\tif(this.getData('ltPropAutoPlay'))\t{\n\t\t\tthis.autoPlayFunc();\n\t\t}\n\t\t\t\n\t}\n\n    setActiveItem() {\n\t\tvar activeIndex = this.getData( 'currentActiveIndex' ),\n\t\t\titemList = this.$node.getElementsByTagName( 'lyte-carousel-item' ),\n\t\t \tindicatorList= this.$node.querySelector( ' lyte-carousel-indicator-item[data-value=\"'+ activeIndex +'\"] ' );\n\t\t\tif( activeIndex >= 0 && activeIndex < itemList.length ){\n\t\t\t\titemList[activeIndex].setAttribute('tabindex', this.getData('ltPropTabIndex'))\n\t\t\t\titemList[activeIndex].setAttribute('data-tabindex', this.getData('ltPropDataTabIndex'))\n\n\t\t\t\titemList[ activeIndex ].classList.add( 'lyteActive' );\n\t\t\t\titemList[activeIndex].setAttribute('aria-hidden', true)\n\n\t\t\t\tif( indicatorList ) {\n\t\t\t\t\tindicatorList.setAttribute('data-tabindex', this.getData('ltPropDataTabIndex'))\n\t\t\t\t\tindicatorList.setAttribute('tabindex', this.getData('ltPropTabIndex'))\n\n\t\t\t\t\tindicatorList.classList.add( 'lyteActive' ) ;\n\t\t\t\t}\n\t\n\t\t\t}\n\t}\n\n    prevClick(event, index) {\n\t\tif( this._prevTrans ) {\n\t\t\t// event.preventDefault();\n\t\t\t// event.stopPropagation();\n\t\t\tconsole.log('return')\n\n\t\t\treturn;\n\t\t}\n\t\telse{\n\t\t\tif( this._autoId ) {\n\t\t\t\tclearInterval( this._autoId )\n\t\t\t\tthis._autoId = false;\n\t\t\t}\n\t\t\tthis._prevTrans=true\n\n\t\t\tvar records = this.getData( 'ltPropRecords' ),\n\t\t \tcurrentActive = this.getData( 'currentActiveIndex' ),\n\t\t \titemList = this.$node.getElementsByTagName( 'lyte-carousel-item' ) ,\n\t\t\t indicatorList= this.$node.querySelector( ' lyte-carousel-indicator-item[data-value=\"' +currentActive+ '\"] ' );\n\t\t\t window.res=true;\n\t\t\tif( this.getMethods( 'onBeforePrev' ) ){\n\t\t\t\tres = this.executeMethod( 'onBeforePrev' , event , this , currentActive ,records);\n\t\t\t\tdelete this._prevTrans\n\n\t\t\t}\n\t\t\tif(res !== false){\n\t\t\t\tif( currentActive >= 1 ){\n\t\t\t\t\tthis.previous( currentActive, index || currentActive-1, itemList, indicatorList, event )\n\t\t\t\t}\n\t\t\t\telse if(currentActive==0){\n\t\t\t\t\tthis.previous( currentActive, index || records-1, itemList, indicatorList, event )\n\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( this.getData( 'ltPropAutoPlay' )  ) {\n\t\t\t\tsetTimeout( function() {\n\t\t\t\t\tthis.autoPlayFunc();\n\t\t\t\t}.bind( this ), 100 )\n\t\t\t}\n\t\t}\n\t}\n\n    nextClick(event, index) {\n\t\tvar records = this.getData( 'ltPropRecords' ),\n\t\t \tcurrentActive = this.getData( 'currentActiveIndex' ),\n\t\t \tres=true,that = this,index;\n\t\tif( this._nextTrans) {\n\t\t\t// event.preventDefault();\n\t\t\t// event.stopPropagation();\n\t\t\t\treturn;\t\t\t\n\t\t}\n\t\telse{\n\t\t\t\n\t\t\tthis.clearTimeoutAndInterval()\n\t\t\tif( this.getMethods( 'onBeforeNext' ) ){\n\t\t\t\t\t\tres = this.executeMethod( 'onBeforeNext' , event , this , currentActive ,records);\n\t\t\t\t\t\trecords = this.getData( 'ltPropRecords' )\n\t\t\t}\n\t\t\tif(this.getData( 'ltPropRecords' ) <= 1){\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlet itemList = this.$node.getElementsByTagName( 'lyte-carousel-item' ) ,\n\t\t \tindicatorList= this.$node.querySelector( ' lyte-carousel-indicator-item[data-value=\"'+ currentActive +'\"] ' )\n\t\t\tif(res && res.then  ) {\n\t\t\t\tres.then( function( arg ) {\n\t\t\t\t\tif( currentActive >= 0 &&  currentActive < that.getData( 'ltPropRecords' ) ) {\n\t\t\t\t\t\tif( currentActive < that.getData( 'ltPropRecords' ) - 1 ) {\n\t\t\t\t\t\t\tthat.next( currentActive, index || currentActive+1, itemList, indicatorList, event )\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( currentActive == that.getData( 'ltPropRecords' ) - 1 ) {\n\t\t\t\t\t\t\tthat.next( currentActive, index || 0, itemList, indicatorList, event )\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( that.getData('ltPropAutoPlay')  ) {\n\t\t\t\t\t\t\tthat.autoPlayFunc();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}).catch( function( err ) {\n\t\t\t\t\tconsole.error( err );\n\t\t\t\t} );\n\t\t\t}\n\t\t\telse if( res !== false ) {\n\t\t\t\tif( currentActive >= 0 && currentActive < records-1 ) {\n\t\t\t\t\tthis.next( currentActive, index || currentActive+1, itemList, indicatorList, event )\n\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if( currentActive == records-1 ) {\n\t\t\t\t\tthis.next( currentActive, index || 0, itemList, indicatorList, event )\n\t\t\t\t}\n\t\t\t\tif( this.getData( 'ltPropAutoPlay' )  ) {\n\t\t\t\t\tsetTimeout( function() {\n\t\t\t\t\t\tthis.autoPlayFunc();\n\t\t\t\t\t}.bind( this ), 100 )\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\n\t}\n\n    next(currentActive, nextIndex, itemList, indicatorList, event) {\n\t\tdebugger\n\t\tvar res = true, records = this.getData('ltPropRecords')\n\n\t\tthis._nextTrans = true\n\t\t\tvar duration = parseFloat( window.getComputedStyle( itemList[ currentActive ] ).transitionDuration )\n\t\t\t\tduration = ( duration * 1000 ) +200\n\t\t\tsetTimeout( function() {\n\t\t\t\t\t\n\t\t\t\t\tif( this._nextTrans ) {\n\t\t\t\t\t\tvar itemList = this.$node.getElementsByTagName( 'lyte-carousel-item' ),\n\t\t\t\t\t\tindicatorList = this.$node.getElementsByTagName( 'lyte-carousel-indicator-item' ),\n\t\t\t\t\t\tactiveItemList = this.$node.querySelectorAll( 'lyte-carousel-item.lyteActive' )\n\t\t\t\t\t\tfor( var i=0 ; i<itemList.length; ++i ) {\n\t\t\t\t\t\t\tif( $L(itemList[ i ] ).hasClass( 'lyteActivePrev' ) ) {\n\t\t\t\t\t\t\t\titemList[ i ].classList.remove( 'lyteActivePrev' )\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( activeItemList.length > 1 ) {\n\t\t\t\t\t\t\tfor( var i=0 ; i < itemList.length; ++i ) {\n\t\t\t\t\t\t\t\tif( i != this.getData( 'ltPropActiveIndex' ) && $L( itemList[ i ] ).hasClass( 'lyteActive' ) ) {\n\t\t\t\t\t\t\t\t\titemList[ i ].setAttribute('tabindex',-1)\n\n\t\t\t\t\t\t\t\t\titemList[ i ].classList.remove( 'lyteActive' )\n\t\t\t\t\t\t\t\t\titemList[i].setAttribute('aria-hidden', false)\n\n\t\t\t\t\t\t\t\t\tindicatorList[i].setAttribute('tabindex',-1)\n\n\t\t\t\t\t\t\t\t\tindicatorList[ i ].classList.remove( 'lyteActive' )\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdelete this._nextTrans\n\t\t\t\t\t}\n\t\t\t}.bind( this ), duration )\n\t\n\t\t\titemList[ nextIndex].classList.add( 'lyteActiveNext' ) \n\t\t\tthis._nextTimeout = setTimeout( function() {\n\t\t\t\tif( this._nextTrans ) {\n\t\t\t\t\titemList[ currentActive ].addEventListener( 'transitionend', this._removePrevClass )\n\t\t\t\t\titemList[ currentActive ].classList.add( 'lyteActivePrev' ) \n\t\t\t\t\titemList[ currentActive ].setAttribute('tabindex',-1)\n\n\t\t\t\t\titemList[ currentActive ].classList.remove( 'lyteActive' ) \n\t\t\t\t\titemList[currentActive].setAttribute('aria-hidden', false)\n\n\t\t\t\t\tif( indicatorList ) {\n\t\t\t\t\t\tindicatorList.setAttribute('tabindex',-1)\n\n\t\t\t\t\t\tindicatorList.classList.remove( 'lyteActive' )\n \n\t\t\t\t\t}\n\t\t\t\t\titemList[ nextIndex].classList.remove( 'lyteActiveNext' ) \n\t\t\t\t\t// this.setData( 'ltPropActiveIndex',\tnextIndex ) ;\n\t\t\t\t\tthis.setData( 'currentActiveIndex', nextIndex ) ;\n\t\t\t\t\tif( this.getMethods( 'onAfterNext' ) ){\n\t\t\t\t\t\tthis.executeMethod( 'onAfterNext' , event , this , nextIndex ) ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}.bind( this ), 100 )\n\t\t\n\t\t\n\t}\n\n    previous(currentActive, prevIndex, itemList, indicatorList, event) {\n\t\tvar res = true, records = this.getData('ltPropRecords')\n\t\t\n\n\t\t\tthis._prevTrans=true\n\n\t\t\titemList[ prevIndex ].classList.add( 'lyteActivePrev' ) \n\t\t\tsetTimeout( function() {\n\t\t\t\titemList[ currentActive ].addEventListener( 'transitionend', this._removeNextClass )\n\t\t\t\titemList[ currentActive ].classList.add( 'lyteActiveNext' ) \n\t\t\t\titemList[ currentActive ].setAttribute('tabindex',-1)\n\n\t\t\t\titemList[ currentActive ].classList.remove( 'lyteActive' ) \n\t\t\t\titemList[ currentActive ].setAttribute('aria-hidden', false)\n\t\t\t\tthis.setData( 'currentActiveIndex', prevIndex )\n\t\t\t\tconsole.log(itemList[ prevIndex ].classList)\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\titemList[ prevIndex ].classList.remove('lyteActivePrev') \n\t\t\t\t},10)\n\t\t\t\tif( indicatorList ) {\n\t\t\t\t\tindicatorList.setAttribute('tabindex',-1)\n\n\t\t\t\t\tindicatorList.classList.remove( 'lyteActive' ) \n\n\t\t\t\t}\n\t\t\t\t// this.setData( 'ltPropActiveIndex', prevIndex )\n\t\t\t\tif( this.getMethods( 'onAfterPrev' ) ){\n\t\t\t\t\tthis.executeMethod( 'onAfterPrev' , event , this , prevIndex ) \n\t\t\t\t}\n\t\t\t}.bind( this ) )\n\t\t\n\t}\n\n    removePrevClass(event) {\n\t\t\n\t\t\t// if(currentActive-1>=0){\n\t\t\t\tevent.currentTarget.classList.remove( 'lyteActivePrev' ) \n\t\t\t\tevent.currentTarget.removeEventListener( 'transitionend', this._removePrevClass )\n\n\t\t\t// }\n\n\t\t\tdelete this._nextTrans \n\t}\n\n    removeNextClass(event) {\n\t\t\n\n\t\tevent.currentTarget.classList.remove('lyteActiveNext') ;\n\t\tevent.currentTarget.removeEventListener('transitionend',this.removeNextClass);\n\t\t\n\t\tdelete this._prevTrans \n\t}\n\n    autoPlayFunc() {\n\t\tif(this._autoId){\n\t\t\tclearInterval(this._autoId)\n\t\t\tthis._autoId = false\n\t\t}\n\t\tvar duration = this.getData('ltPropAutoPlayDuration')\n\t\tif(duration ){\n\t\t\tthis._autoId=setInterval(function(){\n\t\t\t\tvar effect = this.getData('ltPropEffect') ?  this.getData('ltPropEffect') :'';\n\t\t\t\tif( effect.toLowerCase() == \"fade\" && !this._nextFadeTrans ){\n\t\t\t\t\tthis.nextFadeClick();\n\t\t\t\t}\n\t\t\t\telse if( effect.toLowerCase() !== \"fade\" &&!this._nextTrans ){\n\t\t\t\t\tthis.nextClick();\n\t\t\t\t}\n\t\t\t}.bind(this),duration);\n\t\t}\n\t}\n\n    indicatorClick(event) {\n\t\tif( this.checkRecordCountEqualsOne() ){\n\t\t\treturn\n\t\t}\n\t\tvar index, e = event.target,\n\t\ttarget= $L(e).closest('lyte-carousel-indicator-item')[ 0 ];\n\t\tif( target && target.tagName.toLowerCase() == 'lyte-carousel-indicator-item' ){\n\t\t\tindex = target.getAttribute('data-value');\n\t\t\tvar currentActive = this.getData( 'currentActiveIndex' ),\n\t\t \titemList = this.$node.getElementsByTagName( 'lyte-carousel-item' ) ,\n\t\t \tindicatorList= this.$node.querySelector( ' lyte-carousel-indicator-item[data-value=\"'+ currentActive +'\"] ' ),\n\t\t\tres=true,that = this;\n\n\t\t\tif( index < currentActive ){\n\t\t\t\tthis.prevClick( event, index );\n\t\t\t}\n\t\t\telse if(index > currentActive ){\n\t\t\t\tthis.nextClick( event, index );\n\n\t\t\t}\n\t\t}\n\t}\n\n    prevFadeClick(event, index) {\n\t\tif( this._prevFadeTrans ) {\n\t\t\t// event.preventDefault()\n\t\t\t// event.stopPropagation()\n\t\t\treturn;\n\t\t}\n\t\telse{\n\t\t\tif( this._autoId ) {\n\t\t\t\tclearInterval( this._autoId )\n\t\t\t\tthis._autoId = false;\n\t\t\t}\n\t\t\tvar records = this.getData( 'ltPropRecords' ),\n\t\t \tcurrentActive = this.getData( 'currentActiveIndex' ),\n\t\t \titemList = this.$node.getElementsByTagName( 'lyte-carousel-item' ) ,\n\t\t\tindicatorList= this.$node.querySelector( ' lyte-carousel-indicator-item[data-value=\"' +currentActive+ '\"] ' ),\n\t\t\tres=true;\n\t\t\tif( this.getMethods( 'onBeforePrev' ) ){\n\t\t\t\tres = this.executeMethod( 'onBeforePrev' , event , this , currentActive ,records );\n\t\t\t}\n\t\t\tif(res !== false){\n\t\t\t\tif( currentActive >= 1 ){\n\t\t\t\t\tthis.previousFade( currentActive, index || currentActive-1, itemList, indicatorList, event )\n\t\t\t\t}\n\t\t\t\telse if( currentActive==0 ) {\n\t\t\t\t\tthis.previousFade( currentActive, index || records-1, itemList, indicatorList, event )\n\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( this.getData( 'ltPropAutoPlay' )  ) {\n\t\t\t\tsetTimeout( function() {\n\t\t\t\t\tthis.autoPlayFunc();\n\t\t\t\t}.bind( this ), 100 )\n\t\t\t}\n\t\t}\n\t}\n\n    previousFade(currentActive, prevIndex, itemList, indicatorList, event) {\n\t\tthis._prevFadeTrans=true\n\n\t\tsetTimeout( function() {\n\t\t\titemList[ prevIndex ].addEventListener( 'transitionend', this._zeroOpacityTransition )\n\t\t\titemList[ currentActive ].classList.remove( 'lyteActive' ) ;\n\t\t\titemList[ currentActive ].setAttribute('tabindex',-1)\n\t\t\titemList[ currentActive ].setAttribute('data-tabindex',-1)\n\n\t\t\titemList[ currentActive ].setAttribute('aria-hidden', false)\n\n\t\t\titemList[ prevIndex ].classList.add('lyteActive') ;\n\t\t\titemList[ prevIndex ].setAttribute('tabindex', this.getData('ltPropTabIndex'))\n\t\t\titemList[ prevIndex ].setAttribute('data-tabindex', this.getData('ltPropDataTabIndex'))\n\n\t\t\titemList[ prevIndex ].setAttribute('aria-hidden', true)\n\n\t\t\tif( indicatorList ) {\n\t\t\t\tindicatorList.classList.remove( 'lyteActive' ) ;\n\t\t\t\tindicatorList.setAttribute('tabindex',-1)\n\t\t\t\tindicatorList.setAttribute('data-tabindex',-1)\n\n\t\t\t}\n\t\t\tthis.setData( 'currentActiveIndex', prevIndex );\n\t\t\tif( this.getMethods( 'onAfterPrev' ) ){\n\t\t\t\tthis.executeMethod( 'onAfterPrev' , event , this , prevIndex ) \n\t\t\t}\n\t\t}.bind( this ) )\n}\n\n    zeroOpacityTransition(event) {\n\t\tevent.currentTarget.removeEventListener( 'transitionend', this._zeroOpacityTransition )\n\t\t\n\t\tdelete this._prevFadeTrans ;\n\t\tdelete this._nextFadeTrans ;\n\t}\n\n    nextFadeClick(event, index) {\n\t\t\n\t\tvar records = this.getData( 'ltPropRecords' ),\n\t\t \tcurrentActive = this.getData( 'currentActiveIndex' ),\n\t\t \tres=true,that = this,index;\n\t\tif( this._nextTrans ) {\n\t\t\t\t// event.preventDefault();\n\t\t\t\t// event.stopPropagation();\n\t\t\t\treturn;\t\t\t\n\t\t}\n\t\telse{\n\n\t\t\tthis.clearTimeoutAndInterval()\n\t\t\tif( this.getMethods( 'onBeforeNext' ) ){\n\t\t\t\t\t\tres = this.executeMethod( 'onBeforeNext' , event , this , currentActive ,records );\n\t\t\t\t\t\trecords = this.getData( 'ltPropRecords' )\n\t\t\t}\n\t\t\tif(this.getData( 'ltPropRecords' ) <= 1){\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlet itemList = this.$node.getElementsByTagName( 'lyte-carousel-item' ) ,\n\t\t \tindicatorList= this.$node.querySelector( ' lyte-carousel-indicator-item[data-value=\"'+ currentActive +'\"] ' )\n\t\t\tif( res && res.then) {\n\t\t\t\tres.then(function( arg ) {\n\t\t\t\t\tif( currentActive >= 0 &&  currentActive < that.getData( 'ltPropRecords' ) ) {\n\t\t\t\t\t\tif( currentActive < that.getData( 'ltPropRecords' )-1 ) {\n\t\t\t\t\t\t\tthat.nextFade( currentActive, index || currentActive+1, itemList, indicatorList, event )\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( currentActive == that.getData( 'ltPropRecords' ) - 1 ) {\n\t\t\t\t\t\t\tthat.nextFade( currentActive,index || 0, itemList, indicatorList, event )\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( that.getData( 'ltPropAutoPlay' ) ) {\n\t\t\t\t\t\t// setTimeout(function(){\n\t\t\t\t\t\t\tthat.autoPlayFunc();\n\t\t\t\t\t\t// }.bind(that),100)\n\t\t\t\t\t}\n\t\t\t\t} ).catch( function( err ) {\n\t\t\t\t\tconsole.error( err );\n\t\t\t\t} );\n\t\t\t}\n\t\t\telse if( res !== false ) {\n\t\t\t\tif( currentActive >= 0 && currentActive < records-1 ){\n\t\t\t\t\tthis.nextFade( currentActive, index || currentActive+1, itemList, indicatorList, event )\n\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if( currentActive == records-1 ) {\n\t\t\t\t\tthis.nextFade( currentActive, index || 0, itemList, indicatorList, event )\n\t\t\t\t}\n\t\t\t\tif( this.getData( 'ltPropAutoPlay' ) ) {\n\t\t\t\t\tsetTimeout( function() {\n\t\t\t\t\t\tthis.autoPlayFunc();\n\t\t\t\t\t}.bind( this ),100 )\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n    nextFade(currentActive, nextIndex, itemList, indicatorList, event) {\n\t\tthis._nextFadeTrans = true\n\t\tvar duration = parseFloat( window.getComputedStyle( itemList[ currentActive ] ).transitionDuration )\n\t\t\tduration = ( duration * 1000 ) +20\n\t\t\t\n\t\tsetTimeout( function() {\n\t\t\t\tif( this._nextFadeTrans ) {\n\t\t\t\t\tdelete this._nextFadeTrans\n\t\t\t\t}\n\t\t}.bind( this ), duration )\n\n\t\tthis._nextFadeTimeout = setTimeout( function() {\n\t\t\titemList[ currentActive ].addEventListener( 'transitionend', this._zeroOpacityTransition)\n\t\t\titemList[ currentActive ].classList.remove( 'lyteActive' ) ;\n\t\t\titemList[ currentActive ].setAttribute('tabindex',-1)\n\t\t\titemList[ currentActive ].setAttribute('data-tabindex',-1)\n\t\t\titemList[ currentActive ].setAttribute('aria-hidden', false)\n\n\t\t\tif( indicatorList ) {\n\t\t\t\tindicatorList.classList.remove( 'lyteActive' ) ;\n\t\t\t\tindicatorList.setAttribute('tabindex',-1)\n\t\t\t\tindicatorList.setAttribute('data-tabindex',-1)\n\n\t\t\t}\n\t\t\tthis.setData( 'currentActiveIndex', nextIndex ) ;\n\t\t\tif( this.getMethods( 'onAfterNext' ) ){\n\t\t\t\tthis.executeMethod( 'onAfterNext' , event , this , nextIndex ) \n\t\t\t}\n\t\t}.bind( this ), 100 )\n\t}\n\n    indicatorFadeClick(event) {\n\t\tvar index, e = event.target,\n\t\ttarget= $L( e ).closest( 'lyte-carousel-indicator-item' )[ 0 ];\n\n\t\n\t\tif( target && target.tagName.toLowerCase() == 'lyte-carousel-indicator-item' ) {\n\t\t\tindex = target.getAttribute( 'data-value' );\n\t\t\tvar currentActive = this.getData( 'currentActiveIndex' ),\n\t\t \titemList = this.$node.getElementsByTagName( 'lyte-carousel-item' ) ,\n\t\t \tindicatorList= this.$node.querySelector( ' lyte-carousel-indicator-item[data-value=\"'+ currentActive +'\"] ' ),\n\t\t\tres=true,that = this;\n\n\t\t\tif( index < currentActive ){\n\t\t\t\tthis.prevFadeClick( event, index );\n\t\t\t}\n\t\t\telse if(index > currentActive ){\n\t\t\t\tthis.nextFadeClick( event , index);\n\n\t\t\t}\n\t\t}\n\t}\n\n    static observers() {\n        return {\n            setOrientation: function () { \n                var orientation = this.getData(\"ltPropOrientation\");\n                if (orientation && orientation === \"vertical\") {\n                    this.$node.classList.add('lyteCarouselVertical');\n                }\n                else if (orientation && orientation === \"horizontal\") {\n                    this.$node.classList.remove('lyteCarouselVertical');\n                }\n            }.observes(\"ltPropOrientation\").on(\"didConnect\"),\n\n            ariaObserver: function( change ) {\n                if(this.getData('ltPropAria')){\n                    window._lyteUiUtils.setAttribute( this.getCarouselWidget(), this.getData( 'ltPropAriaAttributes' ) || {}, {} );\n\n                }\n\n            }.observes( 'ltPropAriaAttributes' ).on( 'didConnect' ),\n\n            dataObs : function() {\n                setTimeout( function() {\n                        clearTimeout( this._nextTimeout )\n                        clearTimeout( this._nextFadeTimeout )\n                        this.setData( 'currentActiveIndex',this.getData( 'ltPropActiveIndex' ) )\n                        this.setActiveItem()\n                        this.setMethod();\n                }.bind( this ) )\n            }.observes( 'ltPropData' ),\n\n            currentActiveObs : function() {\n                // this.checkButton();\n                this.setActiveItem();\n                \n                \n            }.observes( 'currentActiveIndex' ),\n\t\t\trecordObs : function(obj) {\n                // this.checkButton();\n                if(obj.oldValue === 1 && obj.newValue > 1 ){\n\t\t\t\t\tthis.setMethod()\n\t\t\t\t}\n                \n            }.observes( 'ltPropRecords' ),\n            activeIndexObs : function() {\n                // this.checkButton();\n                var activeIndex = this.getData( 'currentActiveIndex' ),\n                    itemList = this.$node.getElementsByTagName( 'lyte-carousel-item' ),\n                    indicatorList= this.$node.querySelector( ' lyte-carousel-indicator-item[data-value=\"'+ activeIndex +'\"] ' );\n                if( activeIndex >= 0 && activeIndex < itemList.length ){\n                    itemList[activeIndex].setAttribute('tabindex',-1)\n                    itemList[activeIndex].setAttribute('data-tabindex',-1)\n\n                    itemList[activeIndex].classList.remove('lyteActive')\n                    itemList[activeIndex].setAttribute('aria-hidden', false)\n\n                    if(indicatorList) {\n                        indicatorList.setAttribute('tabindex',-1)\n                        indicatorList.setAttribute('data-tabindex',-1)\n                        indicatorList.classList.remove('lyteActive')\n\n                    }\n                    this.setData( 'currentActiveIndex', this.getData( 'ltPropActiveIndex' ) )\n                }\n                \n            }.observes( 'ltPropActiveIndex' ),\n\n            autoPlayPauseObs : function() {\n                var carouselContent = this.$node.querySelector( '.lyteCarouselWrapper' );\n                this._carouselContentFocus= this.carouselContentFocus.bind(this)\n                if( this.getData( 'ltPropAutoPlayPause' ) && this.getData( 'ltPropAutoPlayDuration' ) ) {\n                    if( carouselContent ) {\n                        carouselContent.addEventListener( 'mouseenter', this._carouselContentFocus )\n                    }\n                }\n                else{\n                    if( carouselContent ) {\n                        carouselContent.removeEventListener( 'mouseenter', this._carouselContentFocus )\n                    }\n                }\n            }.observes( 'ltPropAutoPlayPause' ).on( 'didConnect' ),\n\n            autoPlayObs : function() {\n                if( !this.getData( 'ltPropAutoPlay' ) && this._autoId ) {\n                    clearInterval( this._autoId );\n                    this._autoId = false\n                }\n                if(this.getData( 'ltPropAutoPlay' ) && (this.getData('ltPropRecords') > 1 || this.getData('ltPropMoreRecords'))) {\n                    this.autoPlayFunc();\n                }\n            }.observes( 'ltPropAutoPlay' ).on( 'didConnect' )\n        };\n    }\n}\n\nif( !window._lyteUiUtils.registeredCustomElements[ 'lyte-carousel-item' ] ) {\n    window._lyteUiUtils.registeredCustomElements[ 'lyte-carousel-item' ] = true;\n\n    class LyteCarouselItemCustomElements extends LyteUiComponentComponentRegistry.CustomElements {\n        static options = {clone : {allCallbacks : false}};\n\n        lookups() {\n            return [{\n                component: LyteUiComponentComponentRegistry\n            }];\n        }\n\n        constructor() {\n            super();\n        }\n\n        static get observedAttributes() {\n            return [ ];\n        }\n\n        connectedCallback() {\n            var lyteNode = this.$node;\n\n            lyteNode.setAttribute( 'aria-hidden', false );\n\n            if( !lyteNode.hasAttribute( 'tabindex' ) ) {\n\t\t\t\tlyteNode.setAttribute( 'tabindex', '-1' );\n\t\t\t\tlyteNode.setAttribute( 'data-tabindex', '-1' );\n\n\t\t\t}\n        }\n    }\n\n    LyteCarouselItemCustomElements.register(\"lyte-carousel-item\");\n}\nif( !window._lyteUiUtils.registeredCustomElements[ 'lyte-carousel-next' ] ) {\n    window._lyteUiUtils.registeredCustomElements[ 'lyte-carousel-next' ] = true;\n\n    class LyteCarouselNextCustomElements extends LyteUiComponentComponentRegistry.CustomElements {\n        static options = {clone : {allCallbacks : false}};\n\n        lookups() {\n            return [{\n                component: LyteUiComponentComponentRegistry\n            }];\n        }\n\n        constructor() {\n            super();\n        }\n\n        static get observedAttributes() {\n            return [ ];\n        }\n\n        connectedCallback() {\n            var lyteNode = this.$node;\n\n            lyteNode.setAttribute( 'aria-role', 'button' );\n        }\n    }\n\n    LyteCarouselNextCustomElements.register(\"lyte-carousel-next\");\n}\nif( !window._lyteUiUtils.registeredCustomElements[ 'lyte-carousel-prev' ] ) {\n    window._lyteUiUtils.registeredCustomElements[ 'lyte-carousel-prev' ] = true;\n\n    class LyteCarouselPrevCustomElements extends LyteUiComponentComponentRegistry.CustomElements {\n        static options = {clone : {allCallbacks : false}};\n\n        lookups() {\n            return [{\n                component: LyteUiComponentComponentRegistry\n            }];\n        }\n\n        constructor() {\n            super();\n        }\n\n        static get observedAttributes() {\n            return [ ];\n        }\n\n        connectedCallback() {\n            var lyteNode = this.$node;\n\n            lyteNode.setAttribute( 'aria-role', 'button' );\n        }\n    }\n\n    LyteCarouselPrevCustomElements.register(\"lyte-carousel-prev\");\n}\n/**\n * \n * @syntax yielded \n *\t<lyte-carousel>\n *\t<template is=\"registerYield\" yield-name=\"carouselBoxYield\">\n *       <lyte-carousel-prev> </lyte-carousel-prev>\n *       <lyte-carousel-content>\n *          <lyte-carousel-item> Content 1 </lyte-carousel-item>\n *          <lyte-carousel-item> Content 2 </lyte-carousel-item>\n *       </lyte-carousel-content>\n *       <lyte-carousel-indicator>\n *           <lyte-indicator-item data-value=\"0\"> 1 </lyte-indicator-item>\n *           <lyte-indicator-item data-value=\"1\"> 2 </lyte-indicator-item>\n *       </lyte-carousel-indicator>\n *      <lyte-carousel-next> </lyte-carousel-next>\n *   </template>\n *\t</lyte-carousel> \n */\nexport { LyteCarouselComponent };\n","import './../helpers/helpers-dev.js';\nimport { prop } from \"@slyte/core\";\nimport { Component } from \"../component.js\";\n\n/**\n * Renders a checkbox\n * @component lyte-checkbox\n * @version 1.0.0\n * @utility focus,blur,click\n * @methods onBeforeChecked,onChecked,onChanged,onBeforeUnchecked,onUnchecked\n */\n\nwindow._lyteCbox = {\n\t'checkedClass': 'lyteCboxChecked',\n\t'uncheckedClass': 'lyteCboxUnchecked'\n};\n\nclass LyteCheckboxComponent extends Component {\n    constructor() {\n        super();\n    }\n\n    data() {\n    \treturn {\n    \t\t/**\n\t\t\t * @componentProperty {default | primary | secondary | switch | slider} ltPropType=default\n\t\t\t */\n\n\t\t\t'ltPropType': prop('string', {\n\t\t\t\t'default': window._lyteUiUtils.resolveDefaultValue('lyte-checkbox', 'type', 'default')\n\t\t\t}),\n\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropId\n\t\t\t */\n\n\t\t\t'ltPropId': prop('string', {\n\t\t\t\t'default': undefined\n\t\t\t}),\n\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropDisabled=false\n\t\t\t */\n\n\t\t\t'ltPropDisabled': prop('boolean', {\n\t\t\t\t'default': false\n\t\t\t}),\n\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropChecked=false\n\t\t\t */\n\n\t\t\t'ltPropChecked': prop('boolean', {\n\t\t\t\t'default': false\n\t\t\t}),\n\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropLabel\n\t\t\t */\n\n\t\t\t'ltPropLabel': prop('string', {\n\t\t\t\t'default': undefined\n\t\t\t}),\n\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropName\n\t\t\t */\n\n\t\t\t'ltPropName': prop('string', {\n\t\t\t\t'default': undefined\n\t\t\t}),\n\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropValue\n\t\t\t */\n\n\t\t\t'ltPropValue': prop('string', {\n\t\t\t\t'default': undefined\n\t\t\t}),\n\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropReadOnly=false\n\t\t\t */\n\n\t\t\t'ltPropReadonly': prop('boolean', {\n\t\t\t\t'default': false\n\t\t\t}),\n\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropFireOnInit=false\n\t\t\t */\n\n\t\t\t'ltPropFireOnInit': prop('boolean', {\n\t\t\t\t'default': window._lyteUiUtils.resolveDefaultValue('lyte-checkbox', 'fireOnInit', false)\n\t\t\t}),\n\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropClass\n\t\t\t */\n\n\t\t\t'ltPropClass': prop('string', {\n\t\t\t\t'default': window._lyteUiUtils.resolveDefaultValue('lyte-checkbox', 'class', '')\n\t\t\t}),\n\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropLabelClass\n\t\t\t */\n\n\t\t\t'ltPropLabelClass': prop('string', {\n\t\t\t\t'default': window._lyteUiUtils.resolveDefaultValue('lyte-checkbox', 'labelClass', '')\n\t\t\t}),\n\n\t\t\t/**\n\t\t\t * @componentProperty {number} ltPropTabindex=0\n\t\t\t */\n\n\t\t\t'ltPropTabindex': prop('number', {\n\t\t\t\t'default': 0\n\t\t\t}),\n\t\t\t'lyteUnbound': prop('boolean', {\n\t\t\t\t'default': false\n\t\t\t}),\n\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropYield=false\n\t\t\t * @version 2.2.8\n\t\t\t */\n\n\t\t\t'ltPropYield': prop('boolean', {\n\t\t\t\t'default': false\n\t\t\t}),\n\n\t\t\t/**\n\t\t\t * @componentProperty {object} ltPropAriaCheckbox={}\n\t\t\t * @version 3.1.0\n\t\t\t */\n\n\n\t\t\t'ltPropAriaCheckbox': prop('object', {\n\t\t\t\t'default': window._lyteUiUtils.resolveDefaultValue('lyte-checkbox', 'ariaCheckbox', {})\n\t\t\t}),\n\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropFocus=false\n\t\t\t * @version 3.2.0\n\t\t\t */\n\n\t\t\t'ltPropFocus': prop('boolean', {\n\t\t\t\t'default': false\n\t\t\t}),\n\n\t\t\t'ltPropPreventCallbackObservers': prop('boolean', {\n\t\t\t\t'default': false\n\t\t\t}),\n\n\t\t\t'ltPropDataTabindex': prop('string', { 'default': \"\" }),\n\n\t\t\t'ltPropShowTooltip': prop( 'boolean', { 'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-checkbox', 'showTooltip', false ) } ),\n\n\t\t\t'ltPropTooltipConfig': prop( 'object', {\n\t\t\t\t'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-checkbox', 'tooltipConfig', {\n\t\t\t\t\t'position': 'bottom',\n\t\t\t\t\t'appearance': 'box',\n\t\t\t\t\t'margin': 5,\n\t\t\t\t\t'keeptooltip': true\n\t\t\t\t} )\n\n\t\t\t} ),\n\n\t\t\t'ltPropTooltipClass': prop( 'string', { 'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-checkbox', 'tooltipClass', '' ) } ),\n\n\t\t\t'ltPropAria': prop( 'boolean', { 'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-checkbox', 'aria', false ) } ),\n\n\t\t\t'randomId': prop('string')\n\t\t};\n\t}\n\n    didDestroy() {\n\t\tdelete this.$node.focus;\n\t\tdelete this.$node.blur;\n\t\tdelete this.$node.click;\n\t}\n\n    reduceOpacity() {\n\t\tif (this.getData('ltPropDisabled')) {\n\t\t\tthis.$node.classList.add('lyteCheckDisabled');\n\t\t}\n\t\telse {\n\t\t\tthis.$node.classList.remove('lyteCheckDisabled');\n\t\t}\n\t}\n\n    setDefaults() {\n\t\tvar type = this.getData('ltPropType'),\n\t\t\tcls = this.getData('ltPropClass'),\n\t\t\tlabel = this.getData('ltPropLabelClass');\n\n\t\tif (type === 'switch' ) {\n\t\t\tthis.setData('ltPropFinalClass', cls ? cls : this.getDefaultSwitchClass() );\n\t\t}\n\t\telse if (type === 'default') {\n\t\t\tthis.setData('ltPropFinalClass', cls ? cls : 'lyteCheckBoxDefault');\n\t\t}\n\t\telse if (type === 'primary') {\n\t\t\tthis.setData('ltPropFinalClass', cls ? cls : 'lyteCheckBoxPrimary');\n\t\t}\n\t\telse if (type === 'slider') {\n\t\t\tthis.setData('ltPropFinalClass', cls ? cls : 'lyteCheckSlider');\n\t\t}\n\n\t\tif (type === 'slider') {\n\t\t\tthis.setData('ltPropFinalLabelClass', label ? label : 'lyteCheckSliderText');\n\t\t}\n\t\telse {\n\t\t\tthis.setData('ltPropFinalLabelClass', label ? label : '');\n\t\t}\n\t}\n\n    getDefaultSwitchClass() {\n\t\treturn 'lyteCheckSwitch' + ( this.getData( 'ltPropAria' ) ? ' lyteCheckboxSwitchWithStateLabel' : '' );\n\t}\n\n    setTooltip() {\n\t\tvar showTooltip = this.getData( 'ltPropShowTooltip' ),\n\t\tlabel = this.getData( 'ltPropLabel' ),\n\t\ttooltipConfig = this.getData( 'ltPropTooltipConfig' ),\n\t\ttooltipClass = this.getData( 'ltPropTooltipClass' ),\n\t\tlabelElement = this.$node.querySelector( '[lyte-label]' );\n\t\tif(showTooltip) {\n\t\t\tthis.$node.classList.add( 'lyteCheckboxLabelEllipsis' );\n\t\t}\n\t\tif( showTooltip && labelElement && labelElement.offsetWidth < labelElement.scrollWidth ) {\n\t\t\tlabelElement.setAttribute( 'lt-prop-title', label );\n\t\t\tlabelElement.setAttribute( 'lt-prop-tooltip-config', JSON.stringify( tooltipConfig ) );\n\t\t\tlabelElement.setAttribute( 'lt-prop-tooltip-class', tooltipClass );\n\t\t}\n\t}\n\n    setRandomId() {\n\t\tthis.setData('randomId', 'lyte-checkbox-label-' + window._lyteUiUtils.cboxId++);\n\t}\n\n    focusInput() {\n\t\tvar input = this.$node.querySelector('input'),\n\t\t\tdoesNeedFocus = document.activeElement !== input;\n\n\t\t// Clicking on label doesn't focus checkbox in ff and safari\n\t\tif (doesNeedFocus) {\n\t\t\tinput.focus();\n\t\t}\n\t}\n\n    didConnect() {\n\t\tvar that = this, newAria = this.getData('ltPropAriaCheckbox');\n\n\t\tvar dataIndex = this.getData('ltPropDataTabindex')\n\t\tthis.$node.setAttribute('data-tabindex', dataIndex)\n\n\t\tthis.reduceOpacity();\n\n\t\tthis.$node.click = function () {\n\t\t\tvar ev = new Event('click', {\n\t\t\t\tbubbles: true,\n\t\t\t\tcancelable: true\n\t\t\t}),\n\t\t\t\tnode = that.$node,\n\t\t\t\tchecked = node.ltProp('checked'),\n\t\t\t\tdisabled = node.ltProp('disabled'),\n\t\t\t\treadonly = node.ltProp('readonly'),\n\t\t\t\tunbound = that.getData('lyteUnbound'),\n\t\t\t\titem = that.$node.querySelector('input');\n\n\t\t\tif (disabled || readonly) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthat.setData('eventCache', ev);\n\t\t\t// that.setData( 'preventRefire', true );\n\n\t\t\tthat.setData('internalChange', true);\n\t\t\tthat.clickFn = true;\n\n\t\t\tif (checked) {\n\t\t\t\tnode.ltProp('checked', false);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnode.ltProp('checked', true);\n\t\t\t}\n\n\t\t\t// Unbound checkboxes don't check/uncheck visually on their own because we rely on lt-prop-checked to do it\n\t\t\t// TODO: The input will be checked in onBefore callbacks\n\t\t\t// TODO: This needs to be changed when LN provides the relevant APIs to check if it is unbound\n\t\t\tif (that.$node._fR) {\n\t\t\t\tthat.setData('internalChange', false);\n\t\t\t\titem.checked = node.ltProp('checked');\n\n\t\t\t\tif (item.checked) {\n\t\t\t\t\titem.setAttribute('checked', '');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\titem.removeAttribute('checked')\n\t\t\t\t}\n\t\t\t\tthat.fireCallBacksFunction({}, false);\n\t\t\t}\n\n\t\t\tthat.clickFn = false;\n\t\t\t// that.setData( 'preventRefire', false );\n\t\t\t// that.fireCallBacksFunction( {}, false );\n\t\t\tnode.dispatchEvent(ev);\n\t\t}\n\n\t\tthis.$node.focus = function () {\n\t\t\tvar node = that.$node,\n\t\t\t\tinput = node.querySelector('input'),\n\t\t\t\tdisabled = node.ltProp('disabled'),\n\t\t\t\treadonly = node.ltProp('readonly');\n\n\t\t\tif (disabled || readonly) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tinput.focus();\n\t\t}\n\n\t\tthis.$node.blur = function () {\n\t\t\tvar node = that.$node,\n\t\t\t\tinput = node.querySelector('input'),\n\t\t\t\tdisabled = node.ltProp('disabled'),\n\t\t\t\treadonly = node.ltProp('readonly');\n\n\t\t\tif (disabled || readonly) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tinput.blur();\n\t\t}\n\n\t\tthis.fireCallBacksFunction.call(this, undefined, true);\n\t\tthis.addAriaValues({}, newAria);\n\t}\n\n    addAriaValues(oldAria, newAria) {\n\t\tvar checkbox = this.getCheckboxWidget();\n\n\t\twindow._lyteUiUtils.setAttribute(checkbox, newAria, oldAria);\n\t}\n\n    getCheckboxWidget() {\n\t\treturn this.$node.querySelector('input');\n\t}\n\n    fireCallBacksFunction(arg1, onrender) {\n\t\tvar checked = this.getData('ltPropChecked'),\n\t\t\tfoi = this.getData('ltPropFireOnInit'), returnval,\n\t\t\teventCache = this.getData('eventCache'), shouldBreak;\n\n\t\t// This property is very misleading don't use it for anything\n\t\tthis.$node.checked = checked ? checked : false;\n\n\t\tif (checked && onrender) {\n\t\t\tif (!foi) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar input = this.$node.querySelector('input');\n\t\t\tif (this.getMethods('onBeforeChecked')) {\n\t\t\t\tthis.executeMethod('onBeforeChecked', input, this, eventCache, 'script');\n\t\t\t}\n\n\t\t\tif (this.getMethods('onChecked')) {\n\t\t\t\tthis.executeMethod('onChecked', input, this, eventCache, 'script')\n\t\t\t}\n\n\t\t\tif (this.getMethods('onChanged')) {\n\t\t\t\tthis.executeMethod('onChanged', input, this, eventCache, 'script', this.getData( 'ltPropChecked' ) )\n\t\t\t}\n\t\t}\n\t\telse if (this.$node.checked && !onrender) {\n\t\t\tvar input = this.$node.querySelector('input');\n\n\t\t\tif (!this.clicked) {\n\t\t\t\tthis.setData('preventRefire', true);\n\n\t\t\t\tif (this.getMethods('onBeforeChecked')) {\n\n\t\t\t\t\tthis.data.ltPropChecked = false;\n\t\t\t\t\tinput.checked = false;\n\n\t\t\t\t\t// can return undefined or false\n\t\t\t\t\tshouldBreak = this.executeMethod('onBeforeChecked', input, this, eventCache, this.eventType()) === false;\n\n\t\t\t\t\tif (shouldBreak) {\n\t\t\t\t\t\tif (this.isCheckedLbound()) {\n\t\t\t\t\t\t\tthis.setData('handleLbind', true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\t// I am doing this so that the framework will set the checked attribute\n\t\t\t\t\t\t\tthis.data.ltPropChecked = true;\n\t\t\t\t\t\t\tthis.setData('internalChange', true);\n\t\t\t\t\t\t\tthis.setData('ltPropChecked', false);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.setData('preventRefire', false);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.data.ltPropChecked = true;\n\t\t\t\t\t\tinput.checked = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.setData('preventRefire', false);\n\t\t\t}\n\n\t\t\tif (this.getMethods('onChecked')) {\n\t\t\t\tthis.executeMethod('onChecked', input, this, eventCache, this.eventType());\n\t\t\t}\n\n\t\t\tthis.toggleClass( _lyteCbox.checkedClass );\n\n\t\t\tif (this.getMethods('onChanged')) {\n\t\t\t\tthis.executeMethod('onChanged', input, this, eventCache, this.eventType(), this.getData( 'ltPropChecked' ) );\n\t\t\t}\n\n\t\t\twindow._lyteUiUtils.dispatchEvent( 'checkboxchange', this.$node, { originalEvent: eventCache } );\n\t\t}\n\t\telse if (!this.$node.checked && !onrender) {\n\t\t\tvar input = this.$node.querySelector('input');\n\n\t\t\tif (!this.clicked) {\n\t\t\t\tthis.setData('preventRefire', true);\n\t\t\t\t// this.setData( 'ltPropChecked', true );\n\n\t\t\t\tif (this.getMethods('onBeforeUnchecked')) {\n\n\t\t\t\t\tthis.data.ltPropChecked = true;\n\t\t\t\t\tinput.checked = true;\n\n\t\t\t\t\tshouldBreak = this.executeMethod('onBeforeUnchecked', input, this, eventCache, this.eventType()) === false;\n\n\t\t\t\t\tif (shouldBreak) {\n\t\t\t\t\t\tif (this.isCheckedLbound()) {\n\t\t\t\t\t\t\tthis.setData('handleLbind', true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthis.data.ltPropChecked = false;\n\t\t\t\t\t\t\tthis.setData('internalChange', true);\n\t\t\t\t\t\t\tthis.setData('ltPropChecked', true);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.setData('preventRefire', false);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.data.ltPropChecked = false;\n\t\t\t\t\t\tinput.checked = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.setData('preventRefire', false);\n\t\t\t}\n\n\t\t\tif (this.getMethods('onUnchecked')) {\n\t\t\t\tthis.executeMethod('onUnchecked', input, this, eventCache, this.eventType());\n\t\t\t}\n\n\t\t\tthis.toggleClass( _lyteCbox.uncheckedClass );\n\n\t\t\tif (this.getMethods('onChanged')) {\n\t\t\t\tthis.executeMethod('onChanged', input, this, eventCache, this.eventType(), this.getData( 'ltPropChecked' ) );\n\t\t\t}\n\n\t\t\twindow._lyteUiUtils.dispatchEvent( 'checkboxchange', this.$node, { originalEvent: eventCache } );\n\t\t}\n\n\t}\n\n    // class added only when it is checked/unchecked by user. Not added during initial render. Used to handle animations\n    toggleClass(cls) {\n\t\tvar clsToRemove = cls === _lyteCbox.checkedClass ? _lyteCbox.uncheckedClass : _lyteCbox.checkedClass;\n\n\t\tthis.$node.classList.remove(clsToRemove);\n\t\tthis.$node.classList.add(cls);\n\t}\n\n    eventType() {\n\t\tvar isClicked = this.clicked || this.clickFn,\n\t\t\tkey = this.eveType;\n\n\t\tif (!isClicked) {\n\t\t\treturn 'script';\n\t\t}\n\n\t\treturn key ? key : 'click';\n\t}\n\n    isCheckedLbound() {\n\t\tif (!this.$node._attributeDetails) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.$node._attributeDetails['lt-prop-checked'] ? !!this.$node._attributeDetails['lt-prop-checked'].isLbind : false;\n\t}\n\n    isNodeDestroyed() {\n\t\treturn !this.$node;\n\t}\n\n    fireClick(event) {\n\t\tvar input, hasClickHandlerFired = this.getData('sendEvent'),\n\t\t\tdisabled = this.getData('ltPropDisabled'), clickEvent;\n\n\t\tthis.isTimeoutInitiated = false;\n\n\t\t// sendEvent is going to tell us if the click handler was called or not\n\t\t/* fireClick will be called twice during 1 user click\n\t\t   hasClickHandlerFired will make sure the checkbox's state is only changed once since sendEvent gets reset in the mup function\n\t\t   metaOrShift makes sure this gets triggered only when meta or shift key is pressed\n\t\t   So change state once only when meta or shift is pressed in firefox but this can still interfer with lyte-state attribute\n\t\t   since the attribute doesn't want the click to get triggered. so mup gets triggered -> we change state -> but no click gets fired\n\t\t*/\n\t\tif (!this.isNodeDestroyed() && !hasClickHandlerFired && !disabled && this.metaOrShiftPressed) {\n\t\t\tinput = this.$node.querySelector('input');\n\t\t\tinput.checked = !input.checked;\n\n\t\t\t// This calls the click function\n\t\t\tclickEvent = new Event('click');\n\t\t\tclickEvent.shiftKey = true;\n\t\t\tinput.dispatchEvent(clickEvent);\n\t\t}\n\t}\n\n    static actions() {\n        return {\n            preventInputClick: function (event) {\n                if (event.keyCode === 32) {\n                    event.preventDefault();\n                }\n            },\n\n            mup: function (event) {\n                var readonly = this.getData( 'ltPropReadonly' );\n\n                this.metaOrShiftPressed = event.metaKey || event.shiftKey;\n                this.setData('prevented', false);\n                this.setData('sendEvent', false);\n\n                var disabled = this.getData('ltPropDisabled'), checked, returnval;\n\n                if (disabled) {\n                    return;\n                }\n\n                if( readonly ) {\n                    event.preventDefault();\n                    return ;\n                }\n\n                var ele = this.$node.querySelector('input')\n                checked = ele.checked\n                if (this.getMethods('onBeforeChecked') && !checked) {\n                    returnval = this.executeMethod('onBeforeChecked', ele, this, event, 'click') == false ? false : true;\n                    if (!returnval) {\n                        this.setData('prevented', true);\n                        event.preventDefault();\n                    }\n                }\n\n                else if (this.getMethods('onBeforeUnchecked') && checked) {\n                    returnval = this.executeMethod('onBeforeUnchecked', ele, this, event, 'click') == false ? false : true;\n                    if (!returnval) {\n                        this.setData('prevented', true)\n                        event.preventDefault();\n                    }\n                }\n            },\n\n            prevent: function (event) {\n                var se = this.getData('sendEvent'),\n                    isFireFox = !!~window.navigator.userAgent.indexOf('Firefox'),\n                    isTimeoutInitiated = this.isTimeoutInitiated;\n\n                // Two events originate - one from the user click and another from the browser click\n                // We only allow the user click event to bubble up not the browser click\n\n                // In the newer versions of the framework 3 events are originating.?\n                if (!se) {\n                    event.stopPropagation();\n                }\n\n                // Insanely hacky solution to fix firefox bug\n                // https://bugzilla.mozilla.org/show_bug.cgi?id=559506\n                if (isFireFox && !isTimeoutInitiated ) {\n                    this.isTimeoutInitiated = true;\n                    setTimeout(this.fireClick.bind(this, event), 0);\n                }\n\n            },\n\n            checkBoxClicked: function (event) {\n\n                var readonly = this.getData( 'ltPropReadonly' );\n\n                if( readonly ) {\n                    return ;\n                }\n\n                this.setData('sendEvent', true);\n                this.setData('eventCache', event);\n                this.clicked = true\n                var input;\n\n                this.focusInput();\n\n                if (this.getData('prevented')) {\n                    input = this.$node.querySelector('input');\n                    this.setData('prevented', false)\n                    this.setData('preventRefire', true)\n                    if (input.checked) {\n                        input.checked = false\n                    }\n                    else {\n                        input.checked = true\n                    }\n\n                    this.setData('preventRefire', false)\n                    this.clicked = false\n                    this.setData('eventCache', {});\n                    return;\n                }\n\n                if (this.getData('ltPropDisabled')) {\n                    this.clicked = false\n                    event.preventDefault()\n                    this.setData('eventCache', {});\n                    return;\n                }\n\n                var checked\n                var ele = event.target\n                checked = ele.checked;\n\n                // this.setData( 'preventRefire', true );\n                this.setData('internalChange', true);\n\n                if (!checked) {\n                    this.setData('ltPropChecked', false);\n                }\n                else {\n                    this.setData('ltPropChecked', true);\n                }\n\n                // this.setData( 'preventRefire', false );\n                // TODO: change this when LN gives his API\n                if (this.$node._fR) {\n                    this.setData('internalChange', false);\n\n                    if (this.getData('ltPropChecked')) {\n                        this.$node.querySelector('input').setAttribute('checked', '');\n                    }\n                    else {\n                        this.$node.querySelector('input').removeAttribute('checked');\n                    }\n                    this.fireCallBacksFunction({}, false);\n                }\n                // this.fireCallBacksFunction( {}, false );\n                this.setData('eventCache', {});\n                this.clicked = false\n            }\n        };\n    }\n\n    static observers() {\n        return {\n            ariaObserver: function (change) {\n                var oldAria = change.oldValue,\n                    newAria = change.newValue;\n\n                this.addAriaValues(oldAria, newAria);\n            }.observes('ltPropAriaCheckbox'),\n\n            disabledChange: function () {\n                this.reduceOpacity();\n            }.observes('ltPropDisabled'),\n\n            typeObs: function () {\n                this.setDefaults();\n                this.setRandomId();\n            }.observes('ltPropType', 'ltPropClass', 'ltPropLabelClass').on('init'),\n\n            labelChangedObserver: function() {\n                this.setTooltip();\n            }.observes( 'ltPropLabel', 'ltPropTooltipClass', 'ltPropShowTooltip', 'ltPropTooltipConfig' ).on( 'didConnect' ),\n\n            fireCallbacks:function( change, onrender ) {\n                var shouldPreventScriptChange = this.getData( 'ltPropPreventCallbackObservers' ),\n                internalChange = this.getData( 'internalChange' ),\n                currentState = this.getData( 'ltPropChecked' ),\n                classToAdd = currentState ? _lyteCbox.checkedClass : _lyteCbox.uncheckedClass;\n\n                this.setData('internalChange', false);\n\n                if (this.getData('preventRefire')) {\n                    return;\n                }\n\n                if (this.getData('preventObs')) {\n                    return;\n                }\n\n                if( !internalChange && shouldPreventScriptChange ) {\n                    this.toggleClass( classToAdd );\n                    return ;\n                }\n\n                if (this.getData('handleLbind')) {\n\n                    this.setData('preventObs', true);\n                    this.setData('internalChange', true);\n                    this.setData('ltPropChecked', !this.getData('ltPropChecked'));\n                    this.setData('preventObs', false);\n\n                    this.setData('handleLbind', false);\n                    return;\n                }\n\n                this.fireCallBacksFunction.call(this, change, onrender);\n            }.observes('ltPropChecked'),\n\n            focusCheckbox: function () {\n                var shouldFocus = this.getData('ltPropFocus');\n\n                if (shouldFocus) {\n                    this.$node.focus();\n                }\n\n                this.data.ltPropFocus = false;\n            }.observes('ltPropFocus').on('didConnect')\n        };\n    }\n}\n\ndocument.addEventListener('keyup', function (event) {\n\tvar keyCode = event.keyCode, node, checked, comp;\n\n\tif (keyCode === 32) {\n\n\t\tnode = document.activeElement;\n\n\t\tif (node.tagName !== 'INPUT') {\n\t\t\treturn;\n\t\t}\n\n\t\twhile (node.tagName !== 'LYTE-CHECKBOX'\n\t\t\t&& node.tagName !== 'HTML'\n\t\t) {\n\t\t\tnode = node.parentElement;\n\t\t}\n\n\t\tif (node.tagName === 'LYTE-CHECKBOX') {\n\t\t\t// We are calling the checkbox's click because we want all the callbacks to be properly fired.\n\t\t\t// We'll be preventing the default behaviour of the browser in the keyup and keypress events\n\t\t\tnode.component.eveType = 'key';\n\t\t\tnode.click();\n\t\t\tnode.component.eveType = '';\n\t\t}\n\t}\n}, true);\n\n/**\n * @syntax nonYielded\n * <lyte-checkbox lt-prop-value=\"1\" lt-prop-label=\"check me\"></lyte-checkbox>\n */\n\n/**\n * @syntax yielded\n * <lyte-checkbox lt-prop-value=\"1\" lt-prop-yield=\"true\">\n *     <template is=\"registerYield\" yield-name=\"yield\">\n *         check me\n *     </template>\n * </lyte-checkbox>\n */\n\nexport { LyteCheckboxComponent };\n\n","import './../helpers/helpers-dev.js';\nimport { prop } from \"@slyte/core\";\nimport { Component, LyteUiComponentComponentRegistry } from \"../component.js\";\nimport $L from \"@zoho/lyte-dom\";\nimport \"../../plugins/lyte-search.js\";\n\nwindow._lyteDropdownItemId = 0;\nwindow._lyteDropdownBodyId = 0;\n\n/**\n * Renders a dropdown\n * @component lyte-dropdown\n * @version 1.0.0\n * @utility toggle,resetPosition,open,close\n * @methods onShow,onBeforeShow,onScroll,onPositionChanged,onChange,beforeSelect,onHide,onBeforeHide,onAdd,onBeforeAdd,onRemove,onBeforeRemove,onOptionSelected\n * @dependencies lyte-tooltip\n */\n\n// _preventSetCSS has external depedency - pk - dateselect\n\nclass LyteDropdownComponent extends Component {\n    constructor() {\n        super();\n    }\n\n    init() {\n\t\tvar type = this.getData('ltPropType'),\n\t\t\tsel = this.getData('ltPropSelected');\n\t\tthis._close = this.closeDrop1.bind(this);\n\n\t\tthis._transEnd = this.tranEnd.bind(this);\n\n\t\tif (this.getData('ltPropPreventParentScroll')) {\n\t\t\tthis.setData('ltPropFreeze', false);\n\t\t}\n\n\t\tif (!this.freezeLayerCreated()) {\n\t\t\tthis.createFreezeLayer();\n\t\t}\n\n\t\tthis.$node.getItem = function( val ) {\n\t\t\tvar component = this.component,\n\t\t\tbox = this.getDropBox(),\n\t\t\tbody = component.getDropBody( box );\n\n\t\t\treturn component.getItem( component.getAllItems( body ), val );\n\t\t}\n\n\t\tthis.$node.resetPosition = function () {\n\t\t\tvar comp = this.component,\n\t\t\t\tshouldUseSave = comp.getData('ltPropFixPositionOnOpen');\n\n\t\t\tcomp.setCss(false, shouldUseSave);\n\t\t}\n\n\t\t// Create toggle function\n\t\tthis.$node.toggle = function (event, type) {\n\t\t\tvar val = event ? event : undefined;\n\t\t\tif (this.component.getData('ltPropDisabled') || this.component.getData('ltPropReadOnly')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.component.showHide(val, type, true);\n\t\t}\n\n\t\tthis.$node.getDropBox = function () {\n\t\t\tvar component = this.component;\n\n\t\t\treturn component.getDropBox();\n\t\t}\n\n\t\tthis.$node.open = function () {\n\t\t\tvar component = this.component,\n\t\t\t\tisOpen = component.getData('ltPropIsOpen');\n\n\t\t\tif (!isOpen) {\n\t\t\t\tthis.toggle();\n\t\t\t}\n\t\t}\n\n\t\tthis.$node.close = function () {\n\t\t\tvar component = this.component,\n\t\t\t\tisOpen = this.getData('ltPropIsOpen');\n\n\t\t\tif (isOpen) {\n\t\t\t\tthis.toggle();\n\t\t\t}\n\n\t\t}\n\n\t\tthis.$node.getInitialSelected = function (options) {\n\t\t\tvar component = this.component;\n\n\t\t\tcomponent.setInitialSelected(options);\n\n\t\t\treturn component.getData('ltPropSelected');\n\t\t}\n\n\t\tthis.$node.getDisplayValue = function () {\n\t\t\tvar component = this.component,\n\t\t\t\tlink = component.childComp,\n\t\t\t\tbody = component.getDropBody(link),\n\t\t\t\tsel = component.getData('ltPropSelected'),\n\t\t\t\tnode;\n\n\t\t\tif (sel) {\n\t\t\t\t// node = body.querySelector( '[data-value=\"' + window._lyteUiUtils.escape( sel ) + '\"]' );\n\t\t\t\tnode = component.getItem(component.getAllItems(body), sel);\n\n\t\t\t\tif (node) {\n\t\t\t\t\treturn node.textContent.trim();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn '';\n\t\t}\n\n\t\tthis.$node.closeError = function () {\n\t\t\tvar component = this.component,\n\t\t\t\tlink = component.childComp,\n\t\t\t\tdrophead = component.getData('drophead'),\n\t\t\t\tbody = component.getDropBody(link),\n\t\t\t\tnodes = body.querySelectorAll('lyte-drop-item:not(.lyteDropdownActive):not(.lyteSearchHidden)');\n\n\t\t\tif (nodes.length !== 0) {\n\t\t\t\tcomponent.closeError(link, drophead);\n\t\t\t}\n\t\t}\n\n\t\tthis.$node.updateBoxAria = function (key, value) {\n\t\t\tvar component = this.component,\n\t\t\t\tbox = component.getDropBox();\n\n\t\t\tbox.setAttribute(key, value);\n\t\t}\n\n\t\tthis.$node.updateButtonAria = function (key, value) {\n\t\t\tvar component = this.component,\n\t\t\t\tbutton = component.getAriaButton();\n\n\t\t\tbutton.setAttribute(key, value);\n\t\t}\n\n\t\tthis.$node.updateBodyAria = function (key, value) {\n\t\t\tvar component = this.component,\n\t\t\t\tbody = component.getDropBody(component.childComp);\n\n\t\t\tbody.setAttribute(key, value);\n\t\t}\n\n\t\tthis.$node.setValue = function (value) {\n\t\t\tvar component = this.component,\n\t\t\t\tinput = component.getSearchBox();\n\n\t\t\tif (input && input.setValue) {\n\t\t\t\tinput.setValue(value);\n\t\t\t}\n\t\t}\n\n\t\tthis.$node.showNoResults = function() {\n\t\t\tvar box = this.getDropBox(),\n\t\t\terrorDiv = box.querySelector( '.lyteDropdownNoResult' );\n\n\t\t\tif( errorDiv ) {\n\t\t\t\terrorDiv.style.display = 'block';\n\t\t\t}\n\t\t}\n\n\t\tthis.$node.hideNoResults = function() {\n\t\t\tvar box = this.getDropBox(),\n\t\t\terrorDiv = box.querySelector( '.lyteDropdownNoResult' );\n\n\t\t\tif( errorDiv ) {\n\t\t\t\terrorDiv.style.display = 'none';\n\t\t\t}\n\t\t}\n\n\t\tthis.$node.scrollToSelected = function() {\n\t\t\tvar component = this.component;\n\n\t\t\tcomponent.scrollSel();\n\t\t}\n\n\t\tthis.$node.resetSelected = function() {\n\t\t\tvar component = this.component,\n\t\t\tselected = component.getData( 'ltPropSelected' );\n\n\t\t\tcomponent.setData( 'ltPropSelected', '' );\n\t\t\tcomponent.setData( 'ltPropSelected', selected );\n\t\t}\n\n\n\t\tif (type.indexOf('multiple') !== -1\n\t\t\t|| type.indexOf('multisearch') !== -1\n\t\t) {\n\t\t\tthis.setData('multiple', true);\n\n\t\t\tif (!sel) {\n\t\t\t\tthis.setData('ltPropSelected', '[]');\n\t\t\t}\n\n\t\t\tif (type.indexOf('multisearch') !== -1) {\n\t\t\t\tthis.setData('search', true);\n\t\t\t}\n\n\t\t\tthis.setIterator();\n\t\t}\n\t}\n\n    freezeLayerCreated() {\n\t\treturn document.getElementById( 'lytedropdownfreezelayer' );\n\t}\n\n    createFreezeLayer() {\n\t\tvar freezeLayer;\n\n\t\tfreezeLayer = document.createElement('div');\n\t\tfreezeLayer.setAttribute('id', 'lytedropdownfreezelayer');\n\t\tfreezeLayer.style.display = 'none';\n\t\tfreezeLayer.style.opacity = '0.01';\n\t\tfreezeLayer.style.background = '#fff';\n\n\t\tif( window._lyteUiUtils.appendLocation === 'first' ) {\n\t\t\tdocument.body.insertBefore( freezeLayer, document.body.children[ 0 ] );\n\t\t}\n\t\telse {\n\t\t\tdocument.body.appendChild( freezeLayer );\n\t\t}\n\t}\n\n    getSearchBox() {\n\t\treturn this.$node.querySelector('.lyteDropdownTextField');\n\t}\n\n    setIterator() {\n\t\tvar userValue = this.getData('ltPropUserValue'),\n\t\t\tsysValue = this.getData('ltPropSystemValue');\n\n\t\tthis.setData('userValue', userValue ? userValue : 'display');\n\t\tthis.setData('sysValue', sysValue ? sysValue : 'value');\n\t}\n\n    didDestroy() {\n\t\tvar body = this.childComp,\n\t\t\tmut = this.$node.mutobserver,\n\t\t\tfreeze = this.getData('ltPropFreeze'),\n\t\t\tscrollsToPrevent = this.getData('ltPropPreventScroll'),\n\t\t\ttype = this.getData( 'ltPropType' ),\n\t\t\ttab = this.getElementWithTabIndex();\n\n\t\twindow.clearTimeout(this.timeoutIdForOpen);\n\t\twindow.clearTimeout(this.timeoutIdForClose);\n\t\twindow.clearTimeout( this.scrollEndId );\n\n\t\tthis.popOutOfGlobalStack( this.$node );\n\n\t\tif (body) {\n\n\t\t\t// If a dropdown is getting destroyed when it is open, then we hide the freeze layer set because of it\n\t\t\tif (!body.classList.contains('lyteDropdownHidden')\n\t\t\t\t&& freeze\n\t\t\t\t&& scrollsToPrevent === 'all'\n\t\t\t) {\n\t\t\t\tdocument.getElementById('lytedropdownfreezelayer').style.display = 'none';\n\t\t\t}\n\n\t\t\tif (!body.classList.contains('lyteDropdownHidden') && document.body) {\n\t\t\t\tdocument.body.classList.remove('lyteBodyWrapper');\n\t\t\t}\n\n\t\t\tdelete body.origindd;\n\t\t\tbody.remove();\n\t\t}\n\n\t\tif (mut) {\n\t\t\tmut.disconnect()\n\t\t}\n\n\t\tthis.disableParentListeners();\n\n\t\t// Flush autoClosed when the autoClosed dropdown is getting destroyed\n\t\tif (window._lyteDropdown.autoClosed === this.$node) {\n\t\t\twindow._lyteDropdown.autoClosed = null;\n\t\t}\n\n\t\tif (window._lyteDropdown.lastDropdownWithAPromise === this.$node) {\n\t\t\twindow._lyteDropdown.lastDropdownWithAPromise = null;\n\t\t}\n\n\t\tif( type === 'multisearch' && tab ) {\n\t\t\t$L( tab ).removeSearch();\n\t\t}\n\n\t\tdelete this.childComp;\n\t\tdelete this.$node.toggle;\n\t\tdelete this.$node.element;\n\n\t\tthis.$node.mutobserver = null;\n\n\t\twindow.clearTimeout(this._FFBodyScrollOnRemove);\n\t\twindow.clearTimeout(this._FFBodyScrollOnAdd);\n\t}\n\n    disableParentListeners() {\n\t\tvar that = this;\n\n\t\tif (this.scrollableParents) {\n\t\t\tthis.scrollableParents.off('scroll', this.resetScroll);\n\t\t\tthis.scrollableParents.off( 'wheel', this.preventDefaultBehaviour );\n\t\t\tthis.scrollableParents.off( 'touchmove', this.preventDefaultBehaviour );\n\t\t}\n\n\t\tthis.scrollableParents = undefined;\n\n\t\tif (this.lyteScrollBarParents) {\n\n\t\t\tthis.lyteScrollBarParents.each(function (index, item) {\n\n\t\t\t\tif (item) {\n\t\t\t\t\titem.removeEventListener('touchmove', that.disableLyteScrollBar, true);\n\t\t\t\t\titem.removeEventListener('wheel', that.disableLyteScrollBar, true);\n\t\t\t\t}\n\n\t\t\t});\n\n\t\t\tthis.lyteScrollBarParents = undefined;\n\t\t}\n\n\t}\n\n    prerequisites() {\n\t\t// Not putting inside fastdom because it causes a jitter\n\t\tif (this.data.ltPropAnimate) {\n\t\t\tthis._hgtRemoval = true\n\t\t\t// body.style.height = '';\n\t\t}\n\t\tthis.setCss(false, true);\n\t\tthis.openSlideAnimate();\n\n\t\tif (this.getData('call')) {\n\t\t\tthis.childComp.removeAttribute('lyte-hidden');\n\t\t}\n\n\t\tthis.pushIntoGlobalStack( this.$node );\n\n\t\tthis.fireOnShow();\n\n\t\tif (this.shouldFocusFirstFocusableElement()) {\n\t\t\tthis.focusFirstFocusableElement();\n\t\t}\n\n\t\tthis.setData('call', null);\n\t}\n\n    pushIntoGlobalStack(node) {\n\t\tif( window._lyteUiUtils.popupStack && window._lyteUiUtils.popupStack.globalStack ) {\n\t\t\tif( this.alreadyPushed( node ) ) {\n\t\t\t\tthis.popOutOfGlobalStack( node );\n\t\t\t}\n\n\t\t\twindow._lyteUiUtils.popupStack.globalStack.push( {\n\t\t\t\tchildElement: this.getDropBox(),\n\t\t\t\tfocusedElement: document.activeElement,\n\t\t\t\tparentElement: node\n\t\t\t} );\n\t\t}\n\t}\n\n    alreadyPushed(node) {\n\t\treturn !!~this.findIndex( node );\n\t}\n\n    popOutOfGlobalStack(node) {\n\t\tif( window._lyteUiUtils.popupStack && window._lyteUiUtils.popupStack.globalStack ) {\n\t\t\tvar items = window._lyteUiUtils.popupStack.globalStack;\n\n\t\t\tvar index = this.findIndex( node );\n\n\t\t\tif( !!~index ) {\n\t\t\t\titems.splice( index, 1 );\n\t\t\t}\n\t\t}\n\t}\n\n    findIndex(node) {\n\t\tvar items = window._lyteUiUtils.popupStack.globalStack;\n\n\t\tfor( var i = 0; i < items.length; i++ ) {\n\t\t\tif( items[ i ].parentElement === node ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n    shouldFocusFirstFocusableElement() {\n\t\treturn this.getData('ltPropAllowFocusableElements');\n\t}\n\n    focusFirstFocusableElement() {\n\t\tvar element = this.getFirstFocusableElement();\n\n\t\tif (element) {\n\t\t\telement.focus();\n\t\t}\n\n\t}\n\n    getFirstFocusableElement() {\n\t\tvar box = this.$node.getDropBox();\n\n\t\treturn box.querySelector(window._lyteDropdown.focusableElementsSelector);\n\t}\n\n    fireOnShow() {\n\t\tvar ev;\n\n\t\tif (this.getData('call') && this.getMethods('onShow')) {\n\t\t\tev = this.getData('call');\n\t\t\tev = ev === true ? undefined : ev;\n\t\t\tthis.executeMethod('onShow', ev, this);\n\t\t}\n\n\t\twindow._lyteUiUtils.dispatchEvent('lytedropdownshow', this.$node);\n\t}\n\n    // Do a dfs to find the types of dropdown\n    getChildren(childs) {\n\t\tvar head = this.getData('drophead'),\n\t\t\tbody = this.getData('dropbody'),\n\t\t\ttag, i = 0, drop = this.$node;\n\n\t\tif (head === 'yield' && body === 'yield') {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (; i < childs.length; i++) {\n\n\t\t\ttag = childs[i].tagName;\n\t\t\tif (tag === 'LYTE-DROPDOWN'\n\t\t\t\t|| tag === 'TEMPLATE'\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (tag === 'LYTE-DROP-BOX') {\n\t\t\t\tthis.setData('dropbody', 'yield');\n\t\t\t\tdrop.querySelector('lyte-drop-box').classList.add('lyteDropdownHidden');\n\t\t\t}\n\t\t\telse if (tag === 'LYTE-DROP-BUTTON') {\n\t\t\t\tthis.setData('drophead', 'yield');\n\t\t\t\twindow._lyteUiUtils.appendChild(drop.querySelector('.lyteDummyEventContainer'), drop.querySelector('lyte-drop-button'))\n\t\t\t\ti--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.getChildren(childs[i].children);\n\t\t\t}\n\t\t}\n\t}\n\n    setBoxClass(oldValue) {\n\t\tvar cls = this.getData('ltPropBoxClass'),\n\t\t\tbox = this.childComp || this.$node.querySelector('lyte-drop-box'),\n\t\t\tbody = this.getData('dropbody');\n\n\t\tif (body === 'noyield') {\n\t\t\tif (oldValue) {\n\t\t\t\t$L(box).removeClass(oldValue);\n\t\t\t}\n\n\t\t\tif (cls) {\n\t\t\t\t$L(box).addClass(cls);\n\t\t\t}\n\t\t}\n\n\t}\n\n    setButtonClass(oldValue) {\n\t\tvar cls = this.getData('ltPropButtonClass'),\n\t\t\tbutton = this.$node.querySelector('lyte-drop-button');\n\n\t\tif (oldValue) {\n\t\t\t$L(button).removeClass(oldValue);\n\t\t}\n\n\t\tif (cls) {\n\t\t\t$L(button).addClass(cls);\n\t\t}\n\t}\n\n    setIconClass() {\n\t\tvar multiple = this.getData('multiple'),\n\t\t\tdropButton = this.getDropButton(),\n\t\t\tdrophead = this.getData('drophead');\n\n\t\tif (!multiple) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (drophead === 'yield') {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.hasIconClassChanged()) {\n\t\t\tdropButton.classList.add('ltDropdownIconNodePresent');\n\t\t\tthis.setData('shouldDisplayIcon', true);\n\t\t}\n\t\telse {\n\t\t\tdropButton.classList.remove('ltDropdownIconNodePresent');\n\t\t\tthis.setData('shouldDisplayIcon', false);\n\t\t}\n\t}\n\n    getDropButton() {\n\t\treturn this.$node.querySelector('lyte-drop-button');\n\t}\n\n    getActiveElement() {\n\t\tvar query = this.getData('ltPropActiveElement'), result;\n\n\t\tif (query) {\n\t\t\tresult = this.$node.querySelector(query) || this.$node.getDropBox().querySelector(query);\n\t\t}\n\n\t\tresult = result || this.getAriaButton();\n\n\t\treturn result;\n\t}\n\n    getAriaButton() {\n\t\treturn this.$node.querySelector('[role=\"combobox\"]');\n\t}\n\n    hasIconClassChanged() {\n\t\tvar iconCls = this.getData('ltPropIconClass');\n\n\t\treturn iconCls && iconCls !== 'dropdown';\n\t}\n\n    didConnect() {\n\t\tvar selList = this.getData('ltPropSelectedList') || [];\n\n\t\tthis.determineYieldContents();\n\t\tthis.setClassAttributes();\n\t\tthis.calculateSelected = selList.length > 0;\n\t\tthis.bindEvents();\n\t\tthis.addCallout();\n\t\tthis.setSelectedDuringRender();\n\t\tthis.toggleButtonInteractivity();\n\t\tthis.toggleDropdownClass();\n\t\t// Bad way to trigger an observer\n\t\tthis.setData('preventDisp', true);\n\t\tthis.setData('changeItToInvoke', this.getData('changeItToInvoke') + 1);\n\t\tthis.setData('preventDisp', false);\n\t\tthis.setSelectedFromList(true);\n\t\tthis.toggleDropdown();\n\t\tthis.attachErrorDiv();\n\t\tthis.showNoResultDiv();\n\t\tthis.fireAfterRender();\n\t}\n\n    fireAfterRender() {\n\t\tif( this.getMethods( 'onAfterRender' ) ) {\n\t\t\tthis.executeMethod( 'onAfterRender', this.$node );\n\t\t}\n\t}\n\n    attachErrorDiv() {\n\t\tvar errorDiv = this.createErrorDiv(),\n\t\tbody = this.getDropBody( this.getDropBox() );\n\n\t\tif( errorDiv ) {\n\t\t\tbody.appendChild( errorDiv );\n\t\t}\n\t}\n\n    toggleDropdown() {\n\t\tvar show = this.getData( 'ltPropShow' ),\n\t\tdrop = this.$node, tab = this.getElementWithTabIndex();\n\n\t\tif ( show ) {\n\t\t\tthis.setData( 'ltPropShow', false );\n\t\t\tdrop.toggle();\n\n\t\t\t$L.fastdom.measure( function() {\n\t\t\t\ttab.focus();\n\t\t\t\tvar pos = drop.getBoundingClientRect();\n\n\t\t\t\t// This doesn't work exactly it can be behind a overflow'd div and still not be visible.\n\t\t\t\tif (pos.left < 0\n\t\t\t\t\t|| pos.top < 0\n\t\t\t\t) {\n\t\t\t\t\tdrop.scrollIntoView();\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t}\n\n    toggleButtonInteractivity() {\n\t\tvar tab = this.getElementWithTabIndex(),\n\t\tdisabled = this.getData( 'ltPropDisabled' ),\n\t\tdataTabIndex = this.getData( 'ltPropDataTabindex' ),\n\t\ttabIndex = this.getData( 'ltPropTabindex' );\n\n\t\tif (disabled) {\n\t\t\tthis.disableClickableItem(tab);\n\t\t\ttab.setAttribute('tabindex', -1);\n\t\t\ttab.setAttribute('data-tabindex', \"\");\n\t\t}\n\t\telse {\n\t\t\tthis.enableClickableItem(tab);\n\t\t\ttab.setAttribute('tabindex', tabIndex);\n\t\t\ttab.setAttribute('data-tabindex', dataTabIndex);\n\t\t}\n\t}\n\n    bindEvents() {\n\t\tvar hover = this.getData( 'ltPropHover' ),\n\t\tbox = this.getDropBox(),\n\t\tbody = this.getDropBody( box ),\n\t\ttype = this.getData( 'ltPropType' ),\n\t\ttab;\n\n\t\tif( type === 'multisearch' ) {\n\t\t\ttab = this.getElementWithTabIndex();\n\t\t\ttab && tab.addEventListener( 'keyup', this.fireCheckKey.bind( this ) );\n\t\t}\n\n\t\tbox.addEventListener('click', function (event) {\n\t\t\tthis.processElements(event);\n\t\t}.bind(this));\n\n\t\tif (hover) {\n\t\t\tbox.addEventListener('mouseout', function (event) {\n\t\t\t\tthis.closeIt(event);\n\t\t\t}.bind(this));\n\t\t}\n\n\t\tbody.addEventListener('scroll', function (event) {\n\t\t\tthis.callOnScroll(event, this);\n\t\t}.bind(this));\n\n\t\tbox.addEventListener( 'mousemove', this.highlightDropItemsOnHover.bind( this ) );\n\t}\n\n    determineYieldContents() {\n\t\tvar dropdownYield = this.$node.querySelector( 'lyte-yield' ),\n\t\thead, body;\n\n\t\tthis.determine( dropdownYield );\n\n\t\thead = this.getData('drophead');\n\t\tbody = this.getData('dropbody');\n\n\t\tif (head !== 'yield') {\n\t\t\tthis.setData('drophead', head = 'noyield');\n\t\t}\n\n\t\tif (body !== 'yield') {\n\t\t\tthis.setData('dropbody', body = 'noyield');\n\t\t}\n\t}\n\n    setSelectedDuringRender() {\n\t\tvar placeholder = this.getData('ltPropPlaceholder'),\n\t\tselected = this.getData('ltPropSelected'),\n\t\toptions = this.getData('ltPropOptions') || [],\n\t\tbody = this.getData( 'dropbody' ),\n\t\ttype = this.getData( 'ltPropType' );\n\n\t\tthis.setData('preventDisp', true);\n\n\t\t//We need to set the first value in the dropdown as the selected one\n\t\tif ( !placeholder && !selected && type !== 'multiple' && type !== 'multisearch' ) {\n\t\t\tif( options.length > 0 ) {\n\t\t\t\tthis.setSelectedFromOptions();\n\t\t\t}\n\t\t\telse if( body === 'yield' ) {\n\t\t\t\tthis.setSelectedFromYield();\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tthis.setData('preventDisp', false);\n\t}\n\n    setSelectedFromOptions(options) {\n\t\tvar options = options || this.getData('ltPropOptions') || [],\n\t\tfirstElement = options[ 0 ],\n\t\tflag = false,\n\t\tvalue;\n\n\t\tif (firstElement.constructor == Object) {\n\t\t\tif (Object.keys(firstElement).length == 1) {\n\t\t\t\tvalue = firstElement[Object.keys(firstElement)[0]];\n\t\t\t\tif (value.constructor == Array) {\n\t\t\t\t\tflag = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tif (flag) {\n\t\t\tif (Object.prototype.toString.call(value[0]) === '[object Object]') {\n\t\t\t\tthis.setData('ltPropSelected', value[0][this.getData('ltPropSystemValue')]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.setData('ltPropSelected', value[0]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (Object.prototype.toString.call(firstElement) === '[object Object]') {\n\t\t\t\tthis.setData('ltPropSelected', firstElement[this.getData('ltPropSystemValue')]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.setData('ltPropSelected', firstElement);\n\t\t\t}\n\n\t\t}\n\t}\n\n    setSelectedFromYield() {\n\t\tvar node = this.getFirstEnabledItem();\n\n\t\tif (node) {\n\t\t\tnode.setAttribute('selected', true);\n\t\t}\n\t}\n\n    highlightDropItemsOnHover(event) {\n\t\tvar cur = event.target,\n\t\t\tcurTar = event.currentTarget,\n\t\t\tprev = curTar.querySelector('.lyteDropdownSelection'),\n\n\t\t\t// This overrides everything\n\t\t\tpreventNavigation = this.getData( 'ltPropPreventNavigation' );\n\n\t\tif( preventNavigation ) {\n\t\t\treturn ;\n\t\t}\n\n\t\tcur = window._lyteDropdown.traverse(cur, ['LYTE-DROP-ITEM']);\n\n\t\tif (this.hasMousePositionNotChanged(event) || cur === prev) {\n\t\t\treturn;\n\t\t}\n\n\t\t// This will make sure that it is removed for disabled items which have pointer-events:none\n\t\tif (prev) {\n\t\t\tprev.classList.remove('lyteDropdownSelection');\n\t\t}\n\n\t\tif (!cur || cur.tagName !== 'LYTE-DROP-ITEM') {\n\t\t\treturn;\n\t\t}\n\n\t\tif (cur.getAttribute('disabled') === 'true') {\n\t\t\treturn;\n\t\t}\n\n\t\tif (cur) {\n\t\t\tcur.classList.add('lyteDropdownSelection');\n\t\t\tthis.getActiveElement().setAttribute('aria-activedescendant', cur.getAttribute('id'));\n\t\t}\n\n\t}\n\n    createErrorDiv() {\n\t\tvar isErrorDivYield = this.getData( 'ltPropNoResultYield' ),\n\t\tnoResultText = this.getData('ltPropNoResult'),\n\t\terrorDiv;\n\n\t\tif( !isErrorDivYield ) {\n\t\t\terrorDiv = document.createElement( 'div' );\n\t\t\terrorDiv.setAttribute('class', 'lyteDropdownNoResult');\n\t\t\terrorDiv.textContent = noResultText;\n\t\t\terrorDiv.style.display = 'none';\n\t\t}\n\t\t\n\t\treturn errorDiv;\n\t}\n\n    processElements(event) {\n\t\tvar elm = event.target,\n\t\t\tmul = this.getData('multiple'),\n\t\t\tsearch = this.getData('search');\n\n\t\tif (search) {\n\t\t\tthis.focusInput();\n\t\t}\n\n\t\telm = window._lyteDropdown.traverse(elm, ['HTML', 'LYTE-DROP-ITEM']);\n\n\t\tif (!elm || elm.tagName === 'HTML') {               //Clicking on header should not call selection code\n\t\t\treturn;\n\t\t}\n\n\t\tif (elm.getAttribute('disabled') === 'true') {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !mul ) {\n\t\t\tthis.selectItem( event, elm );\n\t\t}\n\t\telse {\n\t\t\tthis.addItem( event, elm );\n\t\t}\n\t}\n\n    addItem(event, elm) {\n\t\tvar numberOfItemsGettingAdded = 1, src, ret,\n\t\toldSelected = this.getData('ltPropSelected'),\n\t\tthat = this;\n\n\t\tif ( this.beforeAddPromiseActive ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( this.checkLimit( numberOfItemsGettingAdded ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tsrc = elm.getAttribute('data-value');\n\n\t\tif (this.getMethods('onBeforeAdd')) {\n\t\t\tret = this.beforeAdd(event, elm, src);\n\t\t}\n\n\t\tif (this.isPromise(ret)) {\n\t\t\tthis.beforeAddPromiseActive = true;\n\n\t\t\tret.then(function () {\n\t\t\t\tthat.selectItemOfMultiSelect(event, elm, oldSelected);\n\t\t\t\tthat.beforeAddPromiseActive = false;\n\t\t\t}).catch(function (err) {\n\t\t\t\tconsole.error(err);\n\t\t\t\tthat.beforeAddPromiseActive = false;\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tif (ret) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.selectItemOfMultiSelect(event, elm, oldSelected);\n\t\t}\n\t}\n\n    selectItem(event, elm) {\n\t\tvar link = this.childComp, freeze = this.getData( 'ltPropFreeze' ),\n\t\toldSelected = this.getData( 'ltPropSelected' );\n\n\t\tif ( !this.beforeSelect( event, elm ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.setData( 'ltPropSelected', elm.getAttribute('data-value') );\n\t\tthis.optCall(event, this.getData('ltPropSelected'), elm);\n\t\tthis.fireOnChange(oldSelected, event, elm);\n\n\t\tif ( this.beforeHide( link, event, freeze ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.closeDrop(link, event, freeze);\n\t}\n\n    isPromise(obj) {\n\t\treturn typeof obj === 'object';\n\t}\n\n    selectItemOfMultiSelect(event, elm, oldSelected) {\n\t\tvar link = this.childComp,\n\t\t\telements = link.querySelectorAll('lyte-drop-item'),\n\t\t\tsrc = elm.getAttribute('data-value'),\n\t\t\thead = this.getData('drophead'),\n\t\t\ttype = this.getData('ltPropType'),\n\t\t\tsearch = this.getData('search'),\n\t\t\tinput = this.$node.querySelector('lyte-search') || this.$node.querySelector('input');;\n\n\t\tif (search && input.setValue && !this.isInputEmpty(input)) {\n\t\t\tinput.setValue('');\n\t\t}\n\n\t\tthis.setHighlight(elements, elm);\n\n\t\tthis.setData('prev', true);\n\t\telm.setAttribute('selected', 'true');\n\t\tthis.setData('prev', false);\n\n\t\telm.classList.add('lyteDropdownActive');\n\n\t\tthis.hideGroup(elm);\n\n\t\t// check this things position in code now.\n\t\tif (this.getMethods('onAdd')) {\n\t\t\tthis.executeMethod('onAdd', event, src, this.getData('ltPropSelected'), this, elm);\n\t\t}\n\n\t\tthis.showError(link, type, head);\n\n\t\tthis.fixBoxPosition();\n\t\tthis.fireOnChange(oldSelected, event, elm);\n\t}\n\n    setClassAttributes() {\n\t\tthis.setBoxClass();\n\t\tthis.setButtonClass();\n\t\tthis.setIconClass();\n\t\tthis.setClassForRemoveIcon();\n\t}\n\n    setClassForRemoveIcon() {\n\t\tvar shouldUseRemoveIcon = this.getData('ltPropShowRemoveIcon') && this.getData('ltPropSelected');\n\n\t\tif (shouldUseRemoveIcon) {\n\t\t\tthis.$node.classList.add('lyteDropdownWithDeselectIcon');\n\t\t}\n\t\telse {\n\t\t\tthis.$node.classList.remove('lyteDropdownWithDeselectIcon');\n\t\t}\n\t}\n\n    addCallout() {\n\t\tvar span, box = this.getDropBox();\n\n\t\tspan = document.createElement('span');\n\t\tspan.setAttribute('class', 'lyteArrow');\n\t\tbox.insertBefore(span, box.children[0]);\n\t}\n\n    addTabIndexForYieldedMultisearch() {\n\t\tvar type = this.getData('ltPropType'),\n\t\t\tdrophead = this.getData('drophead'),\n\t\t\ttabIndexElement = this.$node.querySelector('input'),\n\t\t\tindex = this.getData('ltPropTabindex'),\n\t\t\tdataIndex = this.getData('ltPropDataTabindex'),\n\t\t\tisDisabled = this.getData('ltPropDisabled');\n\n\t\tif (tabIndexElement && drophead === 'yield' && type === 'multisearch' && !isDisabled) {\n\t\t\ttabIndexElement.setAttribute('tabindex', index);\n\t\t\ttabIndexElement.setAttribute('data-tabindex', dataIndex);\n\t\t}\n\t}\n\n    getElementWithTabIndex() {\n\t\treturn this.$node.querySelector('[tabindex]') || this.$node.querySelector('input');\n\t}\n\n    getFirstEnabledItem() {\n\t\tvar body = this.getDropBody(this.childComp),\n\t\t\titems = body.querySelectorAll('lyte-drop-item'),\n\t\t\tdisabledList = this.getData('ltPropDisabledList') || [];\n\n\t\tfor (var i = 0; i < items.length; i++) {\n\t\t\tif (!~disabledList.indexOf(items[i].getAttribute('data-value'))) {\n\t\t\t\treturn items[i];\n\t\t\t}\n\t\t}\n\t}\n\n    hasMousePositionNotChanged(event) {\n\t\tvar curClientX = event.clientX,\n\t\t\tcurClientY = event.clientY,\n\t\t\tprevClientX = this.prevClientX,\n\t\t\tprevClientY = this.prevClientY;\n\n\t\tthis.prevClientX = curClientX;\n\t\tthis.prevClientY = curClientY;\n\n\t\tif (prevClientX === curClientX && prevClientY === curClientY) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n    tranEnd(evt) {\n\t\tvar box = this.childComp,\n\t\t\tisAnimate = this.getData('ltPropAnimate'),\n\t\t\tbody = this.data.ltPropAnimateBox ? box : this.getDropBody(box);\n\n\t\twindow.clearTimeout(this.timeoutIdForOpen)\n\n\t\tif (isAnimate) {\n\t\t\tbody.style.height = 'auto';\n\t\t}\n\n\t\tbox.classList.remove('lyteAnimate', 'lyteDropBoxAnimate');\n\t\tbox.removeEventListener('transitionend', this._transEnd)\n\t\tdelete this._prevent;\n\t\tdelete this._preventSetcss;\n\t\tdelete this._preventMutObs;\n\n\t\t// Hidden method\n\t\tif (this.getMethods('onAnimationEnd')) {\n\t\t\tthis.executeMethod('onAnimationEnd', evt, this);\n\t\t}\n\n\t\tvar isFF = this.isFF(),\n\t\t\tisOpen = this.getData('ltPropIsOpen');\n\n\t\tif (!isOpen) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (isFF && this.isBodyScrollable()) {\n\t\t\tthis.addProperScrollbar();\n\t\t}\n\t\telse if (isFF && !this.isBodyScrollable()) {\n\t\t\tthis.removeScrollbar();\n\t\t}\n\t}\n\n    openSlideAnimate() {\n\t\tif (this.getData('ltPropAnimate')) {\n\t\t\tif (this._preventSetcss) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (this._preventAnimate) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._preventAnimate = true;\n\t\t\tthis._preventSetcss = true\n\t\t\tthis._preventMutObs = true\n\t\t\tvar box = this.childComp ? this.childComp : this.$node.querySelector('lyte-drop-box'),\n\t\t\t\tisBoxAnimate = this.data.ltPropAnimateBox,\n\t\t\t\telem = isBoxAnimate ? box : this.getDropBody(this.childComp);\n\t\t\tthis._oriStyle = elem.style.height;\n\t\t\t// animation starts from zero\n\t\t\telem.style.height = 0;\n\t\t\t// for invert animation\n\t\t\tif (['up', 'upLeft', 'upRight'].indexOf(this.getData('pos')) != -1) {\n\t\t\t\tbox.style.top = parseInt(box.style.top) + this._hgt + 'px';\n\t\t\t}\n\n\t\t\tbox.classList.add('lyteAnimate');\n\t\t\tif (isBoxAnimate) {\n\t\t\t\tbox.classList.add('lyteDropBoxAnimate');\n\t\t\t}\n\t\t\t// setTimeout( function(){\n\t\t\t// animation class added\n\t\t\t// box.classList.add( 'lyteAnimate' );\n\t\t\tsetTimeout(function () {\n\t\t\t\t// invert anime starts\n\t\t\t\tif (['up', 'upLeft', 'upRight'].indexOf(this.getData('pos')) != -1) {\n\t\t\t\t\tbox.style.top = parseInt(box.style.top) - this._hgt + 'px';\n\t\t\t\t}\n\t\t\t\t// height animate starts\n\t\t\t\telem.style.height = this._hgt + 'px';\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tbox.addEventListener('transitionend', this._transEnd);\n\n\t\t\t\t\tif (!this._hgt) {\n\t\t\t\t\t\tthis.tranEnd.call(this, {})\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvar time = this.getTransitionTime(box);\n\n\t\t\t\t\t\t// A fail safe incase transitionend doesn't fire\n\t\t\t\t\t\tthis.timeoutIdForOpen = setTimeout(this._transEnd, time);\n\t\t\t\t\t}\n\t\t\t\t}.bind(this), 20)\n\t\t\t}.bind(this), 20)\n\t\t\t// }.bind(this), 20)\n\t\t}\n\t}\n\n    getTransitionTime(box) {\n\t\tvar tolerance = 100,\n\t\t\tduration = window.getComputedStyle(box).transitionDuration,\n\t\t\tres = tolerance;\n\n\t\tif (!!~duration.indexOf('ms')) {\n\t\t\tres += parseInt(duration);\n\t\t}\n\t\telse {\n\t\t\t// seconds\n\t\t\tres += parseFloat(duration) * 1000;\n\t\t}\n\n\t\treturn res;\n\t}\n\n    /**\n\t * This is going to determine the structure of the dropdown whether it is a single or dropdown within dropdown\n\t * @param {HTMLElement} yd - The yield of the dropdown\n\t *\n\t */\n\n    determine(yd) {\n\t\tvar children = yd.children,\n\t\t\thead, box, drop = this.$node, dummy, other;\n\n\t\tother = drop.querySelector('lyte-dropdown');\n\t\tif (other) {\n\t\t\tthis.getChildren(children);\n\t\t}\n\t\telse {\n\t\t\tbox = yd.querySelector('lyte-drop-box');\n\t\t\thead = yd.querySelector('lyte-drop-button');\n\n\t\t\tif (head) {\n\t\t\t\tdummy = drop.querySelector('.lyteDummyEventContainer');\n\t\t\t\tthis.setData('drophead', 'yield');\n\t\t\t\twindow._lyteUiUtils.appendChild(dummy, head);\n\t\t\t}\n\n\t\t\tif (box) {\n\t\t\t\tthis.setData('dropbody', 'yield');\n\t\t\t\tbox.classList.add('lyteDropdownHidden')\n\t\t\t}\n\t\t}\n\t}\n\n    /**\n\t * This is going to add a class to the drop-box for multiselects\n\t *\n\t */\n\n    addClass() {\n\t\tvar link = this.childComp;\n\n\t\tlink.classList.add('lyteMultiSelectDropdown');\n\t}\n\n    closeDrop(link, event, freeze, isScroll) {\n\t\twindow._lyteDropdown.autoClosed = null;\n\t\tthis.setData('ltPropIsOpen', false);\n\n\t\tif (this._prevent) {\n\t\t\treturn\n\t\t}\n\t\tif (this.getData('ltPropAnimate') && !isScroll) {\n\t\t\tvar isBoxAnimate = this.data.ltPropAnimateBox;\n\t\t\tthis._prevent = true;\n\t\t\tthis._preventSetcss = true;\n\t\t\tthis._arguments = arguments;\n\t\t\tthis.childComp.classList.add('lyteAnimate');\n\t\t\tif (isBoxAnimate) {\n\t\t\t\tthis.childComp.classList.add('lyteDropBoxAnimate');\n\t\t\t}\n\t\t\tsetTimeout(function () {\n\t\t\t\tvar box = this.childComp ? this.childComp : this.$node.querySelector('lyte-drop-box'),\n\t\t\t\t\telem = isBoxAnimate ? box : this.getDropBody(this.childComp);\n\n\t\t\t\telem.style.height = this._hgt + 'px';\n\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t// var box = this.childComp ? this.childComp : this.$node.querySelector('lyte-drop-box'),\n\t\t\t\t\t// elem = isBoxAnimate ? box : this.getDropBody( this.childComp );\n\n\t\t\t\t\t// height set to zero for hide animation\n\t\t\t\t\telem.style.height = 0;\n\t\t\t\t\t// invert animation\n\t\t\t\t\tif (['up', 'upLeft', 'upRight'].indexOf(this.getData('pos')) != -1) {\n\t\t\t\t\t\tbox.style.top = parseInt(box.style.top) + this._hgt + 'px';\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._animationStarted = true;\n\t\t\t\t\tthis._elem = elem;\n\t\t\t\t\tthis._box = box;\n\t\t\t\t\telem.addEventListener('transitionend', this._close);\n\n\t\t\t\t\tif (!this._hgt) {\n\t\t\t\t\t\tthis.closeDrop1.call(this)\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// A fail safe incase transitionend doesn't fire\n\t\t\t\t\t\tvar time = this.getTransitionTime(elem);\n\n\t\t\t\t\t\tthis.timeoutIdForClose = setTimeout(this._close, time);\n\t\t\t\t\t}\n\n\t\t\t\t}.bind(this), 20);\n\n\t\t\t}.bind(this), 20)\n\t\t} else {\n\t\t\tthis.closeDrop1(link, event, freeze)\n\t\t}\n\t}\n\n    closeDrop1(link, event, freeze) {\n\t\tvar bt = this.$node.querySelector('lyte-drop-button'),\n\t\t\tpos = this.getData('pos'), cls, mul = this.getData('multiple'), body,\n\t\t\tbox = this.getDropBox(),\n\t\t\tscrollsToPrevent = this.getData('ltPropPreventScroll'),\n\t\t\tpreventParentScroll = this.getData('ltPropPreventParentScroll');\n\n\t\twindow.clearTimeout(this.timeoutIdForClose);\n\n\t\tif (this._arguments) {\n\t\t\tlink = this._arguments[0], event = this._arguments[1], freeze = this._arguments[2]\n\t\t\tthis._elem.style.height = this._oriStyle;\n\t\t\t//animate class removal\n\t\t\tthis._box.classList.remove('lyteAnimate', 'lyteDropBoxAnimate');\n\t\t\tthis._elem.removeEventListener('transitionend', this._close)\n\t\t\tdelete this._hgt; delete this._oriStyle; delete this._arguments; delete this._elem; delete this._box;\n\t\t}\n\n\t\tif (mul) {\n\t\t\tbody = this.getDropBody(link);\n\t\t\tbody.scrollTop = 0;\n\t\t}\n\n\t\tlink.classList.add('lyteDropdownHidden');\n\t\tvar freezeLayer = document.querySelector('#lytedropdownfreezelayer')\n\t\tif (freeze && freezeLayer && scrollsToPrevent === 'all') {\n\t\t\tdocument.querySelector('#lytedropdownfreezelayer').style.display = 'none'\n\t\t}\n\n\t\tlink.style.left = '';\n\t\tlink.style.top = '';\n\t\tlink.style.bottom = '';\n\t\tlink.style.right = '';\n\n\t\tif (freeze || preventParentScroll) {\n\t\t\tdocument.body.classList.remove('lyteBodyWrapper');\n\t\t}\n\n\t\tthis.disableParentListeners();\n\n\t\tcls = this.removeClass(bt.classList, pos, 'lyteDropButton', true);\n\n\t\tif (cls) {\n\t\t\tbt.classList.remove(cls);\n\t\t}\n\n\t\tthis.popOutOfGlobalStack( this.$node );\n\n\t\tif (this.getMethods('onHide')) {\n\t\t\tthis.executeMethod('onHide', event, this);\n\t\t}\n\n\t\tthis.focusButton();\n\n\t\t// This if statement is a bad fix. Added so that the dropdown doesn't throw an error when it is destroyed in on-option-selected and box is empty\n\t\tif (box) {\n\t\t\tvar posClsToRemove = this.removeClass(box.classList, pos, 'lyteDropdown', true);\n\t\t}\n\n\t\tif (posClsToRemove) {\n\t\t\tbox.classList.remove(posClsToRemove);\n\t\t}\n\n\t\tthis.setData('pos', '');\n\t\tthis.setData('secondaryPosition', '');\n\t\tthis.setData('savedPositions', {});\n\n\t\tdelete this._prevent; delete this._preventSetcss;\n\t\tdelete this._preventAnimate;\n\t\tdelete this._animationStarted;\n\t}\n\n    focusButton() {\n\t\tvar isSearch = this.getData('search'),\n\t\t\tactiveElement = document.activeElement,\n\t\t\tfocusOnClose = this.getData('ltPropFocusOnClose');\n\n\t\t/* Not sure about multisearchs */\n\t\tif (focusOnClose && !isSearch && !this.isFocusable(activeElement)) {\n\t\t\tthis.preventScroll = true;\n\t\t\tthis.setData('ltPropFocus', true);\n\t\t\tthis.preventScroll = false;\n\t\t}\n\t}\n\n    isFocusable(element) {\n\t\tvar tabIndex;\n\n\t\telement = $L(element);\n\n\t\tif (!window._lyteDropdown.isVisible(element.get(0)) || element.is(\":disabled\")) {\n\t\t\treturn false;\n\t\t}\n\n\t\ttabIndex = element.attr(\"tabindex\");\n\t\ttabIndex = isNaN(tabIndex) ? -1 : tabIndex;\n\t\treturn element.is(\"button, input, select, textarea, a[href], area[href], iframe\") || tabIndex > -1;\n\t}\n\n    callOnScroll(event) {\n\t\tvar comp = this;\n\n\t\tif (this.getMethods('onScroll')) {\n\t\t\tthis.executeMethod('onScroll', event, this);\n\t\t}\n\n\t\tif( this.hasScrollEndReached( event ) && this.movingDownward( event ) ) {\n\t\t\twindow.clearTimeout( this.scrollEndId );\n\n\t\t\tthis.scrollEndId = setTimeout( function() {\n\t\t\t\tcomp.fireScrollEnd( event );\n\t\t\t}, 50 ); \n\t\t}\n\t}\n\n    movingDownward(event) {\n\t\tvar scrollingContainer = event.target,\n\t\tscrollTop = scrollingContainer.scrollTop,\n\t\tpreviousScrollTop = this.previousScrollTop || 0;\n\n\t\tthis.previousScrollTop = scrollTop;\n\n\t\treturn scrollTop - previousScrollTop > 0;\n\t}\n\n    hasScrollEndReached(event) {\n\t\tvar scrollingContainer = event.target,\n\t\tscrollTop = scrollingContainer.scrollTop,\n\t\theight = scrollingContainer.offsetHeight,\n\t\tscrollHeight = scrollingContainer.scrollHeight,\n\t\ttolerance = 5;\n\n\t\treturn height + scrollTop >= ( scrollHeight - tolerance );\n\t}\n\n    fireScrollEnd(event) {\n\t\tif( this.getMethods( 'onScrollEnd' ) ) {\n\t\t\tthis.executeMethod( 'onScrollEnd', event );\n\t\t}\n\t}\n\n    addDisabledClass(elements) {\n\t\tvar i = 0, ele;\n\t\tfor (; i < elements.length; i++) {\n\t\t\tele = elements[i];\n\t\t\tif (ele.getAttribute('disabled') == 'true') {\n\t\t\t\tele.classList.add('lyteDropdown-disabled');\n\t\t\t}\n\t\t\telse if (ele.classList.contains('lyteDropdown-disabled')) {\n\t\t\t\tele.classList.remove('lyteDropdown-disabled');\n\t\t\t}\n\t\t}\n\t}\n\n    showNoResultDiv() {\n\t\tvar show = this.getData('ltPropShowEmptyMessage'),\n\t\t\tlink = this.childComp,\n\t\t\tbody = this.getDropBody(link),\n\t\t\titems = body.querySelectorAll('lyte-drop-item'),\n\t\t\tnores = body.querySelector('.lyteDropdownNoResult'),\n\t\t\tmultiple = this.getData('multiple');\n\n\t\tif (!nores) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (show && !multiple) {\n\t\t\tif (items.length === 0) {\n\t\t\t\tnores.style.display = 'block';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnores.style.display = 'none';\n\t\t\t}\n\n\t\t}\n\t\telse if (!show && !multiple) {\n\t\t\tnores.style.display = 'none';\n\t\t}\n\t}\n\n    /**\n\t * The method is going to specify the class that needs to be removed from the classList\n\t * ( Might be buggy when lt-prop-position is changed as it only removes opposites)\n\t * @param {classList} arr - The classlist under question\n\t * @param {string} pos - The current position of the dropdown\n\t * @param {string} prefix - A prefix that is appended to the pos attribute to determine the class\n\t * @param {boolean} ignore - Tells whether we must search for the opposites\n\t * @param {string} suffix - A suffix added to the end of the class\n\t *\n\t */\n\n\n    removeClass(arr, pos, prefix, ignore, suffix) {\n\t\tif (!pos) {\n\t\t\treturn '';\n\t\t}\n\n\t\tsuffix = suffix || '';\n\n\t\tvar negate = {\n\t\t\t'up': 'Down',\n\t\t\t'down': 'Up',\n\t\t\t'left': 'Right',\n\t\t\t'right': 'Left'\n\t\t}, i = 0, len = arr.length,\n\n\t\t\tngcls = prefix\n\t\t\t\t+ (ignore ?\n\t\t\t\t\tpos[0].toUpperCase() + pos.substring(1)\n\t\t\t\t\t: negate[pos]) + suffix;\n\n\t\tfor (; i < len; i++) {\n\t\t\tif (arr[i] === ngcls) {\n\t\t\t\treturn ngcls;\n\t\t\t}\n\t\t}\n\n\t\treturn '';\n\t}\n\n    /*\n\t\tCalculate left of dropdown container when it has to come below/above the select element when it exceeds window.innerWidth and there is space to the right\n\t*/\n    setLeftExceedForDown(element, container, bcr, width, xscroll) {\n\t\tvar scrolledLeft = -xscroll,\n\t\t\telementBCR = this.getButton().getBoundingClientRect(),\n\t\t\telementLeft = elementBCR.left,\n\t\t\telementWidth = elementBCR.width,\n\t\t\telementRight = elementBCR.right,\n\t\t\ttotal = scrolledLeft + (window.innerWidth - elementRight);\n\n\t\treturn total\n\t}\n\n    /*\n\t\tCalculate left of dropdown container when it has to come below/above the select element when it doesn't exceed window.innerWidth\n\t*/\n    alignBoxToButtonLeft(element, bcr, xscroll) {\n\t\tvar scrolledLeft = xscroll,\n\t\t\telementBCR = this.getButton().getBoundingClientRect(),\n\t\t\telementLeft = elementBCR.left,\n\t\t\ttotal = scrolledLeft + elementLeft;\n\n\t\treturn total\n\t}\n\n    /*\n\t\tCalculate top of dropdown container when it has to come above the select element\n\t*/\n    setTopAboveForDown(element, container, bcr, containerbcr, yscroll) {\n\t\tvar scrolledHeight = -yscroll,\n\t\t\telementBCR = bcr,\n\t\t\telementTop = elementBCR.top,\n\t\t\tcontainerBCR = containerbcr,\n\t\t\tcontainerHeight = containerBCR.height,\n\t\t\ttotal = scrolledHeight + (window.innerHeight - elementTop);\n\n\t\tif (this._animationStarted) {\n\t\t\treturn scrolledHeight + (window.innerHeight - elementTop);\n\t\t}\n\n\t\treturn total\n\t}\n\n    /*\n\t\tCalculate top of dropdown container when it has to come below the select element\n\t*/\n    alignBoxTopToButtonBottom(element, bcr, yscroll) {\n\t\tvar scrolledHeight = yscroll,\n\t\t\telementBCR = bcr,\n\t\t\telementTop = elementBCR.top,\n\t\t\telementHeight = elementBCR.height,\n\t\t\ttotal = scrolledHeight + elementTop + elementHeight;\n\n\t\treturn total\n\t}\n\n    /*\n\t\tCalculate left of dropdown container when it has to come to right of the select element\n\t*/\n    setLeftForRight(element, bcr, xscroll) {\n\t\tvar scrolledWidth = xscroll,\n\t\t\telementBCR = bcr,\n\t\t\telementLeft = elementBCR.left,\n\t\t\telementWidth = elementBCR.width,\n\t\t\ttotal = scrolledWidth + elementLeft + elementWidth;\n\n\t\treturn total\n\t}\n\n    /*\n\t\tCalculate right of dropdown container when it has to come to left of the select element of right dropdown\n\t*/\n    setRightForRight(element, container, bcr, width, xscroll) {\n\t\tvar scrolledWidth = -xscroll,\n\t\t\telementBCR = bcr,\n\t\t\telementLeft = elementBCR.left,\n\t\t\ttotal = scrolledWidth + (window.innerWidth - elementLeft);\n\n\t\treturn total\n\t}\n\n    /*\n\t\tCalculate top of dropdown container when it has to come to right of dropdown and there is space below\n\t*/\n    setTopForRight(element, bcr, yscroll) {\n\t\tvar scrolledHeight = yscroll,\n\t\t\telementBCR = bcr,\n\t\t\telementTop = elementBCR.top,\n\t\t\ttotal = scrolledHeight + elementTop;\n\n\t\treturn total\n\t}\n\n    /*\n\t\tCalculate top of dropdown container when it has to come to right of dropdown and there is no space below\n\t*/\n    setTopForRightAbove(element, container, bcr, elembcr, yscroll) {\n\t\tvar scrolledHeight = -yscroll,\n\t\t\telementBCR = bcr,\n\t\t\telementTop = elementBCR.top,\n\t\t\telementHeight = elementBCR.height,\n\t\t\telementBottom = elementBCR.bottom,\n\t\t\tcontainerBCR = elembcr,\n\t\t\tcontainerHeight = containerBCR.height,\n\t\t\ttotal = scrolledHeight + (window.innerHeight - elementBottom);\n\n\t\tif (this._animationStarted) {\n\t\t\treturn scrolledHeight + (window.innerHeight - elementBottom);\n\t\t}\n\n\t\treturn total\n\t}\n\n    /**\n\t\tRemove wrong arrow and append proper arrow\n\t\t@param string correct - the correct class\n\t*/\n    setCorrectClass(cls) {\n\t\tvar arrow = this.childComp.querySelector('.lyteArrow'),\n\t\t\tlist = arrow.classList, i = 0;\n\t\tfor (; i < list.length; i++) {\n\t\t\tif (list[i] == 'lyteArrow' || list[i] == cls) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tarrow.classList.remove(list[i]);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\tarrow.classList.add(cls);\n\t\tarrow.classList.add('lyteArrowIcon');\n\t}\n\n    /**\n\t * This going to check if a class has been toggled\n\t * @param {MutationRecord} rec - The mutation record\n\t * @param {String} cls - The class that needs to be checked\n\t *\n\t */\n    hasClassToggled(rec, cls) {\n\t\tvar old = rec.oldValue ? rec.oldValue.trim().split(\" \") : [],\n\t\t\tnode = rec.target,\n\t\t\tolen = old.length,\n\t\t\tnlen = node.classList.length;\n\n\t\tif (((!!~old.indexOf(cls)\n\t\t\t&& !node.classList.contains(cls))\n\t\t\t|| (!~old.indexOf(cls)\n\t\t\t\t&& node.classList.contains(cls)\n\t\t\t))\n\n\t\t\t// Only 1 class changed\n\t\t\t&& Math.abs(olen - nlen) === 1\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n    /**\n\t * The adjust width is going to adjust the width of the dropdown's body that is going to open\n\t * @param {Element} body - The lyte-drop-box\n\t * @param {Number} pwidth - The width of the parent Element\n\t * @param {Number} bwidth - The width of the body Element\n\t *\n\t */\n\n    adjustWidth(body, pwidth, bwidth) {\n\t\tvar boxButtonWidth = this.getData('ltPropBoxButtonWidth'), newWidth;\n\n\t\tif (boxButtonWidth === 'min-button') {\n\t\t\tthis.setData('widthAdjusted', 1);\n\n\t\t\tif (bwidth > pwidth) {\n\t\t\t\tthis.setData('widthAdjusted', 2);\n\t\t\t}\n\n\t\t\tbody.style.minWidth = pwidth + 'px';\n\t\t}\n\t\telse if (boxButtonWidth === 'auto') {\n\t\t\tthis.setData('widthAdjusted', 1);\n\t\t\tbody.style.width = 'auto';\n\t\t\tnewWidth = body.getBoundingClientRect().width;\n\n\t\t\tif (newWidth > pwidth) {\n\t\t\t\tthis.setData('widthAdjusted', 2);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis.setData('widthAdjusted', 1);\n\t\t\tbody.style.width = pwidth + 'px';\n\t\t\tbody.style.minWidth = pwidth + 'px';\n\t\t}\n\n\t\treturn body.getBoundingClientRect().width;\n\n\t}\n\n    getFocusableElements() {\n\t\tvar dropdown = this.$node,\n\t\t\tbox = dropdown.getDropBox();\n\n\t\treturn box.querySelectorAll(window._lyteDropdown.focusableElementsSelector);\n\t}\n\n    /**\n\t * This is going to return the proper drop-body tag of the dropdown - ( dropdown inside dropdown )\n\t * @param {Element} box - The lyte-drop-box of the dropdown\n\t *\n\t */\n\n    getDropBody(link) {\n\t\tvar all;\n\n\t\tif (link) {\n\t\t\tall = link.querySelectorAll('lyte-drop-body');\n\t\t}\n\t\telse {\n\t\t\tall = this.$node.querySelectorAll('lyte-drop-body');\n\t\t}\n\n\t\treturn all[all.length - 1];\n\t}\n\n    /**\n\t * This is going to remove the previous highlighted element and set a new highlighted element\n\t * @param {Element} node - The element to be toggled -> should not be undefined\n\t * @param {Element} body - The lyte-drop-body\n\t *\n\t */\n\n    toggleCurrent(node) {\n\t\tvar cls = 'lyteDropdownSelection',\n\t\t\tbox = this.getDropBox(),\n\t\t\tprev = box && box.querySelector('.' + cls);\n\n\t\tif (prev) {\n\t\t\tprev.classList.remove(cls);\n\t\t}\n\n\t\tnode.classList.add(cls);\n\t\tthis.getActiveElement().setAttribute('aria-activedescendant', node.getAttribute('id'));\n\t}\n\n    /**\n\t * This is going to scroll the drop-body to the element above the selected element\n\t * This function is also going to highlight the selected value\n\t * Note this doesn't work when they are making a request and trying to set the data\n\t *\n\t */\n\n    scrollSel() {\n\n\t\tvar sel = this.getData('ltPropSelected'),\n\t\t\tlink = this.childComp,\n\t\t\tbody = this.getDropBody(link),\n\t\t\ttmp, highlightedElement,\n\t\t\tall_elems = this.getAllItems(body),\n\t\t\tnode = tmp = this.getItem(all_elems, sel) /*body.querySelector( '[data-value=\"' + window._lyteUiUtils.escape( sel ) + '\"]' )*/;\n\n\t\t// Not for multiselects\n\t\tif (this.getData('multiple')) {\n\t\t\t// tmp = body.querySelector( 'lyte-drop-item:not(.lyteDropdownActive):not(.lyteSearchHidden)' );\n\t\t\ttmp = all_elems.filter(function (item) {\n\t\t\t\treturn !item.classList.contains('lyteDropdownActive') && !item.classList.contains('lyteSearchHidden');\n\t\t\t})[0];\n\n\t\t\tif (tmp && !tmp.classList.contains('lyteDropdown-disabled')) {\n\t\t\t\tthis.toggleCurrent(tmp);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif ((sel || '').length === 0) {\n\t\t\tbody.scrollTop = 0;\n\t\t}\n\n\t\twhile (node\n\t\t\t&& (node = node.previousElementSibling)\n\t\t) {\n\t\t\tif ((node.tagName === 'LYTE-DROP-ITEM'\n\t\t\t\t|| node.tagName === 'LYTE-DROP-LABEL')\n\t\t\t\t&& window._lyteDropdown.isVisible(node)\n\t\t\t) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Scroll to original node if no visible node is found\n\t\tnode = node ? node : tmp;\n\n\t\t// If we now have a node set the scrollTop\n\t\tif (node) {\n\t\t\tbody.scrollTop = this.isFirstItem( node ) ? 0 : node.offsetTop;\n\t\t}\n\t\telse {\n\t\t\tbody.scrollTop = 0;\n\t\t}\n\n\t\tif (tmp && !tmp.classList.contains('lyteDropdown-disabled')) {\n\t\t\tthis.toggleCurrent(tmp);\n\t\t}\n\t\telse {\n\t\t\thighlightedElement = body.querySelector('.lyteDropdownSelection');\n\n\t\t\tif (highlightedElement) {\n\t\t\t\thighlightedElement.classList.remove('lyteDropdownSelection');\n\t\t\t}\n\t\t}\n\t}\n\n    isFirstItem(node) {\n\t\tvar parent = node.parentElement;\n\n\t\treturn parent && parent.firstElementChild === node;\n\t}\n\n    /**\n\t * This is going to clone the object\n\t * @param {Object} obj - the object to be clone\n\t *\n\t */\n\n    clone(obj) {\n\t\tvar clone = {};\n\n\t\tfor (var key in obj) {\n\t\t\tclone[key] = obj[key];\n\t\t}\n\n\t\treturn clone;\n\t}\n\n    isFF() {\n\t\tvar ua = window.navigator.userAgent;\n\n\t\treturn !!~ua.indexOf('Firefox');\n\t}\n\n    isBodyScrollable() {\n\t\tvar link = this.childComp,\n\t\t\tbody = this.getDropBody(link);\n\n\t\treturn body.scrollHeight > body.offsetHeight;\n\t}\n\n    addProperScrollbar() {\n\t\tvar link = this.childComp,\n\t\t\tbody = this.getDropBody(link);\n\n\t\tif (!body.classList.contains('lyteDropdownFFScroll')) {\n\t\t\tbody.classList.add('lyteDropdownFFScroll');\n\t\t}\n\n\t\tif (body.classList.contains('lyteDropdownFFZeroScroll')) {\n\t\t\tbody.classList.remove('lyteDropdownFFZeroScroll');\n\t\t}\n\t}\n\n    removeScrollbar() {\n\t\tvar link = this.childComp,\n\t\t\tbody = this.getDropBody(link);\n\n\t\tif (!body.classList.contains('lyteDropdownFFZeroScroll')) {\n\t\t\tbody.classList.add('lyteDropdownFFZeroScroll');\n\t\t}\n\n\t\tif (body.classList.contains('lyteDropdownFFScroll')) {\n\t\t\tbody.classList.remove('lyteDropdownFFScroll');\n\t\t}\n\t}\n\n    getButton() {\n\t\treturn this.$node.element || this.$node.querySelector('lyte-drop-button');\n\t}\n\n    /* \n\t\tDisallow arrow key navigation(and enter) when there can be multiple focusable elements on the box\n\t\tand the current focused element is not the active element. Also I guess activeElement can be empty and then have a value during its lifetime\n\t\tWe are adding the ltPropPreventNavigation here because this function can prevent the navigation of arrow keys\n\t*/\n    shouldNavigate() {\n\t\tvar activeElement = this.getData('ltPropActiveElement'),\n\t\t\tcurrentActiveElement = document.activeElement,\n\t\t\tallowFocusableElements = this.getData('ltPropAllowFocusableElements'),\n\n\t\t\t// This overrides everything\n\t\t\tpreventNavigation = this.getData( 'ltPropPreventNavigation' );\n\n\t\tif( preventNavigation ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!allowFocusableElements || !activeElement) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn currentActiveElement.matches(activeElement);\n\t}\n\n    setVerticalCalloutPosition(width, offsets, doesBoxAndButtonLeftAlign) {\n\t\tvar link = this.childComp,\n\t\tarrow = link.querySelector( '.lyteArrow' ),\n\t\taWidth, tempMarginLeft, tempNum, tempDenom, tempPer;\n\n\t\taWidth = window.getComputedStyle(arrow, ':before').getPropertyValue('border-left-width');\n\t\taWidth = parseFloat(aWidth ? aWidth : '0px');\n\t\ttempMarginLeft = window.getComputedStyle(arrow, ':before').marginLeft;\n\t\ttempMarginLeft = Math.abs(parseFloat(tempMarginLeft ? tempMarginLeft : '0px'));\n\n\t\tif( doesBoxAndButtonLeftAlign ) {\n\t\t\ttempNum = offsets.width / 2 - aWidth + tempMarginLeft; // We removed arrow.offsetWidth because it was giving width as 0 px\n\t\t} else {\n\t\t\ttempNum = width - (offsets.width / 2) - aWidth + tempMarginLeft; // We removed arrow.offsetWidth because it was giving width as 0 px\n\t\t}\n\t\t\n\t\ttempDenom = width / 100;\n\t\ttempPer = tempNum / tempDenom;\n\n\t\tarrow.style.left = tempPer + '%';\n\t}\n\n    setHorizontalCalloutPosition(drop, offsets, doesBoxAndButtonTopAlign) {\n\t\tvar link = this.childComp,\n\t\tarrow = link.querySelector( '.lyteArrow' ),\n\t\taHeight, tempMarginTop, tempNum, tempDenom, tempPer;\n\n\t\taHeight = window.getComputedStyle(arrow, ':before').getPropertyValue('border-left-width');\n\t\taHeight = parseFloat(aHeight ? aHeight : '0px');\n\t\ttempMarginTop = window.getComputedStyle(arrow, ':before').marginTop;\n\t\ttempMarginTop = Math.abs(parseFloat(tempMarginTop ? tempMarginTop : '0px'));\n\n\t\tif( doesBoxAndButtonTopAlign ) {\n\t\t\ttempNum = ((offsets.height / 2) - aHeight + tempMarginTop) * 100;\n\t\t} \n\t\telse {\n\t\t\ttempNum = (drop.height - offsets.height / 2 - aHeight + tempMarginTop) * 100;\n\t\t}\n\n\t\ttempDenom = drop.height;\n\t\ttempPer = tempNum / tempDenom;\n\t\tarrow.style.top = tempPer + '%';\n\t}\n\n    clearPositionValues() {\n\t\tvar link = this.childComp;\n\n\t\tlink.style.left = '';\n\t\tlink.style.top = '';\n\t\tlink.style.bottom = '';\n\t\tlink.style.right = '';\n\t}\n\n    setPositionFlags(primaryPosition, secondaryPosition) {\n\t\tthis.setData( 'pos', primaryPosition );\n\t\tthis.setData( 'secondaryPosition', secondaryPosition );\n\t}\n\n    exceedsBottomBoundary(preferredPosition, offsets, drop, scopeBoundary) {\n\t\tif( preferredPosition !== 'right' && preferredPosition !== 'left' ) {\n\t\t\treturn offsets.top + offsets.height + drop.height > scopeBoundary.bottom;\n\t\t}\n\n\t\treturn offsets.top + drop.height > scopeBoundary.bottom;\n\t\t\n\t}\n\n    exceedsTopBoundary(offsets, drop, scopeBoundary) {\n\t\treturn offsets.top - drop.height < scopeBoundary.top;\n\t}\n\n    findPrimaryVerticalPosition(preferredPosition, offsets, drop, scopeBoundary) {\n\t\tif( preferredPosition === 'down' ) {\n\t\t\tif( this.exceedsBottomBoundary( preferredPosition, offsets, drop, scopeBoundary ) && !this.exceedsTopBoundary( offsets, drop, scopeBoundary ) ) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\n\t\tif( preferredPosition === 'up' ) {\n\t\t\tif( this.exceedsTopBoundary( offsets, drop, scopeBoundary ) && !this.exceedsBottomBoundary( preferredPosition, offsets, drop, scopeBoundary ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t}\n\n    findSecondaryVerticalPosition(preferredPosition, offsets, drop, scopeBoundary) {\n\t\tif ( this.exceedsBottomBoundary( preferredPosition, offsets, drop, scopeBoundary ) ) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\n    /**\n\t * Set the CSS for your dropdown\n\t * refer commit ID 583ee6ccbeaa6b3729178bf9df0139032b016d19 and previous for the previous stable setCSS function.\n\t * commit ID 583ee6ccbeaa6b3729178bf9df0139032b016d19 also gives a better understanding about the hard coded values in this function.\n\t */\n    setCss(onlyScroll, useSave) {\n\t\tvar link = this.childComp,\n\n\t\t\t// An indication that the dropdown has been opened recently and this setcss is called for the open\n\t\t\tisOpen = this.getData('call');\n\n\t\tif (!useSave) {\n\t\t\tthis.setData('savedPositions', {});\n\t\t}\n\n\t\tif (!link\n\t\t\t|| link.classList.contains('lyteDropdownHidden')\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.clearPositionValues();\n\t\t// Get properties\n\t\tvar callout = this.getData('ltPropCallout');\n\n\n\t\t// Get button\n\t\tvar body = link,\n\t\t\tcustom = this.$node.element,\n\t\t\tpar = custom ? custom : this.$node.querySelector('lyte-drop-button');\n\n\t\t// Get Geometric propotions\n\t\tvar save = this.getData('savedPositions'),\n\t\t\tdrop = this.clone(body.getBoundingClientRect()),\n\t\t\tbodybcr = this.getDropBody(body).getBoundingClientRect(),\n\t\t\tx = window.pageXOffset || document.documentElement.scrollLeft,\n\t\t\ty = window.pageYOffset || document.documentElement.scrollTop,\n\t\t\theight = body.offsetHeight,\n\t\t\twidth = body.offsetWidth,\n\t\t\tarrow = link.querySelector('.lyteArrow'),\n\t\t\tposition = this.getData('ltPropPosition'),\n\t\t\toffsets = par.getBoundingClientRect(),\n\t\t\tisFF = this.isFF(),\n\t\t\tscopeBoundary = this.getScopeBoundary();\n\n\t\tif (this.data.ltPropAnimate) {\n\t\t\tthis._hgt = this.data.ltPropAnimateBox ? drop.height : bodybcr.height;\n\t\t\t// this.getDropBody( body ).style.height = ( this._hgt ) + 'px';\n\t\t}\n\n\n\t\t// Adjusting width of the body is a one time thing. Atleast that is what we think.\n\t\t// Till the smoke clears around this issue we are going to hang on to onlyScroll\n\t\t// onlyScroll will probably be deprecated\n\t\tif (isOpen) {\n\n\t\t\t// Hack to prevent the mutation observer from getting fired\n\t\t\t// MutationObserver fired when i added a class attribute to the drop-item.\n\t\t\t// We have cases where it should fire when we add a class to the drop-item\n\t\t\tthis._preventClass = true;\n\t\t\tthis.scrollSel();\n\n\t\t\tif (!onlyScroll) {\n\n\t\t\t\t// Reset width for later usage\n\t\t\t\twidth = this.adjustWidth(body, offsets.width, width);\n\t\t\t\tdrop.width = width;\n\n\t\t\t\t// Set width of span.lyteArrow if there is no callout\n\t\t\t\tif (!callout) {\n\t\t\t\t\tarrow.style.width = offsets.width + 'px';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Adding the not check here because it was causing the mutobserver to fire infinitely when resize occured.\n\t\t// When resized the dropdown would add the lyteDropBodyCallout again and this keeps happening over and over again.\n\t\tif (callout && !body.classList.contains('lyteDropBodyCallout')) {\n\t\t\tbody.classList.add('lyteDropBodyCallout')\n\t\t}\n\n\t\tif (isFF && this.isBodyScrollable()) {\n\t\t\tthis.addProperScrollbar();\n\t\t}\n\t\telse if (isFF && !this.isBodyScrollable()) {\n\t\t\tthis.removeScrollbar();\n\t\t}\n\n\t\t// Intialize flags\n\t\tvar downPos,\n\t\t\trightPos,\n\t\t\ttopPos,\n\t\t\tleftPos,\n\t\t\trtl = window._lyteUiUtils.getRTL();\n\n\n\t\t// temp stores\n\t\tvar tempLeft,\n\t\t\taHeight,\n\t\t\taWidth;\n\n\t\tif (position === 'down') {\n\t\t\tdownPos = this.findPrimaryVerticalPosition( 'down', offsets, drop, scopeBoundary );\n\n\t\t\trightPos = 0;\n\n\t\t\t// rightPos - 1 -> rtl or no space to the right -> align left\n\t\t\t// rightPos - 2 -> ltr or space available to the right -> align right\n\t\t\t// rightPos - 0/3 -> align to the right if ltr or to the left if rtl\n\t\t\ttempLeft = offsets.left;\n\t\t\tif (tempLeft + offsets.width - width > scopeBoundary.left) {\n\t\t\t\trightPos = 1;\n\t\t\t}\n\n\t\t\tif (offsets.left + width <= scopeBoundary.right) {\n\t\t\t\trightPos += 2;\n\t\t\t}\n\n\t\t\tif (rtl) {\n\t\t\t\trightPos = !!(!(rightPos & 1 || !rightPos));\n\t\t\t}\n\t\t\telse {\n\t\t\t\trightPos = !!(rightPos & 2 || !rightPos);\n\t\t\t}\n\n\t\t\tif (useSave && !window._lyteDropdown.isEmpty(save)) {\n\t\t\t\trightPos = save.rightPos;\n\t\t\t\tdownPos = save.downPos;\n\t\t\t}\n\t\t\telse if (useSave) {\n\t\t\t\tsave.rightPos = rightPos;\n\t\t\t\tsave.downPos = downPos;\n\n\t\t\t\tthis.setData('savedPositions', save);\n\t\t\t}\n\n\t\t\tif (downPos) {\n\t\t\t\tif (callout) {\n\t\t\t\t\tthis.setCorrectClass('lyteArrowTop');\n\n\t\t\t\t\t// layout thrashing happens here\n\t\t\t\t\t// Removing layout thrashing causes a jitter\n\t\t\t\t\taHeight = window.getComputedStyle(arrow, ':before').getPropertyValue('border-left-width');\n\t\t\t\t\tbody.style.top = this.alignBoxTopToButtonBottom(par, offsets, y) + parseFloat(aHeight ? aHeight : '0px') + 'px';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbody.style.top = this.alignBoxTopToButtonBottom(par, offsets, y) + 'px';\n\t\t\t\t}\n\n\n\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tif (callout) {\n\t\t\t\t\tthis.setCorrectClass('lyteArrowBottom');\n\n\t\t\t\t\t// layout thrashing happens here\n\t\t\t\t\t// Removing layout thrashing causes a jitter\n\t\t\t\t\taHeight = window.getComputedStyle(arrow, ':before').getPropertyValue('border-left-width');\n\t\t\t\t\tbody.style.bottom = this.setTopAboveForDown(par, body, offsets, drop, y) + parseFloat(aHeight ? aHeight : '0px') + 'px';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbody.style.bottom = this.setTopAboveForDown(par, body, offsets, drop, y) + 'px';\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t\tif (rightPos) {\n\t\t\t\tif (callout) {\n\t\t\t\t\tthis.setVerticalCalloutPosition( width, offsets, true );\n\t\t\t\t}\n\n\t\t\t\tbody.style.left = this.alignBoxToButtonLeft(par, offsets, x) + 'px';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (callout) {\n\t\t\t\t\tthis.setVerticalCalloutPosition( width, offsets, false );\n\t\t\t\t}\n\n\t\t\t\tbody.style.right = this.setLeftExceedForDown(par, body, offsets, width, x) + 'px'\n\t\t\t}\n\n\t\t\tthis.setPositionFlags( downPos ? 'down' : 'up', rightPos ? 'right' : 'left' );\n\n\t\t}\n\t\telse if (position === 'right') {\n\t\t\trightPos = 0;\n\t\t\tif (offsets.left - drop.width > scopeBoundary.left) {\n\t\t\t\trightPos = 1;\n\n\t\t\t}\n\t\t\tif (offsets.left + offsets.width + drop.width < scopeBoundary.right) {\n\t\t\t\trightPos += 2;\n\t\t\t}\n\n\t\t\tif (rtl) {\n\t\t\t\trightPos = !!(!(rightPos & 1 || !rightPos));\n\t\t\t}\n\t\t\telse {\n\t\t\t\trightPos = !!(rightPos & 2 || !rightPos);\n\t\t\t}\n\n\t\t\tdownPos = this.findSecondaryVerticalPosition( 'right', offsets, drop, scopeBoundary );\n\n\t\t\tif (useSave && !window._lyteDropdown.isEmpty(save)) {\n\t\t\t\trightPos = save.rightPos;\n\t\t\t\tdownPos = save.downPos;\n\t\t\t}\n\t\t\telse if (useSave) {\n\t\t\t\tsave.rightPos = rightPos;\n\t\t\t\tsave.downPos = downPos;\n\n\t\t\t\tthis.setData('savedPositions', save);\n\t\t\t}\n\n\t\t\tif (rightPos) {\n\n\t\t\t\tif (callout) {\n\t\t\t\t\tthis.setCorrectClass('lyteArrowLeft');\n\n\t\t\t\t\t// layout thrashing happens here\n\t\t\t\t\t// Removing layout thrashing causes a jitter\n\t\t\t\t\taWidth = window.getComputedStyle(arrow, ':before').getPropertyValue('border-left-width');\n\t\t\t\t\taWidth = parseFloat(aWidth ? aWidth : '0px');\n\t\t\t\t\tbody.style.left = this.setLeftForRight(par, offsets, x) + aWidth + 'px'\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbody.style.left = this.setLeftForRight(par, offsets, x) + 'px'\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tif (callout) {\n\t\t\t\t\tthis.setCorrectClass('lyteArrowRight');\n\n\t\t\t\t\t// layout thrashing happens here\n\t\t\t\t\t// Removing layout thrashing causes a jitter\n\t\t\t\t\taWidth = window.getComputedStyle(arrow, ':before').getPropertyValue('border-left-width');\n\t\t\t\t\taWidth = parseFloat(aWidth ? aWidth : '0px');\n\t\t\t\t\tbody.style.right = this.setRightForRight(par, body, offsets, width, x) + aWidth + 'px';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbody.style.right = this.setRightForRight(par, body, offsets, width, x) + 'px';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (downPos) {\n\t\t\t\tif (callout) {\n\t\t\t\t\tthis.setHorizontalCalloutPosition( drop, offsets, true );\n\t\t\t\t}\n\n\t\t\t\tbody.style.top = this.setTopForRight(par, offsets, y) + 'px'\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (callout) {\n\t\t\t\t\tthis.setHorizontalCalloutPosition( drop, offsets, false );\n\t\t\t\t}\n\n\t\t\t\tbody.style.bottom = this.setTopForRightAbove(par, body, offsets, drop, y) + 'px'\n\t\t\t}\n\n\t\t\tthis.setPositionFlags( rightPos ? 'right' : 'left', downPos ? 'down' : 'up' );\n\n\t\t}\n\t\telse if (position === 'up') {\n\t\t\ttopPos = this.findPrimaryVerticalPosition( 'up', offsets, drop, scopeBoundary );\n\n\t\t\trightPos = 0\n\t\t\tif (offsets.left + offsets.width - width > scopeBoundary.left) {\n\t\t\t\trightPos = 1;\n\t\t\t}\n\t\t\tif (offsets.left + width <= scopeBoundary.right) {\n\t\t\t\trightPos += 2;\n\t\t\t}\n\n\t\t\tif (rtl) {\n\t\t\t\trightPos = !!(!(rightPos & 1 || !rightPos));\n\t\t\t}\n\t\t\telse {\n\t\t\t\trightPos = !!(rightPos & 2 || !rightPos);\n\t\t\t}\n\n\t\t\tif (useSave && !window._lyteDropdown.isEmpty(save)) {\n\t\t\t\trightPos = save.rightPos;\n\t\t\t\ttopPos = save.topPos;\n\t\t\t}\n\t\t\telse if (useSave) {\n\t\t\t\tsave.rightPos = rightPos;\n\t\t\t\tsave.topPos = topPos;\n\n\t\t\t\tthis.setData('savedPositions', save);\n\t\t\t}\n\n\t\t\tif (topPos) {\n\n\t\t\t\tif (callout) {\n\t\t\t\t\tthis.setCorrectClass('lyteArrowBottom');\n\n\t\t\t\t\t// layout thrashing happens here\n\t\t\t\t\t// Removing layout thrashing causes a jitter\n\t\t\t\t\taHeight = window.getComputedStyle(arrow, ':before').getPropertyValue('border-left-width');\n\t\t\t\t\taHeight = parseFloat(aHeight ? aHeight : '0px');\n\t\t\t\t\tbody.style.bottom = this.setTopAboveForDown(par, body, offsets, drop, y) + aHeight + 'px';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbody.style.bottom = this.setTopAboveForDown(par, body, offsets, drop, y) + 'px';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tif (callout) {\n\t\t\t\t\tthis.setCorrectClass('lyteArrowTop');\n\n\t\t\t\t\t// layout thrashing happens here\n\t\t\t\t\t// Removing layout thrashing causes a jitter\n\t\t\t\t\taHeight = window.getComputedStyle(arrow, ':before').getPropertyValue('border-left-width');\n\t\t\t\t\taHeight = parseFloat(aHeight ? aHeight : '0px');\n\t\t\t\t\tbody.style.top = this.alignBoxTopToButtonBottom(par, offsets, y) + aHeight + 'px';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbody.style.top = this.alignBoxTopToButtonBottom(par, offsets, y) + 'px'\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rightPos) {\n\t\t\t\tif (callout) {\n\t\t\t\t\tthis.setVerticalCalloutPosition( width, offsets, true );\n\t\t\t\t}\n\n\t\t\t\tbody.style.left = this.alignBoxToButtonLeft(par, offsets, x) + 'px';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (callout) {\n\t\t\t\t\tthis.setVerticalCalloutPosition( width, offsets, false );\n\t\t\t\t}\n\n\t\t\t\tbody.style.right = this.setLeftExceedForDown(par, body, offsets, width, x) + 'px';\n\t\t\t}\n\n\t\t\tthis.setPositionFlags( topPos ? 'up' : 'down', rightPos ? 'right' : 'left' );\n\n\t\t}\n\t\telse if (position === 'left') {\n\t\t\tleftPos = 0;\n\n\t\t\tif (offsets.left + offsets.width + width < scopeBoundary.right) {\n\t\t\t\tleftPos = 1;\n\t\t\t}\n\t\t\tif (offsets.left - width > scopeBoundary.left) {\n\t\t\t\tleftPos += 2;\n\t\t\t}\n\n\t\t\tif (rtl) {\n\t\t\t\tleftPos = !!(!(leftPos & 1 || !leftPos));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tleftPos = !!(leftPos & 2 || !leftPos);\n\t\t\t}\n\n\t\t\tdownPos = this.findSecondaryVerticalPosition( 'left', offsets, drop, scopeBoundary );\n\n\t\t\tif (useSave && !window._lyteDropdown.isEmpty(save)) {\n\t\t\t\tleftPos = save.leftPos;\n\t\t\t\tdownPos = save.downPos;\n\t\t\t}\n\t\t\telse if (useSave) {\n\t\t\t\tsave.leftPos = leftPos;\n\t\t\t\tsave.downPos = downPos;\n\n\t\t\t\tthis.setData('savedPositions', save);\n\t\t\t}\n\n\t\t\tif (leftPos) {\n\n\t\t\t\tif (callout) {\n\t\t\t\t\tthis.setCorrectClass('lyteArrowRight');\n\n\t\t\t\t\t// layout thrashing happens here\n\t\t\t\t\t// Removing layout thrashing causes a jitter\n\t\t\t\t\taWidth = window.getComputedStyle(arrow, ':before').getPropertyValue('border-left-width');\n\t\t\t\t\taWidth = parseFloat(aWidth ? aWidth : '0px');\n\t\t\t\t\tbody.style.right = this.setRightForRight(par, body, offsets, width, x) + aWidth + 'px';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbody.style.right = this.setRightForRight(par, body, offsets, width, x) + 'px';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tif (callout) {\n\t\t\t\t\tthis.setCorrectClass('lyteArrowLeft');\n\n\t\t\t\t\t// layout thrashing happens here\n\t\t\t\t\t// Removing layout thrashing causes a jitter\n\t\t\t\t\taWidth = window.getComputedStyle(arrow, ':before').getPropertyValue('border-left-width');\n\t\t\t\t\taWidth = parseFloat(aWidth ? aWidth : '0px');\n\t\t\t\t\tbody.style.left = this.setLeftForRight(par, offsets, x) + aWidth + 'px';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbody.style.left = this.setLeftForRight(par, offsets, x) + 'px';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (downPos) {\n\t\t\t\tif (callout) {\n\t\t\t\t\tthis.setHorizontalCalloutPosition( drop, offsets, true );\n\t\t\t\t}\n\n\t\t\t\tbody.style.top = this.setTopForRight(par, offsets, y) + 'px';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (callout) {\n\t\t\t\t\tthis.setHorizontalCalloutPosition( drop, offsets, false );\n\t\t\t\t}\n\n\t\t\t\tbody.style.bottom = this.setTopForRightAbove(par, body, offsets, drop, y) + 'px';\n\t\t\t}\n\n\t\t\tthis.setPositionFlags( leftPos ? 'left' : 'right', downPos ? 'down' : 'up' );\n\n\t\t}\n\n\t\tbody.__height = height;\n\t}\n\n    getScopeBoundary() {\n\t\tvar scope = this.getData('ltPropScope'),\n\t\t\telement,\n\t\t\tres = {\n\t\t\t\tleft: 0,\n\t\t\t\ttop: 0,\n\t\t\t\tright: window.innerWidth,\n\t\t\t\tbottom: window.innerHeight\n\t\t\t}, boundingRects;\n\n\t\tif (scope !== 'window') {\n\t\t\telement = $L(this.$node).closest(scope).get(0);\n\n\t\t\tif (element) {\n\t\t\t\tboundingRects = element.getBoundingClientRect();\n\n\t\t\t\treturn {\n\t\t\t\t\tleft: Math.max(0, boundingRects.left),\n\t\t\t\t\ttop: Math.max(0, boundingRects.top),\n\t\t\t\t\tright: Math.min(window.innerWidth, boundingRects.right),\n\t\t\t\t\tbottom: Math.min(window.innerHeight, boundingRects.bottom)\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n    setFreezeLayer() {\n\t\tvar node = document.getElementById('lytedropdownfreezelayer'),\n\t\t\tscrollsToPrevent = this.getData('ltPropPreventScroll');\n\n\t\tif (scrollsToPrevent === 'all') {\n\t\t\tnode.style.display = 'block';\n\t\t\tnode.classList.add('lyteDropdownZIndex');\n\t\t}\n\n\t\tdocument.body.classList.add('lyteBodyWrapper');\n\t}\n\n    isInView(element) {\n\t\tvar body = this.getDropBody(this.childComp),\n\t\t\tcontainerScrollTop = body.scrollTop,\n\t\t\tcontainerHeight = body.offsetHeight,\n\t\t\telementTop = element.offsetTop,\n\t\t\telementHeight = element.offsetHeight;\n\n\t\treturn elementTop >= containerScrollTop && elementTop + elementHeight <= containerScrollTop + containerHeight;\n\t}\n\n    moveIntoView(element) {\n\t\tvar body = this.getDropBody(this.childComp),\n\t\t\tcontainerScrollTop = body.scrollTop,\n\t\t\telementTop = element.offsetTop;\n\n\t\tif (elementTop <= containerScrollTop) {\n\t\t\tthis.moveDown(element);\n\t\t}\n\t\telse {\n\t\t\tthis.moveUp(element);\n\t\t}\n\t}\n\n    moveDown(element) {\n\t\tvar body = this.getDropBody(this.childComp);\n\n\t\tbody.scrollTop = this.isFirstItem( element ) ? 0 : element.offsetTop;\n\t}\n\n    moveUp(element) {\n\t\tvar body = this.getDropBody(this.childComp);\n\n\t\tbody.scrollTop = element.offsetTop + element.offsetHeight - body.offsetHeight\n\t}\n\n    scrollIntoView(element, move) {\n\t\tvar parent = this.getDropBody(this.childComp),\n\t\t\toffsetTop = element.offsetTop,\n\t\t\tscrollT = parent.scrollTop,\n\t\t\theight = parent.getBoundingClientRect().height,\n\t\t\telementHeight = element.getBoundingClientRect().height;\n\n\t\tif (!parent.contains(element)) {\n\t\t\t// There can be elements inside lyte-drop-footer. So we only scroll to elements inside the body\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.isInView(element)) {\n\t\t\tthis.moveIntoView(element);\n\t\t}\n\t}\n\n    open() {\n\t\tvar that = this, link,\n\t\t\ttype = this.getData('ltPropType'),\n\t\t\thead = this.getData('drophead'),\n\t\t\tmul = this.getData('multiple'),\n\t\t\tfreeze = this.getData('ltPropFreeze'),\n\t\t\thover = this.getData('ltPropHover');\n\n\t\tlink = this.childComp = this.$node.querySelector('lyte-drop-box');\n\n\t\tthis.closeError(link, head);\n\t\tthis.hideNodes();\n\n\t\tif (\n\t\t\ttype === 'multisearch'\n\t\t\t&& head !== 'yield'\n\t\t) {\n\t\t\t$L(this.$node.querySelector('.lyteDropdownTextField')).search({\n\t\t\t\tscope: link,\n\t\t\t\ttrim: this.getData( 'ltPropTrimSearchText' ),\n\t\t\t\tsearchDelay: undefined,\n\t\t\t\thiddenSelector: \".lyteDropdownActive\",\n\t\t\t\tsearch: 'lyte-drop-item',\n\t\t\t\trelated: 'lyte-drop-group',\n\t\t\t\tonSearch: function (res, event, value) {\n\t\t\t\t\tvar i = 0, lk = that.childComp,\n\t\t\t\t\t\tbody = that.getDropBody(lk),\n\t\t\t\t\t\tdiv = body.querySelector('.lyteDropdownNoResult'),\n\t\t\t\t\t\ttext = that.getData('ltPropNoResult'), ret;\n\n\t\t\t\t\tif (that.getMethods('onSearch')) {\n\t\t\t\t\t\tret = that.executeMethod('onSearch', res, event, value, that);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ret === false) {\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\n\t\t\t\t\tbody.scrollTop = 0;\n\n\t\t\t\t\tfor (; i < res.length; i++) {\n\t\t\t\t\t\tif (!res[i].classList.contains('lyteDropdownActive')) {\n\t\t\t\t\t\t\tif (div) {\n\t\t\t\t\t\t\t\tdiv.style.display = 'none';\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthat.toggleCurrent(res[i], body);\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (div.style.display !== 'none') {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (text) {\n\t\t\t\t\t\tdiv.style.display = 'block';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlink.origindd = this.$node;\n\t\twindow._lyteUiUtils.appendChild(document.body, link);\n\t\tlink.classList.remove('lyteDropdownHidden');\n\n\t\tthis.preventParentScroll();\n\n\t\tif (freeze && !mul && !hover) {\n\t\t\tthis.setFreezeLayer()\n\t\t}\n\n\t}\n\n    preventParentScroll() {\n\n\t\tif (!this.getData('ltPropPreventParentScroll')) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar parents = $L(this.$node).parents(), scrollableParents, lyteScrollBarParents, that = this;\n\n\t\tscrollableParents = parents.filter(this.isScrollable);\n\t\tlyteScrollBarParents = parents.filter(this.isLyteScrollBar);\n\n\t\tlyteScrollBarParents = lyteScrollBarParents.map(function (index, item) {\n\t\t\treturn item.parentNode;\n\t\t});\n\n\t\tscrollableParents.each(function (index, item) {\n\t\t\t$L(item).data('lyte-scrollTop', item.scrollTop);\n\t\t\t$L(item).data('lyte-scrollLeft', item.scrollLeft);\n\t\t});\n\n\t\tthis.scrollableParents = scrollableParents;\n\t\tthis.lyteScrollBarParents = lyteScrollBarParents;\n\n\t\tthis.scrollableParents.on('scroll', this.resetScroll);\n\t\tthis.scrollableParents.on( 'wheel', this.preventDefaultBehaviour );\n\t\tthis.scrollableParents.on( 'touchmove', this.preventDefaultBehaviour );\n\n\n\t\tthis.lyteScrollBarParents.each(function (index, item) {\n\t\t\tif (item) {\n\t\t\t\titem.addEventListener('touchmove', that.disableLyteScrollBar, true);\n\t\t\t\titem.addEventListener('wheel', that.disableLyteScrollBar, true);\n\t\t\t}\n\t\t});\n\n\t\tdocument.body.classList.add('lyteBodyWrapper');\n\t}\n\n    disableLyteScrollBar(event) {\n\t\tevent.stopPropagation();\n\t}\n\n    isScrollable(index, item) {\n\t\tvar overflowY = $L(item).css('overflow-y'),\n\t\t\toverflowX = $L(item).css('overflow-x');\n\n\t\tif ((item.clientWidth < item.scrollWidth && (overflowX === 'auto' || overflowX === 'scroll')) || (item.clientHeight < item.scrollHeight && (overflowY === 'auto' || overflowY === 'scroll'))) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n    isLyteScrollBar(index, item) {\n\t\treturn item.classList.contains('lyteScrollBar');\n\t}\n\n    resetScroll() {\n\t\tvar scrollTop = $L(this).data('lyte-scrollTop'),\n\t\t\tscrollLeft = $L(this).data('lyte-scrollLeft');\n\n\t\tthis.scrollTop = scrollTop;\n\t\tthis.scrollLeft = scrollLeft;\n\t}\n\n    preventDefaultBehaviour(event) {\n\t\tevent.preventDefault();\n\t}\n\n    hideNodes() {\n\t\tvar link = this.childComp, selected, i = 0, item,\n\t\t\tmul = this.getData('multiple'),\n\t\t\ttype = this.getData('ltPropType'),\n\t\t\thead = this.getData('drophead'),\n\t\t\tsel = this.getData('ltPropSelected');\n\n\t\t// Hide the filtered items in the dropdown list\n\t\tif (mul && sel && sel.length > 2) {\n\t\t\tif (!link) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tselected = JSON.parse(this.getData('ltPropSelected') || '[]');\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\tconsole.error('Unable to parse ltPropSelected', err);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hide new selected values\n\n\t\t\tvar all_elems = this.getAllItems(link);\n\n\t\t\tfor (; i < selected.length; i++) {\n\t\t\t\titem = this.getItem(all_elems, selected[i]);\n\t\t\t\t// item = link.querySelector('[data-value=\"'+ window._lyteUiUtils.escape( selected[ i ] ) +'\"]');\n\t\t\t\tif (item) {\n\t\t\t\t\titem.classList.add('lyteDropdownActive');\n\t\t\t\t\tthis.hideGroup(item);\n\t\t\t\t\tthis.setData('preventSel', true);\n\t\t\t\t\titem.setAttribute('selected', true);\n\t\t\t\t\tthis.setData('preventSel', false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.showError(link, type, head);\n\t}\n\n    showNodes(change) {\n\t\tvar i = 0, j, olen, elm, res,\n\t\t\tlink = this.childComp,\n\t\t\tbody = this.getDropBody(link),\n\t\t\tmul = this.getData('multiple'),\n\t\t\ttype = this.getData('ltPropType'),\n\t\t\thead = this.getData('drophead'),\n\t\t\tall = this.getData('ltPropSelectedList') || [],\n\t\t\tsysValue = this.getData('sysValue'),\n\t\t\tnv = change.newValue,\n\t\t\tov = change.oldValue;\n\n\t\tif (!mul) {\n\t\t\treturn;\n\t\t}\n\n\t\t// if link doesn't make sense here: TODO\n\t\tif (link) {\n\t\t\tres = body.querySelector('.lyteDropdownNoResult');\n\t\t}\n\n\t\ttry {\n\t\t\t// Convert to string for obvious reasons\n\t\t\tnv = JSON.parse(nv || '[]').map(function (val) {\n\t\t\t\treturn '' + val;\n\t\t\t});\n\n\t\t\t// Convert to string for obvious reasons\n\t\t\tov = JSON.parse(ov || '[]').map(function (val) {\n\t\t\t\treturn '' + val;\n\t\t\t});\n\t\t}\n\t\tcatch (err) {\n\t\t\tconsole.error('Unable to parse ltPropSelected', err);\n\t\t\treturn;\n\t\t}\n\n\t\tolen = ov.length;\n\n\t\tvar all_elems = this.getAllItems(link);\n\n\t\tfor (; i < olen; i++) {\n\t\t\tif (nv.indexOf(ov[i]) === -1) {\n\t\t\t\tif (link) {\n\t\t\t\t\t// elm = link.querySelector( '[data-value=\"' + window._lyteUiUtils.escape( ov[ i ] ) + '\"]' );\n\t\t\t\t\telm = this.getItem(all_elems, ov[i]);\n\n\t\t\t\t\t// show items in dropbox\n\t\t\t\t\tif (elm) {\n\t\t\t\t\t\telm.classList.remove('lyteDropdownActive');\n\t\t\t\t\t\tthis.showGroup(elm);\n\t\t\t\t\t\tthis.setData('preventSel', true);\n\t\t\t\t\t\telm.removeAttribute('selected');\n\t\t\t\t\t\tthis.setData('preventSel', false);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\t// remove items from head\n\t\t\t\tthis.setData('preventSelListObs', true);\n\n\t\t\t\tfor (j = 0; j < all.length; j++) {\n\t\t\t\t\tif (('' + all[j][sysValue]) === ov[i]) {\n\t\t\t\t\t\tthis.$addon.arrayUtils(all, 'removeAt', j, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.setData('preventSelListObs', false);\n\n\t\t\t\t// May need to add a check to see if the dropdown is open\n\t\t\t\tif (res\n\t\t\t\t\t&& ((type === 'multisearch' && head !== 'yield')\n\t\t\t\t\t\t|| type === 'multiple')\n\t\t\t\t) {\n\t\t\t\t\tres.style.display = 'none';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n    toggleDropdownClass() {\n\t\tvar node = this.$node,\n\t\t\tsel = this.getData('ltPropSelected') || '[]',\n\t\t\tisMultiple = this.getData('multiple');\n\n\t\tif (!isMultiple) {\n\t\t\treturn;\n\t\t}\n\n\t\tsel = JSON.parse(sel);\n\n\t\tif (sel.length > 0) {\n\t\t\tnode.classList.remove('lyteDropNoOptSelected')\n\t\t}\n\t\telse {\n\t\t\tnode.classList.add('lyteDropNoOptSelected');\n\t\t}\n\t}\n\n    first() {\n\t\tvar type = this.getData('ltPropType');\n\n\t\tthis.setData('ltPropShow', true);\n\t\tthis.setData('ltPropIsOpen', true);\n\t\tthis.open();\n\n\t\tif (type === 'multisearch') {\n\t\t\tthis.focusInput();\n\t\t}\n\n\t\tthis.setBoxStyles();\n\t}\n\n    subsequent(link, freeze, mul, hover) {\n\t\tvar type = this.getData('ltPropType'),\n\t\t\thead = this.getData('drophead');\n\n\t\tthis.setData('ltPropIsOpen', true);\n\t\tlink.classList.remove('lyteDropdownHidden');\n\n\t\tthis.preventParentScroll();\n\n\t\tif (freeze && !mul && !hover) {\n\t\t\tthis.setFreezeLayer()\n\t\t}\n\n\t\tif (type === 'multisearch') {\n\t\t\tthis.focusInput();\n\t\t}\n\n\t\tthis.closeError(link, head);\n\t\tthis.showError(link, type, head);\n\n\t\tthis.setBoxStyles();\n\t}\n\n    setBoxStyles() {\n\t\tvar manual = this.getData('ltPropSetPos'),\n\t\t\tdropbox = this.getDropBox();\n\n\t\tif (manual\n\t\t\t|| !dropbox || dropbox.classList.contains('lyteDropdownHidden')\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.prerequisites();\n\t}\n\n    /**\n\t * This invokes the beforeShow method but with a twist\n\t * You can now return promises which open the dropdown only when they are resolved\n\t * @param {Event} event - The event\n\t * @param {boolean} fromTg - Whether it is from the toggle function\n\t *\n\t *\n\t */\n\n    beforeShow(event, fromTg, first) {\n\t\tvar res, that = this, link = this.getDropBox(),\n\t\t\tfreeze = this.getData('ltPropFreeze'),\n\t\t\tmul = this.getData('multiple'),\n\t\t\thover = this.getData('ltPropHover');\n\n\t\tres = this.executeMethod('onBeforeShow', event, this);\n\n\t\tif (res && res.then) {\n\n\t\t\twindow._lyteDropdown.lastDropdownWithAPromise = this.$node;\n\t\t\tthis.setData('blockShowHide', true);\n\n\t\t\tres\n\t\t\t\t.then(function (arg) {\n\t\t\t\t\tthat.setData('blockShowHide', false);\n\n\t\t\t\t\tif (that.isNotLastDropdownWithPromise()) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthat.setData('call', fromTg ? true : event);\n\n\t\t\t\t\tif (first) {\n\t\t\t\t\t\tthat.first();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthat.subsequent(link, freeze, mul, hover);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.catch(function (err) {\n\t\t\t\t\tthat.setData('blockShowHide', false);\n\t\t\t\t\tlink.removeAttribute('lyte-hidden');\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t});\n\t\t}\n\t\telse if (res !== false) {\n\t\t\tthat.setData('call', fromTg ? true : event);\n\t\t\tif (first) {\n\t\t\t\tthat.first();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthat.subsequent(link, freeze, mul, hover);\n\t\t\t}\n\t\t}\n\t\telse if (res === false) {\n\t\t\tlink.removeAttribute('lyte-hidden');\n\t\t}\n\t}\n\n    // Don't change this fn name because thangagiri/anantha(in lyte-tags) is using it to get the dropbox in one of his components.\n    getDropBox() {\n\t\tvar box = this.childComp;\n\n\t\tif (!box) {\n\t\t\tbox = this.$node.querySelector('lyte-drop-box');\n\t\t}\n\n\t\treturn box;\n\t}\n\n    isNotLastDropdownWithPromise() {\n\t\tvar lastDropdown = window._lyteDropdown.lastDropdownWithAPromise;\n\n\t\treturn this.$node !== lastDropdown;\n\t}\n\n    /**\n\t * Show the error div when one of the elements get removed\n\t * @param link - the drop box\n\t * @param head -  the dropdown's head\n\t *\n\t */\n\n    closeError(link, head) {\n\t\tvar body = this.getDropBody(link),\n\t\t\tresult = body.querySelector('.lyteDropdownNoResult'),\n\t\t\ttype = this.getData('ltPropType');\n\n\t\tif (\n\t\t\tresult\n\t\t\t&& ((head !== 'yield' && type === 'multisearch')\n\t\t\t\t|| (type === 'multiple'))\n\n\t\t) {\n\t\t\tresult.style.display = 'none';\n\t\t}\n\t}\n\n    /**\n\t * Check if the number of selected items has crossed the limit\n\t * @param {Number} extra - The extra items to be added to the selected list\n\t * @returns {Boolean} - true if it does\n\t *\n\t */\n\n    checkLimit(extra) {\n\t\tvar type = this.getData('ltPropType'),\n\t\t\tmax = this.getData('ltPropMaxCount'),\n\t\t\tsel = this.getData('ltPropSelected'),\n\t\t\tarr, count;\n\n\t\tif (type !== 'multiple'\n\t\t\t&& type !== 'multisearch'\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tarr = JSON.parse(sel || '[]'),\n\t\t\tcount = arr.length + extra;\n\n\t\tif (max > 0 && count > max) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n    /**\n\t * Find the data-values of nodes that are going to be removed\n\t * @param {sel} - The current selected\n\t * @param {Array} nodes - An array of HTMLElements that are going to be removed\n\t * @return {Object} - Object containing two keys => removed representing the nodes that are getting removed and selected which represents the current selected\n\t *\n\t */\n\n    findMarked(sel, nodes) {\n\t\tvar i, ind, removed = [],\n\t\t\tlen = nodes.length;\n\n\t\ttry {\n\t\t\tsel = JSON.parse(sel || '[]').map(function (val) {\n\t\t\t\treturn '' + val;\n\t\t\t});\n\t\t}\n\t\tcatch (er) {\n\t\t\tconsole.error('Unable to parse ltPropSelected', er);\n\t\t}\n\n\t\t// Unfortunately sortable can change the order of selected values\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tind = sel.indexOf(nodes[i].getAttribute('data-value'));\n\t\t\tremoved = removed.concat(sel.splice(ind, 1));\n\t\t}\n\n\t\treturn {\n\t\t\tremoved: removed,\n\t\t\tselected: sel\n\t\t};\n\t}\n\n    /**\n\t * Remove the marked values\n\t * @param sel - The current selected\n\t * @param nodes - nodes that are going to be removed\n\t * @param head - whether the content was yielded or not\n\t *\n\t */\n\n    removeMarked(sel, nodes, head, link) {\n\t\tvar len = nodes.length,\n\t\t\ti, j, all = this.getData('ltPropSelectedList') || [],\n\t\t\tsysValue = this.getData('sysValue'),\n\t\t\tbody, node;\n\n\t\tthis.setData('preventSelListObs', true);\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tfor (j = 0; j < all.length; j++) {\n\t\t\t\tif (('' + all[j][sysValue]) == nodes[i].getAttribute('data-value')) {\n\t\t\t\t\tthis.$addon.arrayUtils(all, 'removeAt', j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.setData('preventSelListObs', false);\n\n\t\tbody = this.getDropBody(link);\n\n\t\tvar all_elems = this.getAllItems(body);\n\n\t\tfor (i = 0; i < nodes.length; i++) {\n\t\t\t// node = body.querySelector( '[data-value=\"'+ window._lyteUiUtils.escape( nodes[ i ].getAttribute( 'data-value' ) ) +'\"]' );\n\t\t\tnode = this.getItem(all_elems, nodes[i].getAttribute('data-value'));\n\t\t\tif (node) {\n\t\t\t\tnode.classList.remove('lyteDropdownActive');\n\t\t\t\tnode.classList.remove('lyteSearchHidden');\n\t\t\t\tthis.showGroup(node);\n\t\t\t\tnode.removeAttribute('selected');\n\t\t\t}\n\t\t}\n\n\t\tthis.fixSearchResults();\n\n\t\tthis.setData('prev', true);\n\t\tthis.setData('ltPropSelected', JSON.stringify(sel));\n\t\tthis.setData('prev', false);\n\n\t}\n\n    fixSearchResults() {\n\t\tvar input = this.$node.querySelector('lyte-search') || this.$node.querySelector('input');\n\n\t\tif (input && input.setValue) {\n\t\t\tinput.setValue(input.value || '');\n\t\t}\n\t}\n\n    removeAll(event) {\n\t\tvar drop = this.$node,\n\t\t\tlink = this.childComp,\n\t\t\thead = this.getData('drophead'),\n\t\t\tbutton = drop.querySelector('lyte-drop-button'),\n\t\t\tnodes = button.querySelectorAll('.lyteDropMark'),\n\t\t\toldSelected = this.getData('ltPropSelected'),\n\t\t\tsel = this.getData('ltPropSelected'),\n\t\t\tproper, changeObj, ret;\n\n\t\tif (this.getData('ltPropReadOnly')) {\n\t\t\treturn;\n\t\t}\n\n\t\tchangeObj = this.findMarked(sel, nodes);\n\n\t\tproper = this.getData('isKeyDown') ? 'keydown' : 'click';\n\n\t\t// Intentionally sending false because we are already passing in an array\n\t\tret = this.beforeRemove(event, changeObj.removed, proper, nodes);\n\n\t\tif (ret) {\n\t\t\t// Don't know why exactly this is here\n\t\t\t// event.stopPropagation();\n\t\t\treturn;\n\t\t}\n\n\t\tthis.removeMarked(changeObj.selected, nodes, head, link);\n\n\t\tthis.closeError(link, head);\n\n\t\tif (this.getMethods('onRemove')) {\n\t\t\tthis.executeMethod('onRemove', event, changeObj.removed, this.getData('ltPropSelected'), this, proper, nodes);\n\t\t}\n\n\t\tthis.fixBoxPosition();\n\n\t\tthis.fireOnChange(oldSelected, event, nodes);\n\n\t\t// Don't know why exactly this is here\n\t\t// event.stopPropagation();\n\t}\n\n    /**\n\t * Returns true when current clicked node and previous selected node( only 1 ) are same or one of the previous selected nodes is behind. Else returns false\n\t *\n\t * @param cur - currently selected node\n\t */\n\n    relativePosition(cur, prev) {\n\t\tvar iterator = cur;\n\n\t\t// When the current selected element and the previous selected element is the same\n\t\tif (prev.length === 1 && prev[0] === cur) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Loop through previous elements to check if it is present\n\t\twhile ((iterator = iterator.previousElementSibling)) {\n\t\t\tif (iterator.getAttribute('lyte-last')) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n    shade(node) {\n\t\tvar front, iterator,\n\t\t\t// There can be dropdowns within dropdown - this guarantees the first button is selected\n\t\t\tpresent = this.$node\n\t\t\t\t.querySelector('lyte-drop-button')\n\t\t\t\t.querySelectorAll('.lyteDropMark');\n\n\t\t// Don't process when a there are more than 1 selected items and the user clicks on one of the selected items\n\t\tif (present.length > 1 && node.classList.contains('lyteDropMark')) {\n\t\t\treturn;\n\t\t}\n\n\t\titerator = (present.length === 0 || this.relativePosition(node, present)) ? 'previousElementSibling' :\n\t\t\t'nextElementSibling';\n\n\t\tdo {\n\t\t\tnode.classList.add('lyteDropMark');\n\t\t} while ((node = node[iterator])\n\t\t\t&& !node.getAttribute('lyte-last'));\n\t}\n\n    fireCheckKey() {\n\t\tvar node = this.$node;\n\n\t\tnode.component.checkKey(window.event);\n\t}\n\n    fireOnChange(oldValue, event, item) {\n\t\tvar newValue = this.getData('ltPropSelected');\n\n\t\tif (this.hasValueChanged(oldValue) && this.getMethods('onChange')) {\n\t\t\tthis.executeMethod('onChange', event, newValue, this, item);\n\t\t}\n\t}\n\n    hasValueChanged(oldValue) {\n\t\tvar newValue = this.getData('ltPropSelected'),\n\t\t\tisMultiSelects = this.getData('multiple');\n\n\t\tif (isMultiSelects) {\n\t\t\toldValue = this.stringifyALS(oldValue);\n\t\t\tnewValue = this.stringifyALS(newValue);\n\n\t\t\t// differently ordered selected values are considered different.\n\t\t\treturn oldValue !== newValue;\n\t\t}\n\t\telse {\n\t\t\treturn oldValue !== newValue;\n\t\t}\n\t}\n\n    stringifyALS(arrayLikeString) {\n\t\tarrayLikeString = arrayLikeString || '[]';\n\n\t\tarrayLikeString = JSON.parse(arrayLikeString).map(function (item) {\n\t\t\treturn '' + item;\n\t\t});\n\n\t\treturn JSON.stringify(arrayLikeString);\n\t}\n\n    mark(node, shift, single) {\n\n\n\n\t\t// When shift is pressed\n\t\tif (shift) {\n\t\t\twindow._lyteDropdown.unmark(this);\n\t\t\tthis.shade(node);\n\t\t}\n\t\t// When command or control is pressed\n\t\telse if (single) {\n\t\t\twindow._lyteDropdown.unmark(this);\n\t\t\tnode.classList.add('lyteDropMark');\n\t\t}\n\t\t// When none of the modifier keys are pressed\n\t\telse {\n\t\t\twindow._lyteDropdown.unmark();\n\t\t\tnode.classList.add('lyteDropMark');\n\t\t}\n\n\t\tthis.setLast(node);\n\t}\n\n    beforeSelect(event, item) {\n\t\tvar selected = this.getData('ltPropSelected'), ret = true,\n\t\t\tvalue = item.getAttribute('data-value');\n\n\t\tif (this.getMethods('beforeSelect')) {\n\t\t\tret = this.executeMethod('beforeSelect', event, selected, this, item, value);\n\t\t\tret = ret === false ? false : true;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n    /**\n\t * This function is going to focus the input in the dropdown when\n\t * an item is selected from the multiselect list\n\t * an item is removed from the selected list\n\t *\n\t */\n\n    focusInput() {\n\t\tvar inp;\n\n\t\t// People have search inside the drop-box in multisearch\n\t\tif (!window._lyteUiUtils.isMobile) {\n\t\t\t$L.fastdom.measure(function () {\n\n\t\t\t\tif (!this.$node) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar inp = this.$node.querySelector('input');\n\n\t\t\t\tif (inp) {\n\t\t\t\t\tinp.focus();\n\t\t\t\t}\n\t\t\t}, this);\n\t\t}\n\t\telse {\n\t\t\tinp = this.$node.querySelector('input');\n\n\t\t\tif (inp) {\n\t\t\t\tinp.focus();\n\t\t\t}\n\t\t}\n\t}\n\n    /**\n\t * This is going to show the no result div\n\t * @param {Element} link - The drop-box element\n\t * @param {String} type - The dropdown type\n\t * @param {String} head - Whether the head is an yield or not\n\t *\n\t */\n\n    showError(link, type, head) {\n\t\tvar body = this.getDropBody(link),\n\t\t\tnodes = body.querySelectorAll('lyte-drop-item:not(.lyteDropdownActive):not(.lyteSearchHidden)'),\n\t\t\tres, text = this.getData('ltPropNoResult');\n\n\t\tif (\n\t\t\ttext\n\t\t\t&& nodes.length === 0\n\t\t\t&& (res = body.querySelector('.lyteDropdownNoResult'))\n\t\t\t&& ((type === 'multisearch' && head !== 'yield') || (type === 'multiple'))\n\t\t) {\n\t\t\tres.style.display = 'block';\n\t\t}\n\t}\n\n    /**\n\t * This is going to decide whether to remove or to not remove the current item from the multiselect\n\t * @param {Event} event - The event object\n\t * @param {String/Array} src - An array or the single data-value getting removed\n\t * @param {String} proper - The event which triggered the remove function\n\t * @param {Element/Array} node - An array or the single item getting removed\n\t * @returns {Boolean} - true to prevent it from getting removed\n\t *\n\t */\n\n    beforeRemove(event, src, proper, node) {\n\t\tvar ret;\n\n\t\tif (this.getMethods('onBeforeRemove')) {\n\t\t\tret = this.executeMethod('onBeforeRemove', event, src, this.getData('ltPropSelected'), this, proper, node);\n\n\t\t\tret = ret != false ? false : true;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n    /**\n\t * This invokes a method which is going to decide whether to add the item into the multiselect or not\n\t * @param {Event} event - The event object\n\t * @param {Element} elm - The element that was selected\n\t * @param {String} src - Its data-value\n\t * @returns {Boolean/Object} - returning prevents the element from being selected\n\t *\n\t */\n\n    beforeAdd(event, elm, src) {\n\t\tvar preventAddition;\n\n\t\tif (this.getMethods('onBeforeAdd')) {\n\t\t\tpreventAddition = this.executeMethod('onBeforeAdd', event, src, this.getData('ltPropSelected'), this, elm);\n\t\t}\n\n\t\tif (this.isPromise(preventAddition)) {\n\t\t\treturn preventAddition;\n\t\t}\n\n\t\tpreventAddition = preventAddition != false ? false : true;\n\n\t\treturn preventAddition;\n\t}\n\n    /**\n\t * This is going to invoke the beforeHide callback and tell us whether the dropbody should be hidden or not\n\t * @param {Event} event - The invoked event object\n\t *\n\t *\n\t */\n\n    beforeHide(link, event, freeze) {\n\t\tvar res = false;\n\n\t\tif (this.getMethods('onBeforeHide')) {\n\t\t\tres = this.executeMethod('onBeforeHide', event, this);\n\t\t\tif (res && res.then) {\n\t\t\t\tres\n\t\t\t\t\t.then(function () {\n\t\t\t\t\t\tthis.closeDrop(link, event, freeze);\n\t\t\t\t\t}.bind(this, link, event, freeze))\n\t\t\t\t\t.catch(function (err) {\n\t\t\t\t\t\tconsole.error(err);\n\t\t\t\t\t});\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tres = res != false ? false : true;\n\t\t}\n\n\t\treturn res;\n\t}\n\n    // Hidden Method\n    beforeScrollClose(event) {\n\t\tif (this.getMethods('onBeforeScrollClose')) {\n\t\t\tthis.executeMethod('onBeforeScrollClose', event);\n\t\t}\n\t}\n\n    // Hidden Method\n    beforeScrollOpen(event) {\n\t\tif (this.getMethods('onBeforeScrollOpen')) {\n\t\t\tthis.executeMethod('onBeforeScrollOpen', event);\n\t\t}\n\t}\n\n    /**\n\t * This is going to set the highlight element of the dropdown\n\t * @param {NodeList} elems - All the lyte-drop-items to be traversed\n\t * @param {Element} node - Current selected drop-item\n\t *\n\t */\n\n    setHighlight(elems, node) {\n\t\tvar i = 0, j, k;\n\n\t\tfor (; i < elems.length; i++) {\n\t\t\tif (elems[i].classList.contains('lyteDropdownSelection')) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (elems[i] && elems[i] === node) {\n\n\t\t\tk = j = i;\n\t\t\ti = window._lyteDropdown.find(elems, i + 1, true);\n\n\n\n\t\t\tif (i != elems.length) {\n\t\t\t\telems[i].classList.add('lyteDropdownSelection');\n\t\t\t\tthis.getActiveElement().setAttribute('aria-activedescendant', elems[i].getAttribute('id'));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tj = window._lyteDropdown.find(elems, j - 1, false);\n\n\t\t\t\tif (j != -1) {\n\t\t\t\t\telems[j].classList.add('lyteDropdownSelection');\n\t\t\t\t\tthis.getActiveElement().setAttribute('aria-activedescendant', elems[j].getAttribute('id'));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telems[k].classList.remove('lyteDropdownSelection');\n\t\t}\n\n\t}\n\n    /**\n\t * Sets the current node as the last selected node\n\t * so that subsequent selections can proceed from this node ( Also removes the previous last)\n\t *\n\t * @param node - the node which is going to be the last node that is getting set\n\t */\n\n    setLast(node) {\n\t\tvar prev = document.querySelector('[lyte-last=\"true\"]');\n\n\t\tif (prev) {\n\t\t\tprev.removeAttribute('lyte-last');\n\t\t}\n\n\t\tnode.setAttribute('lyte-last', true);\n\t}\n\n    /**\n\t * This is going to invoke the onOptionSelected callback\n\t * @param {Event} event - The event object\n\t * @param {string} sel - The current selected value\n\t * @param {Element} elm - The lyte-drop-item that was selected\n\t *\n\t */\n\n    optCall(event, sel, elm) {\n\t\tif (this.getMethods('onOptionSelected')) {\n\t\t\tthis.executeMethod('onOptionSelected', event, sel, this, elm);\n\t\t}\n\t}\n\n    /**\n\t * Function to set the first value as lt-prop-selected\n\t *\n\t */\n\n    setInitialSelected(options) {\n\t\tthis.setSelectedFromOptions( options );\n\t}\n\n    setSelectedList() {\n\t\tvar sel = this.getData('ltPropSelected'),\n\t\t\tselected, selectedList;\n\n\t\tif (!sel) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tselected = JSON.parse(sel || '[]').map(function (val) {\n\t\t\t\treturn '' + val;\n\t\t\t});\n\t\t}\n\t\tcatch (err) {\n\t\t\tconsole.error('Could not parse ltPropSelected', err);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.buildList(selected);\n\t}\n\n    buildList(selected) {\n\t\tthis.setData('preventSelListObs', true);\n\n\t\tfor (var i = 0; i < selected.length; i++) {\n\t\t\tif (this.isPresentInList(selected[i])) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (this.isOptionsGiven()) {\n\t\t\t\tthis.buildWithOptions(selected[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.buildManually(selected[i]);\n\t\t\t}\n\t\t}\n\n\t\tthis.setData('preventSelListObs', false);\n\t}\n\n    isPresentInList(sel) {\n\t\tvar list = this.getData('ltPropSelectedList') || [],\n\t\t\tsysValue = this.getData('sysValue');\n\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tif (('' + list[i][sysValue]) === sel) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n    isOptionsGiven() {\n\t\tvar userValue = this.getData('ltPropUserValue'),\n\t\t\tsysValue = this.getData('ltPropSystemValue')\n\n\t\treturn userValue || sysValue;\n\t}\n\n    buildWithOptions(selected) {\n\t\tvar options = this.getData('ltPropOptions') || [],\n\t\t\tsysValue = this.getData('sysValue'), selectedObj, i = 0;\n\n\t\twhile (i < options.length && !selectedObj) {\n\t\t\tif (this.isOptGroup(options[i])) {\n\t\t\t\tselectedObj = this.getSelectedFromGroup(options[i], selected);\n\t\t\t}\n\t\t\telse if (('' + options[i][sysValue]) === selected) {\n\t\t\t\t// TODO: Check if same object needs to be pushed or a cloned object needs to be pushed.\n\t\t\t\tselectedObj = options[i];\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\n\t\tif (selectedObj) {\n\t\t\tthis.$addon.arrayUtils(this.getData('ltPropSelectedList'), 'push', selectedObj);\n\t\t}\n\t}\n\n\tisOptGroup(option) {\n\t\tvar keys = Object.keys(option),\n\t\t\tlength = keys.length;\n\n\t\treturn keys.length === 1 && Array.isArray(option[keys[0]]);\n\t}\n\n    getSelectedFromGroup(group, selected) {\n\t\tvar key = Object.keys(group)[0],\n\t\t\tsysValue = this.getData('sysValue');\n\n\t\tgroup = group[key] || [];\n\n\t\tfor (var i = 0; i < group.length; i++) {\n\t\t\tif (('' + group[i][sysValue]) === selected) {\n\t\t\t\treturn group[i];\n\t\t\t}\n\t\t}\n\t}\n\n    buildManually(selected) {\n\t\tvar link = this.childComp,\n\t\t\tparent = link ? link : this.$node.querySelector('lyte-drop-box'),\n\t\t\telement = this.getItem(this.getAllItems(parent), selected),\n\t\t\t// element = parent.querySelector( '[data-value=\"' + window._lyteUiUtils.escape( selected ) + '\"]' ),\n\t\t\tobj = {\n\t\t\t\tvalue: selected,\n\t\t\t\tdisplay: (element || {}).textContent\n\t\t\t};\n\n\t\tif (!obj.display) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.$addon.arrayUtils(this.getData('ltPropSelectedList'), 'push', obj);\n\t}\n\n\tdisableClickableItem(tab) {\n\t\tvar type = this.getData('ltPropType');\n\n\t\tif (type === 'multisearch') {\n\t\t\ttab = this.getClickableItem(tab);\n\t\t}\n\n\t\tif (tab && tab.classList) {\n\t\t\ttab.classList.add('lyteDropdown-disabled');\n\t\t}\n\n\t\tthis.$node.classList.add('lyteDropdownDisabled');\n\t}\n\n    enableClickableItem(tab) {\n\t\tvar type = this.getData('ltPropType');\n\n\t\tif (type === 'multisearch') {\n\t\t\ttab = this.getClickableItem(tab);\n\t\t}\n\n\t\tif (tab && tab.classList) {\n\t\t\ttab.classList.remove('lyteDropdown-disabled');\n\t\t}\n\n\t\tthis.$node.classList.remove('lyteDropdownDisabled');\n\t}\n\n    getClickableItem(tab) {\n\t\tvar head = this.getData('drophead');\n\n\t\tif (head === 'noyield') {\n\t\t\treturn window._lyteDropdown.traverse(tab, ['HTML', 'LYTE-DROP-BUTTON']);\n\t\t}\n\t\telse {\n\t\t\treturn this.$node.querySelector('.lyteDummyEventContainer');\n\t\t}\n\n\n\t}\n\n    hideGroup(item) {\n\t\tvar group = $L(item).parent(), visibleItems;\n\n\t\tif (!group.get(0) || group.get(0).tagName !== 'LYTE-DROP-GROUP') {\n\t\t\treturn;\n\t\t}\n\n\t\tvisibleItems = this.getVisibleItems(group);\n\n\t\tif (visibleItems.length === 0) {\n\t\t\tgroup.addClass('lyteDropdownHideGroup');\n\t\t}\n\t}\n\n    showGroup(item) {\n\t\tvar group = $L(item).parent(), visibleItems;\n\n\t\tif (!group.get(0) || group.get(0).tagName !== 'LYTE-DROP-GROUP') {\n\t\t\treturn;\n\t\t}\n\n\t\tvisibleItems = this.getVisibleItems(group);\n\n\t\tif (visibleItems.length > 0) {\n\t\t\tgroup.removeClass('lyteDropdownHideGroup');\n\t\t}\n\t}\n\n    getVisibleItems(group) {\n\t\treturn group.find('lyte-drop-item:not(.lyteDropdownActive):not(.lyteSearchHidden)');\n\t}\n\n    setSelectedFromList(isDidConnect) {\n\t\tvar isMultiple = this.getData('multiple'),\n\t\t\tlist, selected, sysValue = this.getData('sysValue'),\n\t\t\tselstr = this.getData('ltPropSelected');\n\n\t\tif (!isMultiple) {\n\t\t\treturn;\n\t\t}\n\n\t\tlist = this.getData('ltPropSelectedList') || [];\n\n\t\tif (isDidConnect\n\t\t\t&& !this.calculateSelected\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tselected = [];\n\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tselected.push('' + list[i][sysValue]);\n\t\t}\n\n\t\tthis.prevSelectedList = true;\n\t\tthis.setData('ltPropSelected', JSON.stringify(selected));\n\t\tthis.prevSelectedList = false;\n\t\tthis.toggleDropdownClass();\n\t}\n\n    executeKeyNavigationCallback(item) {\n\t\t// Hiding this for now because we don't know it will be useful for anyone outside UI components\n\t\tif (this.getMethods('onKeyNavigation')) {\n\t\t\tthis.executeMethod('onKeyNavigation', this, item);\n\t\t}\n\t}\n\n    isInputEmpty(input) {\n\t\tif (input.tagName === 'LYTE-SEARCH') {\n\t\t\tinput = input.querySelector('input');\n\t\t}\n\n\t\tif (input && input.value === '') {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n    fixBoxPosition() {\n\t\tvar shouldUseSave = this.getData('ltPropFixPositionOnOpen');\n\n\t\tthis.setCss(true, shouldUseSave);\n\t}\n\n    showHide(event, eventtype, fromTg) {\n\t\tvar link = this.childComp,\n\t\t\tfreeze = this.getData('ltPropFreeze'),\n\t\t\tmul = this.getData('multiple'),\n\t\t\ttype = this.getData('ltPropType'),\n\t\t\thover = this.getData('ltPropHover'),\n\t\t\trm = this.getData('ltPropRemoveMultiple'),\n\t\t\tshow = this.getData('ltPropShow'), res, cur,\n\t\t\tblockShowHide = this.getData('blockShowHide'),\n\t\t\tisReadOnly = this.getData('ltPropReadOnly'),\n\t\t\tisDisabled = this.getData('ltPropDisabled');\n\n\t\tif (isReadOnly || isDisabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (blockShowHide) {\n\t\t\treturn;\n\t\t}\n\n\t\t/* Doesn't matter if the onBeforeOpen returns false\n\t\t * trying to open another dropdown when autoClosed is set will flush it\n\t\t * showHide is called from toggle as well\n\t\t */\n\n\t\twindow._lyteDropdown.autoClosed = null;\n\n\t\t// Exists to remove multiple selected values from a multiselect using either the meta key or the control key\n\t\tif (rm && event && mul) {\n\t\t\tcur = event.target;\n\t\t\twhile (cur && cur.tagName !== 'LYTE-DROPDOWN' && !cur.getAttribute('data-value')) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\n\t\t\t// Node with data-value is clicked so you need to process it\n\t\t\tif (cur && cur.getAttribute('data-value')) {\n\t\t\t\tthis.mark(cur, event.shiftKey, event.ctrlKey || event.metaKey);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// The node with data-value is not clicked so this is going to unmark everything\n\t\t\telse {\n\t\t\t\t_lyteDropdown.unmark();\n\t\t\t}\n\t\t}\n\t\t// When you click another dropdown whose rm is false\n\t\telse {\n\t\t\t_lyteDropdown.unmark();\n\t\t}\n\n\t\t// For some unknow reason the dropdown closes when you hover over the select box to prevent this we are doing this and same for the opposite\n\t\tif (eventtype == 'enter') {\n\t\t\tif (\n\t\t\t\tlink\n\t\t\t\t&& !link.classList.contains('lyteDropdownHidden')\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.$node.querySelector('[tabindex]').focus()\n\t\t}\n\n\t\tif (eventtype == 'leave') {\n\t\t\tif (\n\t\t\t\tlink\n\t\t\t\t&& link.classList.contains('lyteDropdownHidden')\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis.showNoResultDiv();\n\n\t\tif (!show) {\n\t\t\tif (!link) {\n\t\t\t\tthis.childComp = this.$node.querySelector('lyte-drop-box');\n\t\t\t}\n\n\t\t\tif (this.childComp) {\n\t\t\t\tthis.childComp.setAttribute('lyte-hidden', '');\n\t\t\t}\n\n\t\t\twindow._lyteUiUtils.dispatchEvent('beforeshow', this.$node, { originalEvent: event });\n\n\t\t\tif (this.getMethods('onBeforeShow')) {\n\t\t\t\tthis.beforeShow(event, fromTg, true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.setData('call', fromTg ? true : event);\n\t\t\t\tthis.first();\n\t\t\t}\n\n\t\t\tif (mul) {\n\t\t\t\tthis.addClass();\n\t\t\t}\n\t\t}\n\t\telse if (link && link.classList.contains('lyteDropdownHidden')) {\n\t\t\tlink.setAttribute('lyte-hidden', '');\n\n\t\t\twindow._lyteUiUtils.dispatchEvent('beforeshow', this.$node, { originalEvent: event });\n\n\t\t\tif (this.getMethods('onBeforeShow')) {\n\t\t\t\tthis.beforeShow(event, fromTg, false);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.setData('call', fromTg ? true : event);\n\t\t\t\tthis.subsequent(link, freeze, mul, hover);\n\t\t\t}\n\t\t}\n\t\telse if (link && (fromTg || !mul)) {\n\t\t\tif (this.beforeHide.call(this, link, event, freeze)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.closeDrop(link, event, freeze);\n\t\t}\n\t\telse if (link && type === 'multisearch') {\n\t\t\tthis.focusInput();\n\t\t}\n\t}\n\n    checkKey(event) {\n\t\tvar type = this.getData('ltPropType');\n\t\tif (event.keyCode == 9) {\n\t\t\tthis.$node.component.showHide(event, event.type);\n\n\t\t\tif (type == 'multisearch') {\n\t\t\t\tthis.focusInput();\n\t\t\t}\n\t\t}\n\t}\n\n    closeIt(event) {\n\t\tvar mx = event.clientX,\n\t\t\tmy = event.clientY,\n\t\t\tdp = this.$node.querySelector('lyte-drop-button'),\n\t\t\tdpt = dp.getBoundingClientRect().top,\n\t\t\tdph = dp.getBoundingClientRect().height,\n\t\t\tdpl = dp.getBoundingClientRect().left,\n\t\t\tdpw = dp.getBoundingClientRect().width,\n\t\t\tdc = this.childComp,\n\t\t\tdct = dc.getBoundingClientRect().top,\n\t\t\tdch = dc.getBoundingClientRect().height,\n\t\t\tdcl = dc.getBoundingClientRect().left,\n\t\t\tdcw = dc.getBoundingClientRect().width;\n\n\t\tif ((mx > Math.floor(dpl)\n\t\t\t&& mx < Math.floor(dpl + dpw)\n\t\t\t&& my > Math.floor(dpt)\n\t\t\t&& my < Math.floor(dpt + dph))\n\t\t\t|| (mx > Math.floor(dcl)\n\t\t\t\t&& mx < Math.floor(dcl + dcw)\n\t\t\t\t&& my > Math.floor(dct)\n\t\t\t\t&& my < Math.floor(dct + dch)\n\t\t\t)\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.$node.toggle(event, \"leave\")\n\t}\n\n    closeFun(event) {\n\t\tvar link = this.childComp,\n\t\t\thead = this.getData('drophead'),\n\t\t\trm = this.getData('ltPropRemoveMultiple'),\n\t\t\toldSelected = this.getData('ltPropSelected'),\n\t\t\tnode = event.target, src, sel = this.getData('ltPropSelected'), i = 0,\n\t\t\tres = [], body, end, proper, hide, ret, changeObj;\n\n\t\twhile (\n\t\t\t!node.getAttribute('data-value')\n\t\t\t&& node\n\t\t) {\n\t\t\tnode = node.parentElement\n\t\t}\n\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\n\t\tsrc = node.getAttribute('data-value')\n\n\t\tproper = this.getData('isKeyDown') ? 'keydown' : 'click';\n\n\t\tret = this.beforeRemove(event, rm ? [src] : src, proper, rm ? [node] : node);\n\n\t\tif (ret) {\n\t\t\t// Don't know why this is here\n\t\t\t// event.stopPropagation();\n\t\t\treturn;\n\t\t}\n\n\t\t// This is for inbuilt error display\n\t\tthis.closeError(link, head);\n\n\t\tchangeObj = this.findMarked(sel, [node]);\n\n\t\tthis.removeMarked(changeObj.selected, [node], head, link);\n\n\t\tif (this.getMethods('onRemove')) {\n\t\t\t// Return an array of removed values in case of removeMultiple\n\t\t\t// else return a singular value\n\t\t\tthis.executeMethod('onRemove', event, rm ? [src] : src, this.getData('ltPropSelected'), this, proper, rm ? [node] : node);\n\t\t}\n\n\t\tthis.fixBoxPosition();\n\n\t\tthis.fireOnChange(oldSelected, event, rm ? [node] : node);\n\n\t\t// Don't know why this is here\n\t\t// event.stopPropagation();\n\n\t}\n\n    data() {\n\t\treturn {\n\t\t\t'shouldDisplayIcon': prop('boolean', { 'default': false }),\n\t\t\t'changeItToInvoke': prop(\"number\", { \"default\": 1 }),\n\t\t\t'dummy1': prop(\"boolean\", { \"default\": true }),\n\t\t\t'dummy2': prop(\"boolean\", { \"default\": false }),\n\t\t\t'savedPositions': prop('object', { 'default': {} }),\n\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropRemoveMultiple\n\t\t\t * @default false\n\t\t\t * @version 1.0.2\n\t\t\t *\n\t\t\t */\n\n\t\t\t'ltPropRemoveMultiple': prop('boolean', { 'default': window._lyteUiUtils.resolveDefaultValue('lyte-dropdown', 'removeMultiple', false) }),\n\t\t\t'ltPropYield': prop(\"boolean\", { \"default\": false }),\n\n\t\t\t/**\n\t\t\t * @componentProperty {default|multiple|multisearch} ltPropType\n\t\t\t * @default default\n\t\t\t */\n\n\t\t\t'ltPropType': prop(\"string\", { \"default\": 'default' }),\n\n\t\t\t/**\n\t\t\t * @componentProperty {number} ltPropTabindex\n\t\t\t * @default 0\n\t\t\t */\n\n\t\t\t'ltPropTabindex': prop(\"number\", { \"default\": 0 }),\n\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropShow\n\t\t\t * @default false\n\t\t\t *\n\t\t\t */\n\n\t\t\t'ltPropShow': prop(\"boolean\", { \"default\": false }),\n\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropFreeze\n\t\t\t * @default true\n\t\t\t *\n\t\t\t */\n\n\t\t\t'ltPropFreeze': prop(\"boolean\", { \"default\": window._lyteUiUtils.resolveDefaultValue('lyte-dropdown', 'freeze', true) }),\n\n\t\t\t/**\n\t\t\t * @componentProperty {array} ltPropOptions\n\t\t\t * @default []\n\t\t\t */\n\n\t\t\t'ltPropOptions': prop(\"array\", { \"default\": [] }),\n\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropUserValue\n\t\t\t */\n\n\t\t\t'ltPropUserValue': prop(\"string\", { \"default\": undefined }),\n\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropSystemValue\n\t\t\t */\n\n\t\t\t'ltPropSystemValue': prop(\"string\", { \"default\": undefined }),\n\n\t\t\t/**\n\t\t\t * @componentProperty {up|down|left|right} ltPropPosition\n\t\t\t * @default down\n\t\t\t */\n\n\t\t\t'ltPropPosition': prop(\"string\", { \"default\": window._lyteUiUtils.resolveDefaultValue('lyte-dropdown', 'position', 'down') }),\n\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropIconClass\n\t\t\t * @default dropdown\n\t\t\t */\n\n\t\t\t'ltPropIconClass': prop(\"string\", { \"default\": window._lyteUiUtils.resolveDefaultValue('lyte-dropdown', 'iconClass', 'dropdown') }),\n\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropSelected\n\t\t\t * @default ''\n\t\t\t */\n\n\t\t\t'ltPropSelected': prop(\"string\", { \"default\": '' }),\n\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropCallout\n\t\t\t * @default false\n\t\t\t *\n\t\t\t */\n\n\t\t\t'ltPropCallout': prop(\"boolean\", { \"default\": window._lyteUiUtils.resolveDefaultValue('lyte-dropdown', 'callout', false) }),\n\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropPlaceholder\n\t\t\t * @version 1.0.4\n\t\t\t */\n\n\t\t\t'ltPropPlaceholder': prop(\"string\", { \"default\": window._lyteUiUtils.resolveDefaultValue('lyte-dropdown', 'placeholder', '') }),\n\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropDisabled\n\t\t\t * @default false\n\t\t\t *\n\t\t\t */\n\n\t\t\t'ltPropDisabled': prop(\"boolean\", { \"default\": false }),\n\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropHover\n\t\t\t * @default false\n\t\t\t *\n\t\t\t */\n\n\t\t\t'ltPropHover': prop(\"boolean\", { \"default\": false }),\n\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropNoResult\n\t\t\t * @default No Results Found\n\t\t\t * @version 2.0.0\n\t\t\t */\n\n\t\t\t'ltPropNoResult': prop(\"string\", { \"default\": window._lyteUiUtils.resolveDefaultValue('lyte-dropdown', 'noResult', window._lyteUiUtils.i18n('no.results.found')) }),\n\n\t\t\t/**\n\t\t\t * @componentProperty {number} ltPropMaxCount\n\t\t\t * @default 0\n\t\t\t * @version 2.1.0\n\t\t\t */\n\n\t\t\t'ltPropMaxCount': prop('number', { 'default': 0 }),\n\n\t\t\t'ltPropInputClass': prop(\"string\", { \"default\": 'lyteSearch' }),\n\n\t\t\t/**\n\t\t\t * @typedef {object} boundary\n\t\t\t * @property {number} left\n\t\t\t * @property {number} right\n\t\t\t * @property {number} top\n\t\t\t * @property {number} bottom\n\t\t\t */\n\t\t\t/**\n\t\t\t * @componentProperty {boundary} ltPropBoundary\n\t\t\t * @default {}\n\t\t\t */\n\n\t\t\t'ltPropBoundary': prop(\"object\", { \"default\": {} }),\n\t\t\t'pos': prop(\"string\", { \"default\": '' }),\n\t\t\t'secondaryPosition': prop(\"string\", { \"default\": '' }),\n\t\t\t'firePos': prop(\"number\", { \"default\": 1 }),\n\t\t\t'ltPropAjaxRequest': prop(\"object\", { \"default\": {} }),\n\t\t\t'firstRequest': prop(\"boolean\", { \"default\": true }),\n\t\t\t'userValue': prop('string'),\n\t\t\t'sysValue': prop('string'),\n\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropDisplayValue\n\t\t\t * @version 1.0.1\n\t\t\t */\n\n\t\t\t'ltPropDisplayValue': prop(\"string\", { \"default\": \"\", hideAttr: true }),\n\n\t\t\t/**\n\t\t\t * @componentProperty {array} ltPropDisabledList\n\t\t\t * @version 1.0.3\n\t\t\t * @default []\n\t\t\t */\n\n\t\t\t'ltPropDisabledList': prop('array', { \"default\": [] }),\n\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropAnimate\n\t\t\t * @default false\n\t\t\t *\n\t\t\t */\n\n\t\t\tltPropAnimate: prop('boolean', { default: window._lyteUiUtils.resolveDefaultValue('lyte-dropdown', 'animate', false) }),\n\t\t\t'ltPropSetPos': prop('boolean', { 'default': false }),\n\n\n\t\t\t/**\n\t\t\t * @componentProperty {tooltipConfig} ltPropTooltip\n\t\t * @default { \"position\" : \"bottom\", \"appearance\" : \"box\",\"margin\" : 5, \"keeptooltip\" : true}\n\t\t\t * @version 2.0.0\n\t\t\t * @component lyte-tooltip ltPropTooltipConfig\n\t\t\t */\n\n\t\t\t'ltPropTooltip': prop('object', {\n\t\t\t\t'default': window._lyteUiUtils.resolveDefaultValue('lyte-dropdown', 'tooltip', {\n\t\t\t\t\t'position': 'bottom',\n\t\t\t\t\t'appearance': 'box',\n\t\t\t\t\t'margin': 5,\n\t\t\t\t\t'keeptooltip': true\n\t\t\t\t})\n\n\t\t\t}),\n\t\t\t// 'ltPropContainerClass':Lyte.attr(\"string\",{\"default\":''}),\n\t\t\t// 'ltPropSlide':Lyte.attr(\"boolean\",{\"default\": false}),\n\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropBoxClass\n\t\t\t * @version 2.2.8\n\t\t\t */\n\n\t\t\t'ltPropBoxClass': prop('string', { 'default': window._lyteUiUtils.resolveDefaultValue('lyte-dropdown', 'boxClass', '') }),\n\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropIsOpen\n\t\t\t * @default false\n\t\t\t *\n\t\t\t * @version 2.2.8\n\t\t\t */\n\n\t\t\t'ltPropIsOpen': prop('boolean', { 'default': false }),\n\n\t\t\t'ltPropFocus': prop('boolean', { 'default': false }),\n\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropFixPositionOnOpen\n\t\t\t * @default false\n\t\t\t *\n\t\t\t * @version 2.2.12\n\t\t\t */\n\n\t\t\t'ltPropFixPositionOnOpen': prop('boolean', { 'default': window._lyteUiUtils.resolveDefaultValue('lyte-dropdown', 'fixPositionOnOpen', false) }),\n\n\t\t\t'ltPropForcePlaceholder': prop('boolean', { 'default': window._lyteUiUtils.resolveDefaultValue('lyte-dropdown', 'forcePlaceholder', false) }),\n\n\t\t\t'ltPropShowEmptyMessage': prop('boolean', { 'default': false }),\n\n\t\t\t'ltPropBoxButtonWidth': prop('string', { 'default': window._lyteUiUtils.resolveDefaultValue('lyte-dropdown', 'boxButtonWidth', 'min-button') }),\n\n\t\t\t'ltPropPreventScroll': prop('string', { 'default': 'all' }),\n\n\t\t\t'ltPropScope': prop('string', { 'default': 'window' }),\n\n\t\t\tltPropAnimateBox: prop('boolean', { default: window._lyteUiUtils.resolveDefaultValue('lyte-dropdown', 'animateBox', false) }),\n\n\t\t\t'ltPropTooltipClass': prop('string', { 'default': window._lyteUiUtils.resolveDefaultValue('lyte-dropdown', 'tooltipClass', '') }),\n\n\t\t\t'ltPropDisplayList': prop('array', { 'default': [] }),\n\n\t\t\t'ltPropSelectedList': prop('array', { 'default': window._lyteUiUtils.resolveDefaultValue('lyte-dropdown', 'selectedList', []) }),\n\n\t\t\t'ltPropItemSearchType': prop('string', { 'default': 'contains' }),\t//@options contains, startsWith\n\n\t\t\t'ltPropFocusOnClose': prop('boolean', { 'default': window._lyteUiUtils.resolveDefaultValue('lyte-dropdown', 'focusOnClose', true) }),\n\n\t\t\t'ltPropButtonClass': prop('string', { 'default': window._lyteUiUtils.resolveDefaultValue('lyte-dropdown', 'buttonClass', '') }),\n\n\t\t\t'ltPropDisableItemTooltip': prop('boolean', { 'default': false }),\n\n\t\t\t'ltPropPreventParentScroll': prop('boolean', { 'default': false }),\n\n\t\t\t'ltPropShowRemoveIcon': prop('boolean', { 'default': false }),\n\n\t\t\t'ltPropAriaButton': prop('object', { 'default': {}, watch: true }),\n\n\t\t\t// Keeping this property hidden for now because we don't know if we need it.\n\t\t\t'ltPropAriaBox': prop('object', { 'default': {}, watch: true }),\n\n\t\t\t'ltPropAriaBody': prop('object', { 'default': {}, watch: true }),\n\n\t\t\t'ltPropReadOnly': prop('boolean', { 'default': false }),\n\n\t\t\t// The element that should receive focus when the dropdown is opened. It can be in the button or the body\n\t\t\t'ltPropActiveElement': prop('string', { 'default': '' }),\n\n\t\t\t// This is used to allow focusable elements in the body and focustrap them. Also this will be hidden\n\t\t\t'ltPropAllowFocusableElements': prop('boolean', { 'default': false }),\n\t\t\t'ltPropDataTabindex': prop('string', { 'default': \"\" }),\n\n\t\t\t/* This is a special property that is used to handle a stupid case(territory dropdown in list view) where they have submenus inside dropdown.\n\t\t\tThey have submenus inside dropdown which needs to be opened and navigated through the keyboard. So we prevent our arrow key navigations\n\t\t\tThis property should not be revealed to the outside world */\n\t\t\t'ltPropPreventNavigation': prop( 'boolean', { 'default': false } ),\n\n\t\t\t'ltPropTrimSearchText': prop( 'boolean', { 'default': true } ),\n\n\t\t\t// Experimental for now\n\t\t\t'ltPropNoResultYield': prop( 'boolean', { 'default': false } )\n\n\t\t};\n\t}\n\n    getAllItems(link, __arr) {\n\t\tvar arr = __arr || [],\n\t\t\t__nodes = link ? link.children : [],\n\t\t\t__len = __nodes.length;\n\n\t\tfor (var i = 0; i < __len; i++) {\n\t\t\tvar __cur_item = __nodes[i];\n\n\t\t\tif (/lyte-drop-item/i.test(__cur_item.tagName || \"\")) {\n\t\t\t\tarr.push(__cur_item);\n\t\t\t} else {\n\t\t\t\tthis.getAllItems(__cur_item, arr);\n\t\t\t}\n\n\t\t}\n\n\t\treturn arr;\n\t}\n\n    getItem(list, value) {\n\t\tvar __len = list.length,\n\t\t\tconv = value;\n\n\t\tfor (var i = 0; i < __len; i++) {\n\t\t\tvar cur = list[i];\n\n\t\t\tif (cur.getAttribute('data-value') == conv) {\n\t\t\t\treturn cur;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n    static actions() {\n        return {\n            addFocusClass: function (event) {\n                this.getDropButton().classList.add('lyteMultiSearchDropButtonFocused');\n            },\n\n            removeFocusClass: function (event) {\n                this.getDropButton().classList.remove('lyteMultiSearchDropButtonFocused');\n            },\n\n            toolTipConfig: function (button, propName) {\n                var width = button.offsetWidth,\n                    scrollWidth = button.scrollWidth,\n                    config = this.getData('ltPropTooltip');\n\n                propName = propName || 'showToolTip';\n\n                this.setData(propName, (width < scrollWidth) && !window._lyteDropdown.isEmpty(config));\n            },\n\n            preventDefault: function (event) {\n                if (event.keyCode === 13) {\n                    event.preventDefault();\n                }\n            },\n\n            closeIt: function (event) {\n                this.closeIt(event);\n            },\n\n            processElements: function (event) {\n                this.processElements(event)\n            },\n\n            closeFun: function (event) {\n                this.closeFun(event);\n            },\n\n            checkKey: function (event) {\n                this.checkKey(event);\n            },\n\n            showHide: function ( event, eventtype, fromTg ) {\n                this.showHide( event, eventtype, fromTg );\n            }\n        };\n    }\n\n    static observers() {\n        return {\n            iconClassChanged: function () {\n                this.setIconClass();\n            }.observes('ltPropIconClass'),\n\n            setClassForRemoveIconObs: function () {\n                this.setClassForRemoveIcon();\n            }.observes('ltPropShowRemoveIcon', 'ltPropSelected'),\n\n            addDataTabindex: function () {\n                var drophead = this.getData('drophead'),\n                    isDisabled = this.getData('ltPropDisabled'),\n                    dataIndex = this.getData('ltPropDataTabindex'),\n                    tabIndexElement = this.$node.querySelector('input');\n                if (tabIndexElement && drophead === 'yield' && !isDisabled) {\n                    tabIndexElement.setAttribute('data-tabindex', dataIndex);\n                }\n            }.observes('ltPropDataTabIndex'),\n\n            addTabIndex: function () {\n                this.addTabIndexForYieldedMultisearch();\n            }.observes('ltPropTabindex'),\n\n            changeBoxClass: function (change) {\n                var oldValue = change.oldValue;\n\n                this.setBoxClass(oldValue);\n\n            }.observes('ltPropBoxClass'),\n\n            changeButtonClass: function (change) {\n                var oldValue = change.oldValue;\n\n                this.setButtonClass(oldValue);\n\n            }.observes('ltPropButtonClass'),\n\n            noResultChanged: function () {\n                var link = this.childComp,\n                    type = this.getData('ltPropType'),\n                    head = this.getData('drophead'),\n                    body = this.getDropBody(link),\n                    nores = body.querySelector('.lyteDropdownNoResult'),\n                    text = this.getData('ltPropNoResult'),\n                    link = this.childComp;\n\n                nores.textContent = text;\n\n                if (!text) {\n                    nores.style.display = 'none';\n                }\n\n                // Hide the no result div if text is empty\n                if (link) {\n                    this.showError(link, type, head);\n                }\n\n            }.observes('ltPropNoResult'),\n\n            // TODO: Fix this\n            onChangeInDisabledList: function () {\n                var elements = this.childComp ? this.childComp.querySelectorAll('lyte-drop-item') : this.$node.querySelectorAll('lyte-drop-item'),\n                    isItemDisabled;\n\n                for (var i = 0; i < elements.length; i++) {\n                    isItemDisabled = this.$component.registeredHelpers.lyteUiCheckDisabled(this.getData('ltPropDisabledList') || [], elements[i].dataset.value);\n\n                    if (isItemDisabled === 'true') {\n                        elements[i].classList.remove('lyteDropdownSelection');\n                        elements[i].setAttribute('disabled', isItemDisabled);\n                    }\n\n                    if (isItemDisabled === 'false' && elements[i].hasAttribute('disabled')) {\n                        elements[i].removeAttribute('disabled');\n                    }\n                }\n                this.addDisabledClass(elements);\n\n            }.observes('ltPropDisabledList.[]', 'ltPropOptions.[]' ).on('didConnect'),\n\n            /**\n             * Fires the position callback and adds and removes classes for the drop-box according to the direction\n             *\n             */\n\n            firePosCallBack: function () {\n                var pos = this.getData('pos'),\n                    needCv = this.getData('widthAdjusted');\n\n                if (pos !== '') {\n                    // Fast dom removed here because it is causing a bug in ie\n                    // $L.fastdom.mutate( function() {\n                    var body = this.childComp,\n                        bt = this.$node.querySelector('lyte-drop-button'),\n                        ngcls = this.removeClass(body.classList, pos, 'lyteDropdown');\n\n                    /* Removing and adding class of the lyte-drop-box */\n\n                    if (ngcls) {\n                        this._preventClass = true;\n                        body.classList.remove(ngcls);\n                    }\n\n                    body.classList.add('lyteDropdown' + pos[0].toUpperCase() + pos.substring(1));\n\n                    /* End */\n\n                    /* Removing and adding class of lyte-drop-button */\n\n                    ngcls = this.removeClass(bt.classList, pos, 'lyteDropButton');\n\n                    if (ngcls) {\n                        this._preventClass = true;\n                        bt.classList.remove(ngcls);\n                    }\n\n                    bt.classList.add('lyteDropButton' + pos[0].toUpperCase() + pos.substring(1));\n\n                    /* End */\n\n                    if (needCv === 2) {\n                        body.classList.add('lyteDropdownCurve');\n                    }\n\n                    if (this.getMethods('onPositionChanged')) {\n                        this.executeMethod('onPositionChanged', pos, this);\n                    }\n                    // }, this );\n\n                }\n\n            }.observes(\n                'pos',\n                'firePos'\n            ),\n\n            secondaryPositionObserver: function () {\n                var pos = this.getData('secondaryPosition') || '';\n\n                if (pos !== '') {\n                    var box = this.childComp,\n                        classToRemove = this.removeClass(box.classList, pos, 'lyteDropbox', false, 'AlignToButton');\n\n                    if (classToRemove) {\n                        box.classList.remove(classToRemove);\n                    }\n\n                    this._preventClass = true;  // This preventClass will take care of the classToRemove mut observer fire\n                    box.classList.add('lyteDropbox' + pos[0].toUpperCase() + pos.substring(1) + 'AlignToButton');\n                }\n            }.observes('secondaryPosition'),\n\n            selObs: function (change) {\n                var old = change.oldValue;\n\n                if (this.getData('prev')) {\n                    return;\n                }\n\n                // TODO:\n                // When limit crosses we reset the ltPropSelected which causes the other lt-prop-selected to fire\n                // That observer fires twice overall but doesn't change the state of the dropdown but we need to cutdown\n                // the processing\n                if (this.checkLimit(0)) {\n                    this.setData('prev', true);\n                    this.setData('ltPropSelected', old);\n                    this.setData('prev', false);\n\n                    return;\n                }\n\n                this.hideNodes();\n                this.showNodes(change);\n            }.observes('ltPropSelected'),\n\n            /**\n             * Function to set an initial value to the dropdown when lt-prop-options is pushed later\n             * into the dropdown. When lt-prop-options is empty and new items are pushed in\n             * @param change - Old value and new values\n             *\n             */\n\n            contentChange: function (change) {\n                var oldValue = change.oldValue,\n                    newValue = change.newValue,\n                    sel = this.getData('ltPropSelected'),\n                    ph = this.getData('ltPropPlaceholder'),\n                    disp = this.getData('ltPropDisplayValue'),\n                    body = this.getData('dropbody') === 'yield',\n\n                    // Old value of lt-prop-options should be empty and the new value should be filled\n                    initial = (\n                        (oldValue && oldValue.length === 0)\n                        || !oldValue\n                    ) && newValue && newValue.length > 0;\n\n                if (initial && !sel && !ph && !body) {\n                    this.setInitialSelected();\n                }\n\n                this.showNoResultDiv();\n            }.observes('ltPropOptions'),\n\n            // This is going to only process the child nodes\n            hideOptionsBasedOnSelected: function () {\n                // This is for multiselect\n                var link = this.childComp,\n                    head = this.getData('drophead'),\n                    multiple = this.getData('multiple'),\n                    type = this.getData('ltPropType');\n\n                if (link && multiple) {\n                    this.hideNodes();\n\n                    // close error will always close the error\n                    this.closeError(link, head);\n\n                    // So there is no error div showing now and show error will decide to show it or not based on the displayed items\n                    this.showError(link, type, head);\n                }\n            }.observes('ltPropOptions'),\n\n            selChange: function () {\n                var mul = this.getData('multiple'),\n                    head = this.getData('drophead'),\n                    link = this.childComp,\n                    sel = this.getData('ltPropSelected'),\n                    disp = this.getData('ltPropDisplayValue'),\n                    preventDisp = this.getData('preventDisp'),\n                    sels, parent = link ? link : this.$node.querySelector('lyte-drop-box'),\n                    body = this.getDropBody(parent),\n                    node, i = 0;\n\n                if (this.prevSelectedList) {\n                    return;\n                }\n\n                if (\n                    mul\n                ) {\n                    this.setSelectedList();\n                }\n                else if (!mul) {\n                    var all_elems = this.getAllItems(parent);\n\n                    // node = parent.querySelector( '[data-value=\"' + window._lyteUiUtils.escape( sel ) + '\"]' );\n                    node = this.getItem(all_elems, sel);\n\n                    if (node) {\n                        this.toggleCurrent(node);\n                    }\n\n                    // Don't remove previous selected=true attribute when it is a multiselect should only remove it when the element is removed from the selected list.\n                    sels = parent.querySelectorAll('[selected]');\n\n                    for (; i < sels.length; i++) {\n                        if (sels[i].getAttribute('data-value') != sel) {\n                            sels[i].removeAttribute('selected');\n                        }\n                    }\n\n                    if (head !== 'yield') {\n                        if (node) {\n                            var innerText = node.textContent;\n\n                            if ((disp && !preventDisp) || !disp) {\n\n                                // don't really need the or over here but w.e\n                                this.setData('ltPropDisplayValue', (innerText || '').trim());\n                            }\n                        }\n                        else if (!sel && !preventDisp) {\n                            this.setData('ltPropDisplayValue', '');\n                        }\n                    }\n\n                }\n\n                // To set selected to true to the ltPropSelected node\n                if (node) {\n                    node.setAttribute('selected', 'true');\n                }\n\n                this.toggleDropdownClass();\n\n            }.observes(\n                'ltPropOptions',\n                'ltPropSelected',\n                'changeItToInvoke'\n            ),\n\n            tabIndexChange: function () {\n                this.toggleButtonInteractivity();\n            }.observes('ltPropDisabled'),\n\n            focusDropdown: function () {\n                var focusableElement = this.getElementWithTabIndex(),\n                    shouldFocus = this.getData('ltPropFocus'),\n                    isSearch = this.getData('search');\n\n                if (shouldFocus) {\n                    if (!isSearch && focusableElement) {\n                        focusableElement.focus( { preventScroll: this.preventScroll } );\n                    }\n                    else if (isSearch) {\n                        this.$node.open();\n                    }\n                }\n\n                this.data.ltPropFocus = false;\n            }.observes('ltPropFocus').on('didConnect'),\n\n            showHideEmptyMessage: function () {\n                this.showNoResultDiv();\n            }.observes('ltPropShowEmptyMessage'),\n\n            setSelectedFromListObs: function () {\n                if (this.getData('preventSelListObs')) {\n                    return;\n                }\n\n                this.setSelectedFromList();\n            }.observes('ltPropSelectedList.[]'),\n\n            ariaObserver: function () {\n                // TODO: Need to fix the setAttribute oldAria argument passed here\n                window._lyteUiUtils.setAttribute(this.getDropBox(), this.getData('ltPropAriaBox') || {}, {});\n                window._lyteUiUtils.setAttribute(this.getDropBody(this.childComp), this.getData('ltPropAriaBody') || {}, {});\n                window._lyteUiUtils.setAttribute(this.getAriaButton(), this.getData('ltPropAriaButton') || {}, {});\n            }.observes('ltPropAriaButton', 'ltPropAriaButton.{}', 'ltPropAriaBox', 'ltPropAriaBox.{}', 'ltPropAriaBody', 'ltPropAriaBody.{}' ).on('didConnect')\n        };\n    }\n}\n\nwindow.addEventListener('scroll', function (event) {\n\t$L.fastdom.measure(function () {\n\t\tvar elm = window._lyteDropdown.getVisibleDropbox(),\n\t\t\ttempele = elm,\n\t\t\tisAnimate,\n\t\t\tcur = event.target, shouldUseSave,\n\t\t\tdrop, component, boundary, offsets, link, bounds;\n\n\t\tif (!elm) {\n\t\t\twindow._lyteDropdown.openAutoClosedDropdown(cur, event);\n\t\t\treturn;\n\t\t}\n\n\t\t// if( cur.nodeName == \"#document\" ) {     //This probably happens because scrollIntoView is used to focus the dropdown which is open at the start so the event.target is #document(CODE HELP)\n\t\t// \treturn ;\n\t\t// }\n\n\t\twhile (cur != document && cur.tagName !== 'LYTE-DROP-BOX' && cur.tagName !== 'HTML') {\n\t\t\tcur = cur.parentElement;\n\t\t}\n\n\t\tif (cur.tagName === 'LYTE-DROP-BOX') {\n\t\t\treturn;\n\t\t}\n\n\t\tdrop = elm.origindd;\n\n\t\t// People could just render the lyte-drop-box without any dropdown and that guy is scrolling\n\t\tif (!drop) {\n\t\t\twindow._lyteDropdown.openAutoClosedDropdown(cur, event);\n\t\t\treturn;\n\t\t}\n\n\t\tcomponent = drop.component;\n\t\tlink = component.childComp;\n\n\n\t\t// Dropdowns crossing their boundaries are closed automatically\n\t\tbounds = window._lyteDropdown.buildBounds(component);\n\t\toffsets = drop.getBoundingClientRect();\n\n\t\tif ((offsets.top < bounds.top\n\t\t\t|| offsets.left < bounds.left\n\t\t\t|| offsets.right > bounds.right\n\t\t\t|| offsets.bottom > bounds.bottom)\n\t\t) {\n\n\t\t\tcomponent.beforeScrollClose(event);\n\t\t\tif (component.beforeHide.call(component, link, event, component.getData('ltPropFreeze'))) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcomponent.closeDrop.call(component, link, event, component.getData('ltPropFreeze'), true);\n\t\t\tisAnimate = component.getData('ltPropAnimate');\n\n\t\t\t/* While closeDrop does set autoClosed to null\n\t\t\t * This sets it to its proper value thereby making the dropdown properly close/open when\n\t\t\t * it either moves out or comes into bounds\n\t\t\t */\n\n\n\t\t\tif (!isAnimate) {\n\t\t\t\twindow._lyteDropdown.autoClosed = drop;\n\t\t\t}\n\n\t\t}\n\n\t\t// Set CSS of the dropdown on scrolling\n\t\tif (!drop.component._preventSetcss) {\n\t\t\tshouldUseSave = drop.component.getData('ltPropFixPositionOnOpen');\n\n\t\t\tdrop.component.setCss(true, shouldUseSave);\n\t\t}\n\t});\n}, true);\n\ndocument.addEventListener('click', function (event) {\n\tvar ele = event.target,\n\t\ttarget = event.target,\n\t\tcur, all, i = 0, j = 0, type,\n\t\topen, temp, component, res, freeze, link, drp, item, active, container, head, input;\n\n\t// Performing an user action such as click whether it is on the same dropdown\n\t// or another dropdown or anywhere will flush autoClosed\n\t// Browser defined scrollbars don't trigger a click but lyte-scrollbar does\n\tif (!window._lyteDropdown.isScrollBar(target)) {\n\t\twindow._lyteDropdown.autoClosed = null;\n\t}\n\n\tele = window._lyteDropdown.traverse(ele, ['LYTE-DROPDOWN', 'HTML', 'LYTE-DROP-BOX', 'LYTE-DROP-REMOVE']);\n\n\tif (window._lyteDropdown.focusOut) {\n\n\t\t// If container is html, then the click event in the dropdown will close it.\n\t\twindow._lyteDropdown.preventClose = ele && ele.tagName !== 'HTML' ? true : false;\n\t}\n\n\t// return when there is no element\n\tif (!ele) {\n\t\treturn;\n\t}\n\n\tif (ele.tagName == 'HTML') {\n\n\t\twindow._lyteDropdown.unmark();\n\t\topen = document.querySelectorAll('lyte-drop-box:not(.lyteDropdownHidden)');\n\n\t\tfor (; j < open.length; j++) {\n\t\t\ttemp = open[j];\n\t\t\tif (temp) {\n\t\t\t\tcomponent = temp.origindd.component;\n\n\t\t\t\tif (component.beforeHide.call(component, temp, event, component.getData('ltPropFreeze'))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfreeze = document.getElementById('lytedropdownfreezelayer');\n\t\t\t\tcomponent.closeDrop.call(component, temp, event, freeze);\n\t\t\t}\n\t\t}\n\n\t\tactive = document.activeElement;\n\n\t\t// Looks like activeElements can be undefined - LOL IE\n\t\tif (active && active.tagName === 'INPUT' && (container = window._lyteDropdown.traverse(active, ['LYTE-DROPDOWN']))) {\n\t\t\tactive.blur();\n\t\t}\n\t}\n\telse if (ele.tagName === 'LYTE-DROPDOWN') {\n\t\tcur = ele;\n\t\tall = document.querySelectorAll('lyte-drop-box:not(.lyteDropdownHidden)')\n\t\tfor (; i < all.length; i++) {\n\t\t\tif (all[i].origindd == cur) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdrp = all[i].origindd;\n\t\t\t\tcomponent = drp.component;\n\t\t\t\twindow._lyteDropdown.unmark();\n\n\t\t\t\tif (component.beforeHide.call(component, component.childComp, event, component.getData('ltPropFreeze'))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tcomponent.closeDrop.call(component, component.childComp, event, component.getData('ltPropFreeze'));\n\t\t\t}\n\t\t}\n\t}\n\telse if (ele.tagName === 'LYTE-DROP-REMOVE') {\n\t\tdrp = ele;\n\t\twhile (drp.tagName != 'LYTE-DROPDOWN') {\n\t\t\tif (drp.getAttribute('data-value')) {\n\t\t\t\titem = drp;\n\t\t\t}\n\t\t\tdrp = drp.parentElement;\n\t\t}\n\n\t\ttype = drp.ltProp('type');\n\t\thead = drp.component.getData('drophead');\n\n\t\twindow._lyteDropdown.closeOtherDropdowns(drp);\n\n\t\tif (drp.ltProp('readOnly')) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (type === 'default') {\n\t\t\tdrp.ltProp('selected', '');\n\t\t}\n\t\telse {\n\t\t\tif (type === 'multisearch') {\n\t\t\t\tdrp.component.focusInput();\n\t\t\t\tinput = drp.querySelector('lyte-search') || drp.querySelector('input');\n\n\t\t\t\tif (input && input.setValue) {\n\t\t\t\t\tinput.setValue('');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (item.classList.contains('lyteDropMark')) {\n\t\t\t\tdrp.component.removeAll(event);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twindow._lyteDropdown.unmark();\n\t\t\t\tdrp.component.closeFun(event);\n\t\t\t}\n\t\t}\n\n\t}\n}, true);\n\nif (window._lyteUiUtils.isIos) {\n\tdocument.addEventListener('focusout', function (event) {\n\t\t// need to check for multiple dropdown\n\t\tvar target = event.target,\n\t\t\topen, drop, comp, freeze;\n\n\t\t// test for normal input in dom\n\t\tif ((drop = window._lyteDropdown.traverse(target, 'LYTE-DROPDOWN'))\n\t\t\t&& event.target.tagName === 'INPUT'\n\t\t) {\n\t\t\tcomp = drop.component;\n\t\t\topen = comp.childComp;\n\t\t\tfreeze = comp.getData('ltPropFreeze');\n\n\t\t\twindow._lyteDropdown.focusOut = true;\n\n\t\t\tsetTimeout(function () {\n\n\t\t\t\tif (_lyteDropdown.preventClose) {\n\t\t\t\t\t_lyteDropdown.preventClose = _lyteDropdown.focusOut = false;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (open\n\t\t\t\t\t&& !open.classList.contains('lyteDropdownHidden')\n\t\t\t\t) {\n\t\t\t\t\tif (comp.beforeHide(open, event, freeze)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tcomp.closeDrop(open, event, freeze);\n\t\t\t\t}\n\n\t\t\t\t_lyteDropdown.focusOut = false;\n\t\t\t}, 0);\n\t\t}\n\t}, true);\n}\n\ndocument.addEventListener('keydown', function (event) {  //This is to take care of the tabbing problems in a dropdown and traversing(CODE HELP)\n\tvar kc = event.keyCode,\n\t\tactive, acomp, abutton, anodes, activeDrop,\n\t\topen = document.querySelector('lyte-drop-box:not(.lyteDropdownHidden)'),\n\t\ttype, res, drp, component, src, last, l = 0, cur, elem, elems, i = 0, j, all, k, curActive;\n\n\n\tif (window._lyteDropdown.openFocusedDropdown(kc)) {\n\t\treturn;\n\t}\n\n\tif (kc === 32 || kc === 40) {\n\t\tcurActive = activeDrop = document.activeElement;\n\t\tactiveDrop = window._lyteDropdown.traverse(activeDrop, ['LYTE-DROPDOWN', 'HTML']);\n\n\t\t// active elements can be null - LOL IE\n\t\tif (activeDrop) {\n\t\t\tif (activeDrop.tagName === 'LYTE-DROPDOWN' && curActive.tagName !== 'INPUT' && curActive.tagName !== 'TEXTAREA') {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\n\t\t\tif (activeDrop.tagName === 'LYTE-DROPDOWN'\n\t\t\t\t&& !activeDrop.ltProp( 'isOpen' )\n\t\t\t) {\n\t\t\t\tactiveDrop.component.showHide(event, event.type);\n\n\t\t\t\t// End this here\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t// UP, DOWN, ENTER\n\tif (\n\t\t(\n\t\t\tkc == 38\n\t\t\t|| kc == 40\n\t\t\t|| kc == 13\n\t\t)\n\t\t&& open\n\t) {\n\n\t\tif (kc == 38\n\t\t\t|| kc == 40\n\t\t) {\n\t\t\tevent.preventDefault()\n\t\t}\n\n\t\t// Get the current highlighted element\n\t\tdrp = open.origindd;\n\t\tcomponent = drp.component;\n\t\ttype = component.getData('ltPropType');\n\t\topen = component.getDropBox();\n\t\tcur = open.querySelector('.lyteDropdownSelection');\n\n\t\tvar shouldNavigate = component.shouldNavigate();\n\n\t\tif (!shouldNavigate) {\n\t\t\treturn;\n\t\t}\n\n\t\t// No current Highlighted Element or the current highlighted element is hidden\n\t\t// It just sets the first visible element as highlighted and returns\n\t\t// Only for multiselects\n\t\tif (\n\t\t\t!cur\n\t\t\t|| (cur && !window._lyteDropdown.isVisible(cur))\n\t\t) {\n\n\t\t\t// This one is a yikes\n\t\t\telems = open.querySelectorAll('lyte-drop-item:not(.lyteSearchHidden):not(.lyteDropdownActive)') //wrong\n\n\t\t\tfor (; i < elems.length; i++) {\n\t\t\t\tif (window._lyteDropdown.isVisible(elems[i])\n\t\t\t\t\t&& elems[i].getAttribute('disabled') !== \"true\"\n\t\t\t\t) {\n\t\t\t\t\telem = elems[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cur) {\n\t\t\t\tcur.classList.remove('lyteDropdownSelection');\n\t\t\t}\n\n\t\t\tif (elem) {\n\t\t\t\telem.classList.add('lyteDropdownSelection');\n\t\t\t\tcomponent.getActiveElement().setAttribute('aria-activedescendant', elem.getAttribute('id'));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tkc = event.keyCode;\n\t\telems = open.querySelectorAll('lyte-drop-item');\n\t\tfor (i = 0; i < elems.length; i++) {\n\t\t\tif (elems[i].classList.contains('lyteDropdownSelection')) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// A highlighted element was present and enter is pressed\n\t\tif (kc == 13) {\n\t\t\tif (component.getData('multiple')) {\n\t\t\t\tif (!elems[i]) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\telems[i].click();\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// Just a safety check.\n\t\t\t\t// lyteDropdownSelection is most likely present\n\t\t\t\tif (elems[i]) {\n\t\t\t\t\telems[i].click();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Key up was pressed\n\t\telse if (\n\t\t\tkc == 38\n\t\t\t&& i != 0\n\t\t) {\n\t\t\tj = i;\n\t\t\ti = window._lyteDropdown.find(elems, i - 1, false);\n\n\t\t\tif (i != -1) {\n\t\t\t\tcomponent.scrollIntoView(elems[i], 'up');\n\t\t\t\telems[j].classList.remove('lyteDropdownSelection');\n\t\t\t\telems[i].classList.add('lyteDropdownSelection');\n\t\t\t\tcomponent.getActiveElement().setAttribute('aria-activedescendant', elems[i].getAttribute('id'));\n\t\t\t\tcomponent.executeKeyNavigationCallback(elems[i]);\n\t\t\t}\n\t\t}\n\n\t\t// Key down was pressed\n\t\telse if (\n\t\t\tkc == 40\n\t\t\t&& i != elems.length - 1\n\t\t) {\n\t\t\tj = i;\n\t\t\ti = window._lyteDropdown.find(elems, i + 1, true);\n\n\t\t\tif (i < elems.length) {  // Added this because it was breaking in CRM\n\t\t\t\tcomponent.scrollIntoView(elems[i], 'down');\n\t\t\t\telems[j].classList.remove('lyteDropdownSelection');\n\t\t\t\telems[i].classList.add('lyteDropdownSelection');\n\t\t\t\tcomponent.getActiveElement().setAttribute('aria-activedescendant', elems[i].getAttribute('id'));\n\t\t\t\tcomponent.executeKeyNavigationCallback(elems[i]);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// Backspace was pressed\n\telse if (kc === 8) {\n\t\tactive = window._lyteDropdown.getActive();\n\n\t\tif (active) {\n\t\t\tacomp = active.component;\n\t\t\tabutton = active.querySelector('lyte-drop-button');\n\t\t\tanodes = abutton.querySelector('.lyteDropMark');\n\t\t}\n\n\t\tdrp = window._lyteDropdown.getDropdownWithFocusedInput();\n\n\t\tif (!drp) {\n\t\t\treturn;\n\t\t}\n\n\t\tcomponent = drp && drp.component;\n\t\ttype = component && component.getData('ltPropType');\n\n\t\tif (anodes) {\n\t\t\tevent.preventDefault();\n\t\t\tacomp.setData('isKeyDown', true);\n\t\t\tacomp.removeAll(event);\n\t\t\tacomp.setData('isKeyDown', false);\n\t\t}\n\t\telse if (drp && type === 'multisearch' && window._lyteDropdown.isInput(event)) {\n\t\t\tlast = drp.querySelectorAll('lyte-drop-remove')\n\t\t\tif (last.length > 0) {\n\t\t\t\tdrp.component.setData('isKeyDown', true);\n\t\t\t\tlast[last.length - 1].click();\n\t\t\t\tdrp.component.setData('isKeyDown', false);\n\t\t\t}\n\t\t}\n\t}\n\n\n\telse if (\n\t\tkc === 27\n\t\t|| kc === 9\n\t) {\n\t\t// Escape\n\t\t// Close the current opened dropdown\n\t\tif (open) {\n\n\t\t\topen = window._lyteDropdown.traverse(open, ['LYTE-DROP-BOX']);\n\n\t\t\tif (!open) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcomponent = open.origindd.component;\n\n\t\t\tif (kc === 9 && window._lyteDropdown.shouldTrapFocus(component)) {\n\t\t\t\twindow._lyteDropdown.loopIfBoundaryElements(component, event);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (component.beforeHide.call(component, component.childComp, event, component.getData('ltPropFreeze'))) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// open.classList.add('lyteDropdownHidden')\n\t\t\t\tcomponent.closeDrop.call(component, component.childComp, event, component.getData('ltPropFreeze'));\n\t\t\t}\n\t\t}\n\t}\n});\n\ndocument.addEventListener('keypress', function (event) { //It searches the dropdown items matching the pressed charactes when the dropdown is open\n\tvar kc = event.which || event.keyCode, i = 0, children, pos,\n\t\topen = document.querySelectorAll('lyte-drop-box:not(.lyteDropdownHidden)'), drp, searchMethod;\n\n\tvar isMatchFound = function (itemValue, searchKey, method) {\n\t\tif (method === 'contains') {\n\t\t\tif (itemValue.trim().toLowerCase().indexOf(searchKey.toLowerCase()) != -1) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse if (method === 'startsWith') {\n\t\t\tif (itemValue.trim().substring(0, searchKey.length).toLowerCase() === searchKey.toLowerCase()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t};\n\n\tif (\n\t\topen.length > 0\n\t\t&& ((kc >= 65 && kc <= 90)\n\t\t\t|| (kc >= 97 && kc <= 122)\n\t\t\t|| (kc >= 48 && kc <= 57))\n\t) {\n\t\twindow._lyteDropdown.pressedCharacter = _lyteDropdown.pressedCharacter ? _lyteDropdown.pressedCharacter += String.fromCharCode(kc) : String.fromCharCode(kc);\n\t\tif (_lyteDropdown.checkDDtimeoutId) {\n\t\t\tclearTimeout(_lyteDropdown.checkDDtimeoutId);\n\t\t}\n\n\t\t_lyteDropdown.checkDDtimeoutId = setTimeout(function () {\n\t\t\t_lyteDropdown.pressedCharacter = null;\n\t\t}, 500);\n\n\t\t// activeElements can be null - LOL IE\n\t\tdrp = (document.activeElement || {}).parentElement;\n\t\tdrp = (drp || {}).tagName == \"LYTE-DROPDOWN\" ? drp : null;\n\t\tif (open.length > 0 && drp) {\n\t\t\tfor (var i = 0; i < open.length; i++) {\n\t\t\t\t// breaking change\n\t\t\t\tif (open[i].origindd == drp) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\topen = open[i];\n\t\t\tdrp = open.origindd;\n\t\t\tchildren = open.querySelectorAll('lyte-drop-item');\n\t\t\tsearchMethod = drp.getData('ltPropItemSearchType');\n\n\t\t\tif (\n\t\t\t\t_lyteDropdown.cachePreviousVal.char\n\t\t\t\t&& _lyteDropdown.cachePreviousVal.char == _lyteDropdown.pressedCharacter\n\t\t\t\t&& (_lyteDropdown.cachePreviousVal.pos + 1) < children.length\n\t\t\t\t&& isMatchFound(children[_lyteDropdown.cachePreviousVal.pos + 1].textContent, _lyteDropdown.pressedCharacter, searchMethod)/* children[ _lyteDropdown.cachePreviousVal.pos + 1 ].textContent.trim().substring( 0, _lyteDropdown.pressedCharacter.length ).toLowerCase() === _lyteDropdown.pressedCharacter.toLowerCase()*/\n\t\t\t) {\n\t\t\t\tpos = _lyteDropdown.cachePreviousVal.pos + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (i = 0; i < children.length; i++) {\n\t\t\t\t\tif (isMatchFound(children[i].textContent, _lyteDropdown.pressedCharacter, searchMethod) /*children[ i ].textContent.trim().substring( 0, _lyteDropdown.pressedCharacter.length ).toLowerCase() === _lyteDropdown.pressedCharacter.toLowerCase()*/) {\n\t\t\t\t\t\tpos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pos != undefined) {\n\t\t\t\tvar selected = open.querySelectorAll('.lyteDropdownSelection');\n\t\t\t\tfor (var j = 0; j < selected.length; j++) {\n\t\t\t\t\tselected[j].classList.remove('lyteDropdownSelection');\n\t\t\t\t}\n\t\t\t\tchildren[pos].classList.add('lyteDropdownSelection');\n\t\t\t\tdrp.component.getActiveElement().setAttribute('aria-activedescendant', children[pos].getAttribute('id'));\n\t\t\t\tvar scrollDiv = open.querySelector('lyte-drop-body');\n\n\t\t\t\tif (scrollDiv.contains(children[pos])) {\n\t\t\t\t\t// footers can have lyte-drop-items. So no scrolling there.\n\t\t\t\t\tscrollDiv.scrollTop += parseInt(children[pos].getBoundingClientRect().top - scrollDiv.getBoundingClientRect().top);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_lyteDropdown.cachePreviousVal.char = _lyteDropdown.pressedCharacter;\n\t\t\t_lyteDropdown.cachePreviousVal.pos = pos;\n\t\t}\n\n\t}\n\n});\n\nif (!window._lyteUiUtils.isMobile) {\n\twindow.addEventListener('resize', function (event) {\n\t\tdelete this._hgt;\n\n\t\t// Resizing is counted as an user action which flushes the autoClosed property\n\t\twindow._lyteDropdown.autoClosed = null;\n\n\t\tvar open = document.querySelector('lyte-drop-box:not(.lyteDropdownHidden)'),\n\t\t\tshouldUseSave;\n\n\t\tif (open && !open.origindd.component._preventSetcss) {\n\t\t\tshouldUseSave = open.origindd.component.getData('ltPropFixPositionOnOpen');\n\n\t\t\topen.origindd.component.setCss(true, shouldUseSave);\n\t\t}\n\t});\n}\n\nif (!window._lyteUiUtils.registeredCustomElements['lyte-drop-body']) {\n    window._lyteUiUtils.registeredCustomElements['lyte-drop-body'] = true;\n\n    /**\n\t   * @customElement lyte-drop-box\n\t   */\n\n    class LyteDropBodyCustomElements extends LyteUiComponentComponentRegistry.CustomElements {\n        static options = {clone : {allCallbacks : false}};\n\n        lookups() {\n            return [{\n                component: LyteUiComponentComponentRegistry\n            }];\n        }\n\n        constructor() {\n            super();\n        }\n\n        static get observedAttributes() {\n            return [];\n        }\n\n        connectedCallback() {\n            var lyteNode = this.$node;\n\n            if (!lyteNode._attributesSet) {\n\t\t\t\tvar cur = window._lyteDropdown.traverse(lyteNode, ['LYTE-DROPDOWN', 'BODY']), dropdown, component, ariaButton;\n\n\t\t\t\tif (cur.tagName === 'BODY') {\n\t\t\t\t\tcur = lyteNode.origindd;\n\t\t\t\t}\n\n\t\t\t\tif (!cur || cur.tagName !== 'LYTE-DROPDOWN') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tdropdown = cur;\n\t\t\t\tcomponent = dropdown.component;\n\n\t\t\t\t// if( component.getData( 'ltPropType' ) === 'multisearch' || component.getData( 'ltPropType' ) === 'multiple' ) {\n\t\t\t\t// \tthis.setAttribute( 'aria-multiselectable', 'true' );\n\t\t\t\t// }\n\t\t\t\t// else {\n\t\t\t\t// \tthis.setAttribute( 'aria-multiselectable', 'false' );\n\t\t\t\t// }\n\t\t\t\tlyteNode._attributesSet = true;\n\n\t\t\t\tlyteNode.setAttribute('role', 'listbox');\n\t\t\t\tif (!lyteNode.getAttribute('id')) {\n\t\t\t\t\tlyteNode.setAttribute('id', 'Lyte_Drop_Body_' + window._lyteDropdownBodyId++);\n\t\t\t\t}\n\n\t\t\t\tariaButton = component.getAriaButton();\n\n\t\t\t\tif (ariaButton) {\n\t\t\t\t\tariaButton.setAttribute('aria-controls', lyteNode.getAttribute('id'));\n\t\t\t\t}\n\n\t\t\t}\n        }\n    }\n\n    LyteDropBodyCustomElements.register(\"lyte-drop-body\");\n}\n\nif (!window._lyteUiUtils.registeredCustomElements['lyte-drop-item']) {\n    window._lyteUiUtils.registeredCustomElements['lyte-drop-item'] = true;\n\n    /**\n\t * @customElement lyte-drop-item\n\t */\n\n    class LyteDropItemCustomElements extends LyteUiComponentComponentRegistry.CustomElements {\n        static options = {clone : {allCallbacks : false}};\n\n        lookups() {\n            return [{\n                component: LyteUiComponentComponentRegistry\n            }];\n        }\n\n        constructor() {\n            super();\n        }\n\n        static get observedAttributes() {\n            return ['selected'];\n        }\n\n        connectedCallback() {\n            var lyteNode = this.$node;\n\n\n            if (!lyteNode._eventRegistered) {\n\n\t\t\t\tlyteNode._eventRegistered = true;\n\n\t\t\t\tlyteNode.setAttribute('aria-selected', 'false');\n\t\t\t\tlyteNode.setAttribute('role', 'option');\n\n\t\t\t\tif (!lyteNode.getAttribute('id')) {\n\t\t\t\t\tlyteNode.setAttribute('id', 'Lyte_Drop_Item_' + window._lyteDropdownItemId++);\n\t\t\t\t}\n\n\t\t\t\t// this.setAttribute( 'tabindex', '-1' );\n\n\n\t\t\t\tlyteNode.addEventListener('mouseenter', function () {\n\t\t\t\t\tvar title = lyteNode.getAttribute('data-title'),\n\t\t\t\t\t\tshowCustomTooltip = lyteNode.getAttribute( 'data-custom-tooltip' ),\n\t\t\t\t\t\twidth = lyteNode.offsetWidth,\n\t\t\t\t\t\tscrollWidth = lyteNode.scrollWidth,\n\t\t\t\t\t\tcomponent = window._lyteDropdown.getDropdownFromItem(lyteNode), tooltipConfig, cls, showToolTip;\n\n\t\t\t\t\tif (!component) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (component.getData('ltPropDisableItemTooltip') || showCustomTooltip === \"true\" ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttooltipConfig = component.getData('ltPropTooltip');\n\t\t\t\t\tcls = component.getData('ltPropTooltipClass');\n\n\t\t\t\t\ttitle = title || lyteNode.innerText.trim();\n\n\t\t\t\t\tshowToolTip = (width < scrollWidth && !window._lyteDropdown.isEmpty(tooltipConfig));\n\t\t\t\t\tlyteNode.setAttribute('lt-prop-title', showToolTip ? title : '');\n\n\t\t\t\t\tif (showToolTip) {\n\t\t\t\t\t\tlyteNode.setAttribute('lt-prop-tooltip-config', JSON.stringify(tooltipConfig));\n\t\t\t\t\t\tlyteNode.setAttribute('lt-prop-tooltip-class', cls);\n\t\t\t\t\t}\n\n\t\t\t\t});\n\t\t\t}\n\n            var component = window._lyteDropdown.getDropdownFromItem(lyteNode);\n            lyteNode._dropdownComponent = component;\n\n            window.clearTimeout(component._FFBodyScrollOnAdd);\n\n            component._FFBodyScrollOnAdd = window.setTimeout(function () {\n\t\t\t\tvar isFF = component.isFF(),\n\t\t\t\t\tisOpen = component.getData('ltPropIsOpen');\n\n\t\t\t\tif (!isOpen) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (isFF && component.isBodyScrollable()) {\n\t\t\t\t\tcomponent.addProperScrollbar();\n\t\t\t\t}\n\t\t\t}, 0);\n        }\n\n        disconnectedCallback() {\n            var lyteNode = this.$node;\n            var component = lyteNode._dropdownComponent;\n\n            if (!component) {\n\t\t\t\treturn;\n\t\t\t}\n\n            window.clearTimeout(component._FFBodyScrollOnRemove);\n\n            component._FFBodyScrollOnRemove = window.setTimeout(function () {\n\t\t\t\tvar isFF = component.isFF(),\n\t\t\t\t\tisOpen = component.getData('ltPropIsOpen');\n\n\t\t\t\tif (!isOpen) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (isFF && !component.isBodyScrollable()) {\n\t\t\t\t\tcomponent.removeScrollbar();\n\t\t\t\t}\n\t\t\t}, 0);\n        }\n\n        attributeChangedCallback(attr, oldValue, newValue, namespace) {\n            var lyteNode = this.$node;\n            var cur = lyteNode, drp, component, type, sel, res,\n\t\t\t\tsrc = lyteNode.getAttribute('data-value'),\n\t\t\t\tattributeChanged;\n\n            if (oldValue === null && newValue !== null || oldValue !== null && newValue === null) {\n\t\t\t\tattributeChanged = true;\n\t\t\t}\n\n            if (!attributeChanged) {\n\t\t\t\treturn;\n\t\t\t}\n\n            if (attr == 'selected') {\n\t\t\t\tif (lyteNode.hasAttribute('selected')) {\n\n\t\t\t\t\tlyteNode.setAttribute('aria-selected', 'true');\n\n\t\t\t\t\tcur = window._lyteDropdown.traverse(cur, ['LYTE-DROP-BOX', 'BODY']);\n\n\t\t\t\t\tif (!cur || cur.tagName == 'BODY') {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tdrp = cur.origindd;\n\t\t\t\t\tif (!drp) {\n\t\t\t\t\t\tcur = window._lyteDropdown.traverse(cur, ['LYTE-DROPDOWN', 'BODY']);\n\t\t\t\t\t\tdrp = cur;\n\t\t\t\t\t}\n\n\t\t\t\t\tcomponent = drp.component;\n\n\t\t\t\t\tif (!component) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (component.getData('preventSel')) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttype = component.getData('ltPropType');\n\n\t\t\t\t\tif (type == 'multiple'\n\t\t\t\t\t\t|| type == 'multisearch'\n\t\t\t\t\t) {\n\t\t\t\t\t\tsel = component.getData('ltPropSelected');\n\t\t\t\t\t\tif ((sel && sel.length == 2) || !sel) {\n\t\t\t\t\t\t\tsel = JSON.stringify([src]);\n\t\t\t\t\t\t\t// not setting prev to true here\n\t\t\t\t\t\t\tcomponent.setData('ltPropSelected', sel);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tres = JSON.parse(sel);\n\t\t\t\t\t\t\tres.push(src);\n\t\t\t\t\t\t\t// not setting prev to true here\n\t\t\t\t\t\t\tcomponent.setData('ltPropSelected', JSON.stringify(res));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcomponent.setData('ltPropSelected', src);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlyteNode.setAttribute('aria-selected', 'false');\n\t\t\t\t}\n\t\t\t}\n        }\n    }\n\n    LyteDropItemCustomElements.register('lyte-drop-item');\n}\n\n\n\nwindow._lyteDropdown = {\n\t// When multiple dropdowns have multiple callbacks returning a promise, store the last dropdown\n\tlastDropdownWithAPromise: null,\n\n\t// Whether the dropdown should not be closed when the input is focused out\n\tpreventClose: false,\n\n\t// Current dropdown that was autoClosed\n\tautoClosed: null,\n\n\t// Whether a focus happened\n\tfocusOut: false,\n\n\tfocusableElementsSelector: 'input:not(:disabled), button:not(:disabled), [tabindex]:not([tabindex=\"-1\"]), textarea:not(:disabled), select:not(:disabled), a',\n\n\tshouldTrapFocus: function (comp) {\n\t\tvar dropdown = comp.$node,\n\t\t\tbox = dropdown.getDropBox(),\n\t\t\tfocusableElements = comp.getFocusableElements(),\n\t\t\tshouldTrapFocus = comp.getData('ltPropAllowFocusableElements') && focusableElements.length > 1;\n\n\t\treturn shouldTrapFocus;\n\t},\n\n\tloopIfBoundaryElements: function (comp, event) {\n\t\tvar focusableElements = comp.getFocusableElements(),\n\t\t\tlength = focusableElements.length,\n\t\t\tdropdown = comp.$node,\n\t\t\tactiveElement = document.activeElement;\n\n\t\tif (event.shiftKey && focusableElements[0] === activeElement) {\n\t\t\tevent.preventDefault();\n\t\t\tfocusableElements[length - 1].focus();\n\t\t}\n\n\t\tif (!event.shiftKey && focusableElements[length - 1] === activeElement) {\n\t\t\tevent.preventDefault();\n\t\t\tfocusableElements[0].focus();\n\t\t}\n\n\t},\n\n\tcloseOtherDropdowns: function (currentDropdown) {\n\t\tvar openDropdowns = window._lyteUiUtils.getVisibleDropdowns() || [];\n\n\t\tfor (var i = 0; i < openDropdowns.length; i++) {\n\t\t\tif (openDropdowns[i] !== currentDropdown) {\n\t\t\t\topenDropdowns[i].close();\n\t\t\t}\n\t\t}\n\t},\n\n\topenFocusedDropdown: function (keyCode) {\n\t\tvar dropdown = window._lyteDropdown.getDropdownWithFocusedInput(),\n\t\t\ttype, BACKSPACE = 8;\n\n\t\tif (keyCode == 27 || keyCode == 9 || !dropdown) {\n\t\t\treturn;\n\t\t}\n\n\t\ttype = (dropdown.ltProp('type') || '').toLowerCase();\n\n\t\tif (type === 'multisearch' && !dropdown.ltProp('isOpen')) {\n\t\t\tdropdown.open();\n\n\t\t\tif (keyCode === BACKSPACE) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t},\n\n\tgetDropdownFromItem: function (cur) {\n\t\tcur = window._lyteDropdown.traverse(cur, ['LYTE-DROP-BOX', 'BODY']);\n\n\t\tif (!cur || cur.tagName == 'BODY') {\n\t\t\treturn;\n\t\t}\n\n\t\tvar drp = cur.origindd;\n\n\t\tif (!drp) {\n\t\t\tcur = window._lyteDropdown.traverse(cur, ['LYTE-DROPDOWN', 'BODY']);\n\t\t\tdrp = cur;\n\t\t}\n\n\t\tvar component = drp.component;\n\n\t\treturn component;\n\t},\n\n\tgetDropdownWithFocusedInput: function () {\n\t\tvar activeElement = document.activeElement, dropdown;\n\n\t\tif (activeElement\n\t\t\t&& activeElement.nodeName.toLowerCase() === 'input'\n\t\t) {\n\t\t\tdropdown = window._lyteDropdown.traverse(activeElement, ['HTML', 'LYTE-DROPDOWN']);\n\t\t}\n\n\t\tif (dropdown && dropdown.nodeName.toLowerCase() === 'lyte-dropdown') {\n\t\t\treturn dropdown;\n\t\t}\n\n\t},\n\n\t/**\n\t * Gets the current visible dropbox from the body\n\t * This was added to fix a performance problem in CRM - kural's subform feature\n\t *\n\t *\n\t */\n\n\tgetVisibleDropbox: function () {\n\t\tvar childs = (document.body || {}).children || [],\n\t\t\ti = 0;\n\n\t\tfor (; i < childs.length; i++) {\n\t\t\tif (\n\t\t\t\tchilds[i].tagName === 'LYTE-DROP-BOX'\n\t\t\t\t&& window._lyteDropdown.isVisible(childs[i])\n\t\t\t) {\n\t\t\t\treturn childs[i];\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Check if the element is a scrollbar\n\t * @param {HTMLElement} element - the clicked element\n\t *\n\t */\n\n\tisScrollBar: function (element) {\n\t\treturn element\n\t\t\t&& (element.classList.contains('lyteScrollContainer') || element.classList.contains('lyteScrollDiv'));\n\t},\n\n\t/**\n\t * Checks if the dropdown is within the visible bounds\n\t * @param {Object} visibleBound - The visible bound of the scrollable element\n\t * @param {Object} dropBound - The dropdown's boundaries\n\t *\n\t */\n\n\tisInBounds: function (visibleBound, dropBound) {\n\t\treturn visibleBound.top < dropBound.top\n\t\t\t&& visibleBound.bottom > dropBound.bottom\n\t\t\t&& visibleBound.left < dropBound.left\n\t\t\t&& visibleBound.right > dropBound.right;\n\t},\n\n\t/**\n\t * This is going to construct the visible bound of the scrolling container\n\t * @param {object} - getBoundingClientRect of the element\n\t * @param {boolean} - If it is a boolean or not\n\t * @param {HTMLElement} - The current scrollable div\n\t *\n\t */\n\n\tbuildVisibleBounds: function (rect, isDoc, cur) {\n\t\tvar top = isDoc ? 0 : Math.max(rect.top, 0),\n\t\t\tleft = isDoc ? 0 : Math.max(rect.left, 0),\n\t\t\tright = isDoc ? window.innerWidth : Math.min(window.innerWidth, rect.left + cur.offsetWidth),\n\t\t\tbottom = isDoc ? window.innerHeight : Math.min(window.innerHeight, rect.top + cur.offsetHeight);\n\n\t\treturn {\n\t\t\ttop: top,\n\t\t\tleft: left,\n\t\t\tright: right,\n\t\t\tbottom: bottom\n\t\t};\n\t},\n\n\t/**\n\t * This is used to find the current auto closed dropdown\n\t * @param {HTMLElement} cur - The cur scrolled element\n\t *\n\t */\n\n\topenAutoClosedDropdown: function (cur, event) {\n\t\tvar isDocument = cur === document,\n\t\t\tscrollRect, visibleBound,\n\t\t\tdrop = window._lyteDropdown.autoClosed, comp, link;\n\n\t\tif (!drop) {\n\t\t\treturn;\n\t\t}\n\n\t\tscrollRect = isDocument ? {} : cur.getBoundingClientRect();\n\t\tvisibleBound = window._lyteDropdown.buildVisibleBounds(scrollRect, isDocument, cur)\n\n\t\tcomp = drop.component,\n\t\t\tlink = comp.childComp;\n\n\t\tif (drop\n\t\t\t&& cur.contains(drop)\n\t\t\t&& window._lyteDropdown.isInBounds(visibleBound, drop.getBoundingClientRect())\n\n\t\t\t// safety\n\t\t\t&& link.classList.contains('lyteDropdownHidden')\n\t\t) {\n\t\t\tcomp.beforeScrollOpen(event);\n\t\t\tdrop.toggle();\n\t\t\twindow._lyteDropdown.autoClosed = null;\n\t\t}\n\t},\n\n\t/**\n\t * This is used to determine whether an object is empty or not\n\t * @param {Object} obj - The object to be checked\n\t *\n\t */\n\n\tisEmpty: function (obj) {\n\t\tfor (var key in obj) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t/**\n\t * This is going to build the boundary parameter for a particular dropdown instance\n\t * @param {Component} comp - The lyte-dropdown component object\n\t *\n\t */\n\n\tbuildBounds: function (comp) {\n\t\tvar bound = comp.getData('ltPropBoundary') || {},\n\t\t\tscope = comp.getData('ltPropScope'), parent, boundingRects;\n\n\t\tif (scope !== 'window') {\n\t\t\tparent = $L(comp.$node).closest(scope).get(0);\n\n\t\t\tif (parent) {\n\t\t\t\tboundingRects = parent.getBoundingClientRect();\n\n\t\t\t\treturn {\n\t\t\t\t\tleft: Math.max(0, boundingRects.left),\n\t\t\t\t\ttop: Math.max(0, boundingRects.top),\n\t\t\t\t\tright: Math.min(window.innerWidth, boundingRects.right),\n\t\t\t\t\tbottom: Math.min(window.innerHeight, boundingRects.bottom)\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tleft: bound.left || 0,\n\t\t\tright: bound.right || window.innerWidth,\n\t\t\ttop: bound.top || 0,\n\t\t\tbottom: bound.bottom || window.innerHeight\n\t\t}\n\t},\n\n\t/**\n\t * This is going to traverse up the dom to check if the required tagNames are present\n\t * @param {Element} node - The element whose parents need to be traversed\n\t * @param {Array} arr - The set of tag names to check against\n\t *\n\t */\n\n\ttraverse: function (node, arr) {\n\t\twhile (node && !~arr.indexOf(node.tagName)) {\n\t\t\tnode = node.parentNode;\n\t\t}\n\n\t\treturn node;\n\t},\n\n\t/**\n\t * Find the next/previous element which is visible\n\t * @param {NodeList} elems - The set of all elements to test against\n\t * @param {integer} i - index from which we need to search\n\t * @param {boolean} forward - whether to move forward or backward\n\t *\n\t *\n\t */\n\n\tfind: function (elems, i, forward) {\n\t\tvar inc = forward ? 1 : -1,\n\t\t\tlen = elems.length;\n\n\t\tfor (\n\t\t\t;\n\t\t\tforward ?\n\t\t\t\ti < len\n\t\t\t\t: i > -1;\n\n\t\t\ti = i + inc\n\t\t) {\n\t\t\tif (window._lyteDropdown.isVisible(elems[i])\n\t\t\t\t&& elems[i].getAttribute('disabled') !== \"true\"\n\t\t\t) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn forward ? len : -1;\n\t},\n\n\t/**\n\t * This is going to check if the element is visible or not\n\t * @param {Element} item - The item to check against\n\t *\n\t */\n\n\tisVisible: function (item) {\n\t\treturn !!(item.offsetWidth || item.offsetHeight || item.getClientRects().length);\n\t},\n\n\t/**\n\t * Checks if the current target is an input within the dropdown and with no value\n\t * @param event - the keydown event\n\t *\n\t */\n\n\t// Initialize variables\n\tpressedCharacter: null,\n\n\tcheckDDtimeoutId: null,\n\n\tcachePreviousVal: {},\n\n\tisInput: function (event) {\n\t\t// There maybe a case when a dropdown might be opened on pressing on an input with toggle. When backspace is pressed\n\t\t// on that input the global event handler for keydown might misbehave by trying to remove the last item\n\t\t// Fix is to check if the input is present inside the open dropdown\n\t\tvar open = event.target;\n\n\t\topen = window._lyteDropdown.traverse(open, ['LYTE-DROPDOWN']);\n\n\t\tif (open\n\t\t\t&& event.target.tagName === 'INPUT'\n\t\t\t&& event.target.type === 'text'\n\t\t\t&& !event.target.value\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t/**\n\t * Unmark all nodes except the current components nodes\n\t *\n\t */\n\n\tunmark: function (comp) {\n\t\tvar nodes = document.querySelectorAll('.lyteDropMark'),\n\t\t\ti = 0, len = nodes.length, par;\n\n\t\tfor (; i < len; i++) {\n\t\t\t// This is stupid. Change it later.\n\t\t\t//nodes[ i ].classList.remove( 'lyteDropMark' );\n\t\t\tpar = comp ? window._lyteDropdown.findParent(nodes[i]) : undefined;\n\t\t\tpar && par == comp.$node ? undefined : nodes[i].classList.remove('lyteDropMark');\n\t\t}\n\t},\n\n\tfindParent: function (node) {\n\t\tnode = window._lyteDropdown.traverse(node, ['LYTE-DROPDOWN'])\n\n\t\treturn node;\n\t},\n\n\tgetActive: function () {\n\t\tvar node = document.querySelector('.lyteDropMark');\n\n\t\treturn window._lyteDropdown.findParent(node);\n\t}\n}\n\nif (!window._lyteUiUtils.registeredCustomElements['lyte-drop-group']) {\n    window._lyteUiUtils.registeredCustomElements['lyte-drop-group'] = true;\n\n    /**\n\t * @customElement lyte-drop-group\n\t */\n\n    class LyteDropGroupCustomElements extends LyteUiComponentComponentRegistry.CustomElements {\n        static options = {clone : {allCallbacks : false}};\n\n        lookups() {\n            return [{\n                component: LyteUiComponentComponentRegistry\n            }];\n        }\n\n        constructor() {\n            super();\n        }\n\n        static get observedAttributes() {\n            return ['label'];\n        }\n\n        attributeChangedCallback(attr, oldValue, newValue, namespace) {\n            var lyteNode = this.$node;\n            var node, value;\n\n            if (attr == 'label') {\n\t\t\t\tnode = lyteNode.querySelector('lyte-drop-label');\n\t\t\t\tvalue = lyteNode.getAttribute('label');\n\t\t\t\tif (node) {\n\t\t\t\t\tnode.textContent = value;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnode = document.createElement('lyte-drop-label');\n\t\t\t\t\tnode.textContent = value;\n\t\t\t\t\tlyteNode.insertBefore(node, lyteNode.children[0]);\n\t\t\t\t}\n\t\t\t}\n        }\n    }\n\n    LyteDropGroupCustomElements.register(\"lyte-drop-group\");\n}\n\n/**\n * @syntax nonYielded\n * <lyte-dropdown lt-prop-options='[{\"name\": \"Option 1\", \"value\": \"1\"}, {\"name\": \"Option 2\", \"value\": \"2\"}]' lt-prop-user-value=\"name\" lt-prop-system-value=\"value\"></lyte-dropdown>\n */\n\n/**\n * @syntax yielded\n * <lyte-dropdown>\n *     <template is=\"registerYield\" yield-name=\"yield\">\n *         <lyte-drop-button>\n *             Option 1\n *         </lyte-drop-button>\n *         <lyte-drop-box>\n *             <lyte-drop-body>\n *                 <lyte-drop-item data-value=\"1\">Option 1</lyte-drop-item>\n *                 <lyte-drop-item data-value=\"2\">Option 2</lyte-drop-item>\n *             </lyte-drop-body>\n *         </lyte-drop-box>\n *      </template>\n * </lyte-dropdown>\n */\n\n/**\n * @syntax\n * @attribute ltPropType=multiple\n * <lyte-dropdown lt-prop-selected='[\"1\"]' lt-prop-type=\"multiple\">\n *     <template is=\"registerYield\" yield-name=\"yield\">\n *         <lyte-drop-box>\n *             <lyte-drop-body>\n *                 <lyte-drop-item data-value=\"1\">Option 1</lyte-drop-item>\n *                 <lyte-drop-item data-value=\"2\">Option 2</lyte-drop-item>\n *             </lyte-drop-body>\n *         </lyte-drop-box>\n *      </template>\n * </lyte-dropdown>\n */\n\n/**\n * @syntax\n * @attribute ltPropType=multisearch\n * <lyte-dropdown lt-prop-selected='[\"1\"]' lt-prop-type=\"multisearch\">\n *     <template is=\"registerYield\" yield-name=\"yield\">\n *         <lyte-drop-box class=\"bodyContainer\">\n *             <lyte-drop-body>\n *                 <lyte-drop-item data-value=\"1\">Option 1</lyte-drop-item>\n *                 <lyte-drop-item data-value=\"2\">Option 2</lyte-drop-item>\n *             </lyte-drop-body>\n *         </lyte-drop-box>\n *      </template>\n * </lyte-dropdown>\n */\n\n\n\n\nexport { LyteDropdownComponent };\n\n\n\n\n","import './lyte-calendar.js';\nimport './lyte-wormhole.js';\nimport './lyte-dropdown.js';\nimport { prop } from \"@slyte/core\";\nimport { Component } from \"../component.js\";\nimport $L from \"@zoho/lyte-dom\";\n\n// import \"../../plugins/lyte-trapFocus.js\";\n\nwindow._lyteInput = function(evt) {\n    // var inputs = document.body.getElementsByTagName( 'lyte-input' );\n    var dateIp = window._lyteUiUtils.input, inputs = Object.keys( dateIp || {} )\n    for( var i = 0; i < inputs.length; i++ ){\n        // if( /date/i.test( inputs[ i ].ltProp( 'type' ) ) ){\n            var comp = dateIp[ inputs[ i ] ].component;\n            if( evt.type == \"click\" ){\n                comp.calenderClickHide.call( comp, evt );\n            } else {\n                comp.scrollFunc.call( comp, evt );\n            }\n        // }\n    }\n};\n\n/**\n * This component is used to get responses from user\n * @component lyte-input\n * @version 1.0.0\n * @dependency lyte-calendar\n *  /components/lyte-calendar.js\n *  /theme/compiledCSS/default/ltr/lyte-ui-calendar.css \n *  /plugins/lyte-moment.js\n * @dependency lyte-dropdown\n *  /components/lyte-dropdown.js\n *  /theme/compiledCSS/default/ltr/lyte-ui-dropdown.css\n * @dependency lyte-wormhole\n *  /components/lyte-wormhole.js\n * @utility focus,blur,click,select\n * @import lyte-dropdown\n * @condition ltPropType time,datetime\n * @ignoreMethods\n * @ignoreUtils\n * @ignoreProperties ltPropRemoveMultiple,ltPropYield,ltPropOptions,ltPropUserValue,ltPropSystemValue,ltPropIconClass,ltPropPlaceholder,ltPropNoResult,ltPropMaxCount,ltPropAjaxRequest,ltPropDisplayValue,ltPropDisabledList,ltPropTooltip,ltPropBoxClass,ltPropIsOpen,ltPropFixPositionOnOpen\n * @import lyte-calendar\n * @condition ltPropType date,datetime\n * @ignoreMethods\n * @ignoreUtils\n */\n\nclass LyteInputComponent extends Component {\n    constructor() {\n        super();\n    }\n\n    init(frm_obs) { \n        var data = this.data, type = data.ltPropType;\n          if( type == 'time' || type == \"datetime\" ){\n            this._prevent = true\n            this.timeInValChange();\n            this.startEndTimeObs();\n            delete this._prevent;\n            if( type.indexOf( 'time' ) != -1 && data.ltPropDropdown ){\n                this.dropdownConstruct();\n                if( type == \"time\" ) {\n                    // data.ltPropDefaultTime = data.ltPropDefaultTime || data.ltPropValue;\n                    this.setData( 'ltPropDefaultTime', data.ltPropDefaultTime || data.ltPropValue );\n                }\n            }\n          } \n          if( type == 'date' || type == \"datetime\" ){\n            if( type == 'date' ) {\n                // data.ltPropCurrentDate = data.ltPropCurrentDate || data.ltPropValue; \n                this.setData( 'ltPropCurrentDate', data.ltPropCurrentDate || data.ltPropValue );\n            } \n\n            if( data.ltPropAria ){\n                this.setData( 'randomId', \"lyteInput_\" + parseInt( Math.random() * 1e6 ) );\n                this.$addon.objectUtils( data.ltPropCalendarProperties, 'add', 'disableNavigation', false );\n            }\n\n            this.dateRegexFind();\n          }\n\n          if( !frm_obs ){\n            this.$node.classList.add('lyteInput');\n            this.$node.classList.add('horizontal');\n          }\n\n          if( this.getMethods( 'beforeRender' ) ) {\n           /**\n            * @method beforeRender\n            * @version 1.0.1\n            */\n                this.executeMethod( 'beforeRender', this.$node );\n            }\n    }\n\n    englishDate() {\n        if( $L.moment && this.data ){\n            var format = this.data.ltPropFormat,\n            date = this.data.ltPropCurrentDate,\n            final = '';\n\n            if( date ){\n                final = $L.moment( date, format, { i18n : true } ).format( format );\n            } \n            this.setData( 'ltPropConvertedDate', final );\n        }\n    }\n\n    englishTime() {\n        if( $L.moment && this.data ){\n            var final = this.data.ltPropDefaultTime;\n\n            if( this.data.ltPropTimeFormat == 12 ){\n                var format = 'hh:mm A';\n                final = $L.moment( final, format, { i18n : true } ).format( format );\n            }\n            this.setData( 'ltPropConvertedTime', final );\n        }\n    }\n\n    didConnect() {\n           var type = this.data.ltPropType/*, divIdInput= this.$node, lyteLabelDiv= this.$node.querySelector( '.lyteLabel' ),lyteFieldDiv= this.$node.querySelector( '.lyteField' )*/; \n           if( type == 'date' || type == \"datetime\" )\n                { \n                    window._lyteUiUtils.input = window._lyteUiUtils.input || {};\n                    this.$node._random = 'LyteInput' + Date.now();\n                    window._lyteUiUtils.input[ this.$node._random ] = this.$node;\n                    this.englishDate();\n                }   \n            if(type == 'time' || type == \"datetime\" ){\n                if(this.getData('ltPropDropdown')){\n                    var drop = this.dropdown = this.$node.querySelector( 'lyte-dropdown' );\n                    this.dropbox =  drop.component.childComp ? drop.component.childComp : drop.querySelector( 'lyte-drop-box' );\n                    drop.element = this.$node.querySelectorAll( 'input' )[ type == 'datetime' ? 1 : 0 ];\n\n                    if( this.data.ltPropDropdownShow ){\n                        drop.resetPosition();\n                    }\n\n                }\n                this.englishTime();\n            }\n            if(type == 'time' || type == 'date' || type == \"datetime\"){\n                if(this.getData('ltPropWheel')){\n                    var func = this.handleWheel.bind(this);\n                    this.setData('eventListeners.timeWheel', func);\n                    this.$node.addEventListener('wheel', func);\n                }\n                this._manualset = true\n                if( type == \"time\" ){\n                    this.setData( 'ltPropValue', this.data.ltPropDefaultTime );\n                } else if( type == \"date\" ) {\n                    this.setData( 'ltPropValue', this.data.ltPropCurrentDate );\n                } \n                delete this._manualset;\n            }  \n            type = type == \"textarea\" ? \"textarea\" : 'input';  \n              [ 'focus', 'blur', 'click', 'select' ].forEach( function( item ){\n                    this.$node[ item ] = function( arg ){\n                      this.$node.querySelector( type )[item]( arg );\n                    }.bind( this )      \n              }.bind( this ) )                      \n            if(this.getMethods('afterRender')){\n               /**\n                * @method afterRender\n                * @version 1.0.1\n                */                \n                this.executeMethod('afterRender', this.$node);\n            }\n            $L.fastdom.measure( function(){\n                this._dir = window._lyteUiUtils.getRTL();\n                if( this._dir ) {\n                    $L.fastdom.mutate( function(){\n                        this.$node.classList.add( 'lyteRTL' );\n                        if( this.$node.calendarDiv ) {\n                            this.$node.calendarDiv.classList.add( 'lyteRTL' );\n                        }\n                    }.bind( this ) )\n                }   \n            }.bind( this ) );\n    }\n\n    didDestroy(frm_obs) {\n        if( !frm_obs && this.$node.calendarComp ){\n            this.$node.calendarComp.remove();\n            delete this.$node.calendarComp; \n            delete this.$node.calendarDiv;\n            delete this._assCalendar;\n            delete this.$node.revertToSelected;\n        }\n        var evt = this.getData('eventListeners'), type = this.getData('ltPropType');\n        // if(type == 'date' || type == \"datetime\" ){\n            var __input = window._lyteUiUtils.input || {};\n            delete __input[ this.$node._random ];\n        // }\n        // if(type == 'time' || type == \"datetime\" ){\n            delete this.dropdown; delete this.dropbox;\n        // }\n        if(evt.hasOwnProperty('mouseup')){\n            document.removeEventListener('mouseup', evt.mouseup);\n        }   \n    }\n\n    rtlfunc(lft, bcr, ww) {\n        if( this._dir ) {\n            if( bcr ) {\n                if( lft == 'left' ) {\n                    return ww - bcr.right;\n                } else if( lft == 'clientX' ) {\n                    return ww - bcr.clientX\n                } else if( lft == 'offsetLeft' ) {\n                    return ww - bcr.width - bcr.offsetLeft;\n                }\n                return ww - bcr.left;\n            } else if( lft == 'left' ) {\n                return 'right';\n            } \n        }\n        return bcr ? bcr[ lft ] : 'left';\n    }\n\n    calenderClickHide(event) {\n        if( !this.data.ltPropBindToBody ){\n            return\n        }\n        var calendarComp = this.$node.calendarDiv, tgt = event.target.correspondingElement || event.target;\n        if( calendarComp.classList.contains( 'lyteCalendarHidden' ) ){\n            return;\n        }\n        if( tgt && [ \"LYTE-DROP-BOX\", \"LYTE-DROP-ITEM\", \"LYTE-DROP-BODY\" ].indexOf( tgt.tagName ) != -1 ) {\n            while( tgt.tagName != \"LYTE-DROP-BOX\" && tgt.tagName != \"BODY\" ) {\n                tgt = tgt.parentNode;\n            }\n            if( tgt.tagName == \"LYTE-DROP-BOX\" ) {\n                tgt = tgt.origindd\n            }\n        }\n\n        var is_contains_target = this.data.ltPropAria ? $L( tgt ).hasClass( 'lyteInputCalendarIcon' ) : this.$node.contains( tgt ),\n        is_target_is_calendar = calendarComp.contains( tgt );\n\n        if( !is_contains_target && !is_target_is_calendar ) {         \n            this._hideCalendar();\n        } else if( tgt && /*!tgt.classList.contains( 'lyteCalDateSpan' ) && !tgt.classList.contains( 'lyteCalCdate' ) &&*/ calendarComp.contains( tgt ) ) {\n            this._byManual = true;\n            this.$node.focus();\n            delete this._byManual;\n        }\n    }\n\n    scrollFunc(event) {\n        if( event && event.type == 'resize' && window._lyteUiUtils.isMobile ) {\n            return;\n        }\n        var thisCalendar = this.$node.calendarDiv;\n         $L.fastdom.mutate(function(){\n            event && event.type == \"orientationchange\" ? setTimeout( this.setCss.bind( this ), 500 ) : this.setCss();\n             $L.fastdom.measure(function(){\n                var boundary = this.data.ltPropBoundary, input = this.$node.getBoundingClientRect(), wwidth = window.innerWidth;\n                if(thisCalendar && event && event.type == 'scroll' && !thisCalendar.classList.contains('lyteCalendarHidden')){\n                    if((boundary.hasOwnProperty('left') ? ( this.rtlfunc.call( this, 'left', input, wwidth ) < boundary.left) : false) || (boundary.hasOwnProperty('right') ? ( this.rtlfunc.call( this, 'right', input, wwidth ) > boundary.right) : false)  || (boundary.hasOwnProperty('top') ? (input.top < boundary.top) : false)  || (boundary.hasOwnProperty('bottom') ? (input.bottom > boundary.bottom) : false))      \n                        {  \n\n                            this._hideCalendar( true );                        }\n                 } else if( this._closedbyscrl ){\n                    if( ( boundary.left != undefined ? ( this.rtlfunc.call( this, 'left', input, wwidth ) >= boundary.left ) : true ) && ( boundary.right != undefined ? ( this.rtlfunc.call( this, 'right', input, wwidth ) <= boundary.right ) : true )  && ( boundary.top != undefined ? (input.top >= boundary.top) : true )  && (boundary.bottom != undefined ? ( input.bottom <= boundary.bottom ) : true ) ){\n                        this._byManual = true;\n                        this.$node.focus();\n                        delete this._byManual;\n                        this.showCalendar( {}, this.$node.querySelector( 'input' ) );\n                        delete this._closedbyscrl;\n                    }    \n                 }\n             }.bind(this))  \n         }.bind(this))\n    }\n\n    rsizefun(evt) {\n        var isTch = evt.touches,\n        ev = evt,\n        cb = \"onResizeStart\",\n        __this = this,\n        __data = __this.data,\n        $node = __this.$node;\n\n        if( isTch && isTch.length > 1 ){\n            return;\n        } else if( isTch ){\n            ev = isTch[ 0 ];\n        }\n\n        if( __this.getMethods( cb ) && __this.executeMethod( cb, evt, $node ) == false ){\n            return;\n        }\n\n        var tagName = 'getElementsByTagName',\n        textarea = $node[ tagName ]( 'textarea' )[ 0 ],\n        resize = __data.ltPropTextAreaResize || {},\n        __doc = document,\n        __add = 'addEventListener',\n        label = $node[ tagName ]( 'label' )[ 0 ],\n        gbcr = \"getBoundingClientRect\",\n        label_bcr = label ? label[ gbcr ]() : {},\n        bcr = textarea[ gbcr ](),\n        this_bcr = $node[ gbcr ](),\n        comp_style = window.getComputedStyle( textarea ),\n        paddingLeft = parseFloat( comp_style.paddingLeft ),\n        fn = function( __min, prop ){\n            var __value = comp_style[ __min ];\n\n            if( /%$/.test( __value ) ){\n                return this_bcr[ prop ] * parseFloat( __value ) / 100;\n            } else {\n                return parseFloat( __value );\n            }\n\n        },\n        __obj = {},\n        __obj1 = {},\n        __obj2 = {},\n        __obj3 = {};\n\n        if( resize.horizontal ){\n            __this.__minwidth = fn( \"minWidth\", 'width' );\n            __this.__maxwidth = fn( \"maxWidth\", 'width' );\n\n            __obj.width = this_bcr.width;\n            __obj1.width = bcr.width;\n            __obj2.width = __obj2.minWidth = label_bcr.width;\n            __obj3.width = __obj3.minWidth = \"auto\";\n        }\n\n        if( resize.vertical ){\n            __this.__minheight = fn( \"minHeight\", 'height' );\n            __this.__maxheight = fn( \"maxHeight\", 'height' );\n\n            __obj.height = this_bcr.height;\n            __obj1.height = bcr.height;\n            __obj2.height = label_bcr.height;\n            __obj3.height = \"auto\";\n        }\n\n\n        __this.__clientX = ev.clientX;\n        __this.__clientY = ev.clientY;\n\n        __doc[ __add ]( isTch ? 'touchmove' : \"mousemove\", __this.__rmove = __this.textareaResize.bind( __this ), true );\n        __doc[ __add ]( isTch ? 'touchend' : 'mouseup', __this.__rend = __this.mouseup.bind( __this ), true );\n\n        $L( $node ).addClass( 'resizeStart' ).css( __obj );\n        $L( textarea ).css( __obj1 ).parent().css( __obj3 );\n        $L( label ).css( __obj2 );\n\n        evt.preventDefault();\n        return false;\n     }\n\n    mouseup(evt) {\n       var __doc = document,\n       __remove = \"removeEventListener\",\n       isTch = evt.type == \"touchend\",\n       cb = \"onResizeEnd\",\n       __this = this,\n       $node = __this.$node;\n\n        $L( $node ).removeClass( 'resizeStart' );\n\n       __doc[ __remove ]( isTch ? \"touchmove\" : \"mousemove\", __this.__rmove, true );\n       __doc[ __remove ]( isTch ? \"touchend\" : \"mouseup\", __this.__rend, true );\n\n       __this.getMethods( cb ) && __this.executeMethod( cb, evt, __this._resize_move, $node );\n\n       [ '__minwidth', '__minheight', '__maxheight', '__maxwidth', '__clientY', '__clientX', '_resize_move', '__remove', '__rend' ].forEach( function( item ){\n           delete __this[ item ];\n       });\n    }\n\n    textareaResize(evt) {\n       var __this = this,\n       __data = __this.data,\n       isTch = evt.touches,\n       ev = evt;\n\n       if( isTch && isTch.length > 1 ){\n           return;\n       } else if( isTch ){\n           ev = isTch[ 0 ];\n           evt.preventDefault();\n       }\n\n       __this._resize_move = true;\n\n       var xInc = -( __this.__clientX - ( __this.__clientX = ev.clientX ) ) * ( this._dir ? -1 : 1 ) ,\n       yInc = -( __this.__clientY - ( __this.__clientY = ev.clientY ) ),\n       __obj = {},\n       __obj1 = {},\n       __setData = {},\n       resize = __data.ltPropTextAreaResize || {},\n       textarea = __this.$node.getElementsByTagName( 'textarea' )[ 0 ],\n       $node = __this.$node,\n       fn = function( prop, __min, __max, inc ){\n           var current = parseFloat( textarea.style[ prop ] ),\n           __new = current + inc;\n\n           if( !isNaN( __min ) ){\n               if( __min > __new ){\n                   inc = __min - current;\n                   __new = current + inc;\n               }\n           }\n\n           if( !isNaN( __max ) ){\n               if( __max < __new ){\n                   inc = __max - current;\n               }\n           }\n\n           __obj[ prop ] = current + inc;\n           __obj1[ prop ] = parseFloat( $node.style[ prop ] ) + inc;\n       };\n\n       if( resize.horizontal ){\n          fn( 'width', __this.__minwidth, __this.__maxwidth, xInc );\n          __setData.ltPropWidth = __obj1.width + 'px';\n       }\n\n       if( resize.vertical ){\n          fn( 'height', __this.__minheight, __this.__maxheight, yInc );\n          __setData.ltPropHeight = __obj.height + 'px';\n       }\n\n       $L( $node ).css( __obj1 );\n       $L( textarea ).css( __obj );\n\n       __this._prevent = true;\n       __this.setData( __setData );\n       delete __this._prevent;\n\n    }\n\n    heightFunc() {\n        if( !this._prevent ){\n            $L( 'input,textarea', this.$node ).eq( 0 ).css( 'height', this.getData( 'ltPropHeight' ) ); \n        }\n     }\n\n    widthfun() {\n        if( !this._prevent ){\n            this.$node.style.width = this.getData( 'ltPropWidth' );\n        }\n    }\n\n    appearanceFun() {\n        var type = this.data.ltPropType, \n        $node = $L( this.$node );\n\n        if( this.getData( 'ltPropAppearance' ) == 'box' ) {\n            if(type =='search') {\n                $node.find( '.lyteField' ).addClass( 'lyteInputBoxSearch' );\n            }\n\n            $node.addClass( 'lyteInputBox' ).removeClass( 'lyteInput' );\n        } else {\n            if(type =='search') {\n                $node.find( '.lyteField' ).removeClass( 'lyteInputBoxSearch' );\n            }\n\n            $node.addClass( 'lyteInput' ).removeClass( 'lyteInputBox' );\n        }       \n    }\n\n    directionfun() {\n        var $node = $L( this.$node );\n\n        if( this.data.ltPropDirection == 'vertical' ){\n            $node.addClass( 'vertical' ).removeClass( 'horizontal' );\n        } else {\n            $node.removeClass( 'vertical' ).addClass( 'horizontal' );\n        }\n    }\n\n    data() {\n\n        var default_values = window._lyteUiUtils.getDefault( 'lyte-input' ),\n        __boolean = \"boolean\",\n        __string = \"string\",\n        __number = \"number\",\n        __object = \"object\",\n        __array = \"array\",\n        __value;\n\n        return {\n           /**\n            * @componentProperty {boolean} ltPropDisabled=false\n            * @version 1.0.0\n            */            \n            ltPropDisabled : prop( __boolean, { default : false }),\n           /**\n            * @componentProperty {boolean} ltPropAutofocus=false\n            * @version 1.0.0\n            */            \n            ltPropAutofocus : prop( __boolean, { default : false }),\n           /**\n            * @componentProperty {on | off} ltPropAutocomplete=off\n            * @version 1.0.0\n            */            \n            ltPropAutocomplete : prop( __string, { default : default_values.autocomplete || 'off' }),\n           /**\n            * @componentProperty {number} ltPropMaxlength\n            * @version 1.0.0\n            */            \n            ltPropMaxlength : prop( __number, { default : default_values.maxlength }),\n           /**\n            * @componentProperty {string} ltPropName=''\n            * @version 1.0.0\n            */            \n            ltPropName : prop( __string, { default : '' }),\n           /**\n            * @componentProperty {string} ltPropPlaceholder=''\n            * @version 1.0.0\n            */            \n            ltPropPlaceholder : prop( __string, { default : '' }),\n           /**\n            * @componentProperty {boolean} ltPropReadonly=false\n            * @version 1.0.0\n            */            \n            ltPropReadonly : prop( __boolean, { default : false }),\n           /**\n            * @componentProperty {string} ltPropValue=''\n            * @version 1.0.0\n            */            \n            ltPropValue : prop( __string, { default : '' }),\n           /**\n            * @componentProperty {string} ltPropWidth=''\n            * @version 1.0.0\n            */            \n            ltPropWidth : prop( __string, { default : default_values.width || '' }),\n           /**\n            * @componentProperty {string} ltPropTabIndex=0\n            * @version 1.0.0\n            */            \n            ltPropTabIndex : prop( __string, { default : default_values.tabIndex || '0' }),\n           /**\n            * @componentProperty {text | number | password | date | time | textarea | datetime} ltPropType=text\n            * @version 1.0.0\n            */            \n            ltPropType : prop( __string, { default : '' }),\n           /**\n            * @componentProperty {flat | box} ltPropAppearance=flat\n            * @version 1.0.0\n            */            \n            ltPropAppearance : prop( __string, { default : default_values.appearance || '' }),\n           /**\n            * @componentProperty {vertical | horizontal} ltPropDirection=vertical\n            * @version 1.0.0\n            */            \n            ltPropDirection : prop( __string, { default : default_values.direction || 'vertical' }),\n           /**\n            * @componentProperty {string} ltPropLabel=''\n            * @version 1.0.0\n            */            \n            ltPropLabel : prop( __string, { default : '' }),\n           /**\n            * @componentProperty {string} ltPropId=''\n            * @version 1.0.0\n            */            \n            ltPropId : prop( __string, { default : '' }),\n           /**\n            * @componentProperty {string} ltPropClass=''\n            * @version 1.0.0\n            */            \n            ltPropClass : prop( __string, { default : default_values.class || '' }),\n           /**\n            * @componentProperty {string} ltPropStyle=''\n            * @version 1.0.0\n            */            \n            ltPropStyle : prop( __string, { default : default_values.style || '' }),\n           /**\n            * @componentProperty {string} ltPropWrapperStyle=''\n            * @version 1.0.0\n            */            \n            ltPropWrapperStyle : prop( __string, { default : default_values.wrapperStyle || '' }),\n           /**\n            * @componentProperty {string} ltPropHeight=''\n            * @version 1.0.0\n            */            \n            ltPropHeight : prop( __string, { default : default_values.height || '' }),\n           /**\n            * @componentProperty {string} ltPropPattern='.+'\n            * @version 1.0.2\n            */            \n            ltPropPattern : prop( __string, { default : default_values.pattern || '.+' }),\n           /**\n            * @componentProperty {string} ltPropInputTitle=''\n            * @version 1.0.2\n            */            \n            ltPropInputTitle : prop( __string, { default : '' }),\n\n            // data for textarea\n           /**\n            * @componentProperty {number} ltPropRows\n            * @version 1.0.0\n            * @condition ltPropType textarea\n            */            \n            ltPropRows : prop( __number, { default : void 0 }),\n           /**\n            * @componentProperty {number} ltPropCols\n            * @version 1.0.0\n            * @condition ltPropType textarea\n            */            \n            ltPropCols : prop( __number, { default : void 0 }),\n            /**\n             * @typedef {object} inputResize\n             * @property {boolean} vertical=true\n             * @property {boolean} horizontal=true\n             */\n\n            /**\n             * @componentProperty {inputResize} ltPropTextAreaResize\n             * @version 1.0.0\n             * @condition ltPropType textarea\n             */            \n            ltPropTextAreaResize : prop( __object, { default : default_values.textAreaResize || { vertical : true, horizontal : true } }),\n\n            // data for number\n           /**\n            * @componentProperty {number} ltPropMax\n            * @version 1.0.0\n            * @condition ltPropType number\n            */            \n            ltPropMax : prop( __number, { default : void 0 }),  \n           /**\n            * @componentProperty {number} ltPropMin\n            * @version 1.0.0\n            * @condition ltPropType number\n            */                      \n            ltPropMin : prop( __number, { default : void 0 }),\n           /**\n            * @componentProperty {number} ltPropStep=1\n            * @version 1.0.0\n            * @condition ltPropType number\n            */                        \n            ltPropStep : prop( __number ,{ default : default_values.step || 1 }),\n\n            // data for time\n           /**\n            * @componentProperty {12 | 24} ltPropTimeFormat=12\n            * @version 1.0.0\n            * @condition ltPropType number\n            */            \n            ltPropTimeFormat : prop( __number, { default : default_values.timeFormat || 12 }),\n           /**\n            * @componentProperty {number} ltPropHourInterval=1\n            * @version 1.0.0\n            * @condition ltPropType time,datetime\n            */            \n            ltPropHourInterval : prop( __number, { default : default_values.hourInterval || 1 }),\n           /**\n            * @componentProperty {string} ltPropDefaultTime=''\n            * @version 1.0.0\n            * @condition ltPropType time,datetime\n            */            \n            ltPropDefaultTime : prop( __string, { default : '' }),\n           /**\n            * @componentProperty {number} ltPropMinuteInterval=30\n            * @version 1.0.0\n            * @condition ltPropType time,datetime\n            */            \n            ltPropMinuteInterval : prop( __number, { default : default_values.minuteInterval || 30 }),\n           /**\n            * @componentProperty {boolean} ltPropDropdown=false\n            * @version 1.0.0\n            * @condition ltPropType time,datetime\n            */            \n            ltPropDropdown : prop( __boolean, { default : default_values.dropdown || false }),\n           /**\n            * @componentProperty {boolean} ltPropShowInterval=false\n            * @version 1.0.0\n            * @condition ltPropType time,datetime\n            */            \n             ltPropShowInterval : prop( __boolean, { default : default_values.showInterval || false }),\n           /**\n            * @componentProperty {string} ltPropStartTime=''\n            * @version 1.0.0\n            * @condition ltPropType time,datetime\n            */\n            ltPropStartTime : prop( __string, { default : default_values.startTime || '' }),\n           /**\n            * @componentProperty {string} ltPropEndTime=''\n            * @version 1.0.0\n            * @condition ltPropType time,datetime\n            */\n            ltPropEndTime : prop( __string, { default : default_values.endTime || '' }),\n             /**\n            * @componentProperty {boolean} ltPropConvertToNearest=false\n            * @version 2.2.14\n            * @condition ltPropType time,datetime\n            */\n            ltPropConvertToNearest : prop( __boolean, { default : default_values.convertToNearest || false }),\n             /**\n            * @componentProperty {boolean} ltPropValidateOnBlur=false\n            * @version 2.2.14\n            * @condition ltPropType time,datetime\n            */\n            ltPropValidateOnBlur : prop( __boolean, { default : default_values.validateOnBlur || false }),\n\n            // data for calendar\n            ltPropFillRows : prop( __boolean, { default : ( __value = default_values.fillRows ) == void 0 ? true : default_values }),\n            ltPropNumberOfRows : prop( __number, { default : default_values.numberOfRows || 6 }),\n            ltPropMinDate : prop( __string, { default : \"\" }),\n            ltPropMaxDate : prop( __string, { default : \"\" }),\n            ltPropStartWeekDay : prop( __number, { default : default_values.startWeekDay || 1 } ),\n            ltPropMonthHeaderFormat : prop( __string, { default: default_values.monthHeaderFormat || 'MMMM YYYY' } ),\n            daysOfWeek : prop( __array, { default : ['Sun','Mon','Tue','Wed','Thu','Fri','Sat' ] } ),\n            ltPropYear : prop( __boolean, { default : ( __value = default_values.year ) == void 0 ? true : __value } ),\n            ltPropFormat : prop( __string, { default : default_values.format || \"MM/DD/YYYY\" }),\n            viewDate : prop( __object, { default : {} }),\n            ltPropStartDate : prop( __string, { default : '' }),\n            ltPropEndDate : prop( __string, { default : ''}),\n            ltPropCurrentDate : prop( __string, { default : ''}),\n            /**\n            * @componentProperty {boolean} ltPropBindToBody=true\n            * @version 2.1.0\n            * @condition ltPropType time,date,datetime\n            */\n            ltPropBindToBody : prop( __boolean, { default : ( __value = default_values.bindToBody ) == void 0 ? true : __value }),\n           /**\n            * @componentProperty {string} ltPropCalendarClass=''\n            * @version 2.1.0\n            * @condition ltPropType date,datetime\n            */\n            ltPropCalendarClass : prop( __string, { default : default_values.calendarClass || \"\" }),\n            ltPropHeaderType : prop( __string, { default : default_values.headerType || \"default\" }),\n\n            // data for dropdown\n           /**\n            * @componentProperty {boolean} ltPropDropdownDisabled=false\n            * @version 1.0.2\n            * @condition ltPropType time,datetime\n            */\n            ltPropDropdownDisabled : prop( __boolean, { default : false}),\n           /**\n            * @componentProperty {boolean} ltPropDropdownShow=false\n            * @version 1.0.2\n            * @condition ltPropType time,datetime\n            */\n            ltPropDropdownShow : prop( __boolean, { default : false}),\n           /**\n            * @componentProperty {boolean} ltPropDropdownCallout=false\n            * @version 2.0.0\n            * @condition ltPropType time,datetime\n            */\n            ltPropDropdownCallout : prop( __boolean, { default : false }),\n           /**\n            * @componentProperty {boolean} ltPropDropdownFreeze=false\n            * @version 1.0.2\n            * @condition ltPropType time,datetime\n            */\n            ltPropDropdownFreeze : prop( __boolean, { default : ( __value = default_values.dropdownFreeze ) == void 0 ? false : __value }),\n           /**\n            * @componentProperty {string} ltPropDropdownId=''\n            * @version 2.2.2\n            * @condition ltPropType time,datetime\n            */\n            ltPropDropdownId : prop( __string, { default : '' }),\n           /**\n            * @componentProperty {string} ltPropDropdownClass=''\n            * @version 2.2.2\n            * @condition ltPropType time,datetime\n            */\n            ltPropDropdownClass : prop( __string, { default : default_values.dropdownClass || '' }),\n\n            // for dropdown and calendar\n            ltPropPosition : prop( __string, { default : default_values.position || 'down'}),\n            ltPropBoundary : prop( __object, { default : default_values.boundary || {} }),\n\n            // for date and time\n            /**\n            * @componentProperty {boolean} ltPropWheel=false\n            * @version 2.0.0\n            * @condition ltPropType time,datetime,date\n            */\n            ltPropWheel : prop( __boolean, { default : default_values.wheel || false } ),\n           /**\n            * @componentProperty {boolean} ltPropYield=false\n            * @version 1.0.2\n            * @condition ltPropType time,datetime,date\n            */\n            ltPropYield : prop( __boolean, { default : default_values.yield || false}),\n            ltPropAnimate : prop( __boolean, { default : default_values.animate || false }),\n           /**\n            * @componentProperty {boolean} ltPropPreventSelection=false\n            * @version 2.2.9\n            * @condition ltPropType date\n            */\n            ltPropPreventSelection : prop( __boolean, { default : default_values.preventSelection || false }),\n           /**\n            * @componentProperty {boolean} ltPropPreventKeys=false\n            * @version 2.2.11\n            * @condition ltPropType date\n            */\n            ltPropPreventKeys : prop( __boolean, { default : default_values.preventKeys || false }),\n           /**\n            * @componentProperty {number} ltPropUpdateDelay=250\n            * @version 2.0.0\n            */\n            ltPropUpdateDelay : prop( __number, { default : default_values.hasOwnProperty( 'updateDelay' ) ? default_values.updateDelay : 250 }),\n           /**\n            * @componentProperty {boolean} ltPropAutoUpdate=true\n            * @version 1.0.2\n            * @default true\n            */\n            ltPropAutoUpdate : prop( __boolean, { default : ( __value = default_values.autoUpdate ) == void 0 ? true : __value }),\n           /**\n            * @componentProperty {number} ltPropCallbackDelay=0\n            * @version 2.2.8\n            */\n            ltPropCallbackDelay : prop( __number, { default : default_values.hasOwnProperty( 'callbackDelay' ) ? default_values.callbackDelay : 0 }),\n           /**\n            * @componentProperty {boolean} ltPropCloseIcon=false\n            * @version 2.0.0\n            * @condition ltPropType date,text,password,number\n            */\n            ltPropCloseIcon : prop( __boolean, { default : default_values.closeIcon || false }),\n\n            // datetime type\n            /**\n             * @experimental ltPropTimePlaceholder\n             */\n            ltPropTimePlaceholder : prop( 'string', { default : \"\" }),\n\n            ltPropCommonPlaceholder : prop( 'string', { default : '' }),\n            /**\n             * @experimental ltPropTimeClass\n             */\n            ltPropTimeClass : prop( __string, { default : default_values.timeClass || \"\" }),\n\n            // aria\n           /**\n            * @componentProperty {boolean} ltPropAria=false\n            * @version 3.1.0\n            */\n            ltPropAria : prop( __boolean, { default : default_values.aria || false }),\n           /**\n            * @componentProperty {object} ltPropAriaAttributes\n            * @version 3.1.0\n            * @default {}\n            */\n            ltPropAriaAttributes : prop( __object, { default : default_values.ariaAttributes || {}, watch : true }),\n\n            ltPropTimeAriaAttributes : prop( __object, { default : default_values.timeAriaAttributes || {}, watch : true } ),\n           /**\n            * @componentProperty {boolean} ltPropFocus=false\n            * @version 3.2.0\n            */\n            ltPropFocus : prop( __boolean, { default : false }),\n           /**\n            * @componentProperty {object} ltPropCalendarProperties\n            * @version 2.2.20\n            * @default {}\n            * @component lyte-calendar\n            * @condition ltPropType date,datetime\n            */\n\n            ltPropCalendarProperties : prop( __object, { default : default_values.calendarProperties || { disableNavigation : true } }),\n           /**\n            * @componentProperty {object} ltPropDropdownProperties\n            * @version 2.2.20\n            * @default {}\n            * @component lyte-dropdown\n            * @condition ltPropType time,datetime\n            */\n\n            ltPropDropdownProperties : prop( __object, { default : default_values.dropdownProperties || {} }),\n\n           /**\n            * @componentProperty {string} ltPropScope=''\n            * @version 2.2.20\n            * @condition ltPropType date,datetime\n            */\n\n            ltPropScope : prop( __string, { default : default_values.scope || \"\" }),\n\n           /**\n            * @componentProperty {boolean} ltPropHeaderYield=false\n            * @version 3.20.0\n            * @condition ltPropType date,datetime\n            */\n\n            ltPropHeaderYield : prop( __boolean, { default : default_values.headerYield || false }),\n\n           /**\n            * @componentProperty {string} ltPropConvertedDate=''\n            * @version 3.20.0\n            * @condition ltPropType date,datetime\n            */\n\n            ltPropConvertedDate : prop( __string, { default : '' }),\n\n           /**\n            * @componentProperty {string} ltPropConvertedTime=''\n            * @version 3.20.0\n            * @condition ltPropType date,datetime\n            */\n\n            ltPropConvertedTime : prop( __string, { default : '' }),\n\n            /**\n            * @componentProperty {boolean} ltPropPreventDropdownNavigation=false\n            * @version 3.28.0\n            * @condition ltPropType date,datetime\n            */\n\n            ltPropPreventDropdownNavigation : prop( __boolean, { default : default_values.preventDropdownNavigation || false }),\n\n            /**\n            * @componentProperty {string} ltPropInputWrapperClass=\"\"\n            * @version 3.30.0\n            */\n            ltPropInputWrapperClass : prop( __string, { default : default_values.inputWrapperClass || '' }),\n\n            /**\n            * @componentProperty {string} ltPropWrapperClass=\"\"\n            * @version 3.32.0\n            */\n            ltPropWrapperClass : prop( __string, { default : default_values.wrapperClass || \"\" }),\n\n            ltPropTimezoneHandling : prop( __boolean, { default : default_values.timezoneHandling || false }),\n\n           /**\n            * @componentProperty {boolean} ltPropFocusAtEnd=false\n            * @version 3.86.0\n            */\n            ltPropFocusAtEnd : prop( __boolean, { default : false } ),\n\n            /**\n            * @componentProperty {boolean} ltPropPasswordIcon=false\n            * @version 3.91.0\n            * @condition ltPropType password\n            */\n            ltPropPasswordIcon : prop( __boolean, { default : false } ),\n            /**\n            * @componentProperty {boolean} ltPropPasswordVisibility=false\n            * @version 3.91.0\n            * @condition ltPropType password\n            */\n            ltPropPasswordVisibility : prop( __boolean, { default : false } ),\n            /**\n             * @typedef {object} passwordTooltip\n             * @property {string} show=\"Show password\"\n             * @property {string} hide=\"Hide password\"\n             */\n\n            /**\n            * @componentProperty {passwordTooltip} ltPropPasswordTooltip=false\n            * @version 3.91.0\n            * @condition ltPropType password\n            */\n            ltPropPasswordTooltip : prop( __object, { default : {\n                show : \"Show password\",\n                hide : \"Hide password\"\n            } } ),\n            /**\n            * @componentProperty {string} ltPropTooltipConfig='{\"position\" : \"bottom\"}'\n            * @version 3.91.0\n            * @condition ltPropType password\n            */\n            ltPropTooltipConfig : prop( __string, { default : '{\"position\" : \"bottom\"}' } ),\n            /**\n             * @typedef {object} ariaLabel\n             * @property {string} modal=\"Choose date\"\n             * @property {string} button=\"Change date\"\n             */\n\n            /**\n            * @componentProperty {ariaLabel} ltPropAriaLabel\n            * @version 3.91.0\n            */\n            ltPropAriaLabel : prop( __object, { default : { modal : \"Choose date\", button : \"Change date\" } } ), \n           /**\n            * @componentProperty {string} ltPropDataTabindex = 0\n            * @version 3.91.0\n            */\n            ltPropDataTabindex : prop( __string, { default : \"0\" } ),\n            /**\n             * @componentProperty {string} ltPropLabelClass=\"\"\n             * @version 3.98.0\n             */\n            ltPropLabelClass : prop( __string, { default : \"\" } ),\n\n            // system data\n\n            eventListeners : prop( __object, {default : {}}),\n            selectedField : prop( __object, { default : {}}),\n            endMinute : prop( __number ),\n            startMinute : prop( __number ),\n            dropdownData : prop( __array, { default : []}),\n            originalData : prop( __array, { default : []}),\n            dateRange : prop( __object, { default : { day : [], month : [], year : []}}),\n            // Dont change this property name. Already some people from crm using this for passing their custom translations\n            meridian : prop( __object, { default : {AM : (window._lyteUiUtils ? window._lyteUiUtils.i18n('AM') : 'AM'), PM : (window._lyteUiUtils ? window._lyteUiUtils.i18n('PM') : 'PM')}}),\n            hour : prop( __string, { default : window._lyteUiUtils.i18n('hour')}),\n            min : prop( __string, { default : window._lyteUiUtils.i18n('min')}),\n            selectedDateField : prop( __string, { default : \"\"}),\n            preventObs : prop( __boolean, { default : true}),\n            resize : prop( __boolean, { default : true}),\n            resizeClass : prop( __string, { default : \"lyteTextareaResize\" } ),\n            pos : prop( __string, { default : \"\"}),\n            isSearch : prop( __boolean, { default : false }),\n            isBox : prop( __string, { default : '' }),\n            dateOrder : prop( __array, { default : [] }),\n            showPlaceholder : prop( __boolean, { default : false }),\n\n            lyteUnbound : prop( __boolean, { default : false }),\n\n            randomId : prop( __string, { default : \"\" } ),\n\n            navigation : prop( __boolean, { default : false } ),\n            passwordClass : prop( __string, { default : \"lyteInputShowPasswordIcon\" } ),\n            passwordTooltip : prop( __string, { default: \"\" } ),\n\n            isExpanded : prop( __string, { default : \"false\" } )\n        };\n}\n\n    getDateFromFormat(tdate, format) {\n\n        var is_i18n = this.data.ltPropCalendarProperties.i18n;\n\n        if( is_i18n ){\n            var format = this._assCalendar.component.getRelevantFormat( format );\n\n            return $L.moment( tdate ).i18N( format ); \n        } else {\n            return this._assCalendar.component.getDateFromFormat(tdate, format);\n        }\n\n    }\n\n    dateValidation(date) {\n        if( !this._assCalendar ){\n            return false;\n        }\n        var timeObj = this._assCalendar.component.stringToDate( date, this.data.ltPropFormat );\n         if( timeObj == 'Invalid Date'){\n            return false\n         }\n         return timeObj;\n    }\n\n    dateRegexFind(arg) {\n         var format, dateRange = this.getData('dateRange'),\n         dateOrder = [];\n         if(!arg){\n             format = this.getData('ltPropFormat');\n         }else{\n             format = arg.newValue;\n         }\n         var dayReg = /D+/ig.exec(format), monthReg = /M+/ig.exec(format), yearReg = /Y+/ig.exec(format);\n         if( dayReg ){\n             dateRange.day[0] = dayReg.index; dateRange.day[1] = dayReg.index + dayReg[0].length;\n             dateOrder.push( { value : dateRange.day[ 0 ], name : \"day\", format : format.match( /D+/ig )[ 0 ] } );\n         }\n         if( monthReg ){\n             dateRange.month[0] = monthReg.index; dateRange.month[1] = monthReg.index + monthReg[0].length;\n             dateOrder.push( { value : dateRange.month[ 0 ], name : \"month\", format : format.match( /M+/ig )[ 0 ] } );\n         }\n         if( yearReg ){\n             dateRange.year[0] = yearReg.index; dateRange.year[1] = yearReg.index + yearReg[0].length;\n             dateOrder.push( { value : dateRange.year[ 0 ], name : \"year\", format : format.match( /Y+/ig )[ 0 ] } )\n         }\n         dateOrder.sort( function( a, b ){\n             return a.value - b.value;\n         } )\n         this.setData( 'dateOrder', dateOrder );\n     }\n\n    constructingArr(i, startTime, format) {\n        if(i < startTime){\n            i += 1440;\n        }\n        var interval = (i - startTime) / 60,\n        temp = {};\n        temp.time = this.convertToRailway(i, true, format).trim();\n        temp.interval = interval < 1 ? ((i - startTime) + ' '+ this.getData('min')) : ((interval % 1 == 0 ? interval : interval.toFixed(1)) + ' ' + this.getData('hour'));\n        return temp;\n    }\n\n    dropdownConstruct() {\n        if( this._prevent ) {\n            return\n        }\n        var startTime = this.getData('startMinute'), i, temp = [], endTime = this.getData('endMinute'), hrInter = this.getData('ltPropHourInterval'), minInt = this.getData('ltPropMinuteInterval'), format = this.getData('ltPropTimeFormat'),\n        arr = [];\n        if(startTime >= endTime){\n            endTime += 1440;\n        }\n        for(i = startTime; i <= endTime; i += minInt){\n             var current = this.constructingArr(i, startTime, format);\n             if( arr.indexOf( current.time ) == -1 ){\n                 temp.push( current );\n                 arr.push( current.time );\n             }\n        }\n\n        if( this.data.ltPropTimezoneHandling ){\n            this.check_dst( temp );\n        }\n        this.setData('originalData', temp);\n\n        if( this.data.ltPropDropdownShow ){\n            this.setData( 'dropdownData', temp );\n        }\n    }\n\n    constructNewDrop(input, format) {\n        var temp = [], startTime = this.getData('startMinute');\n        if(format == 12){\n            var min = this.convertToRailway(input.value.trim());\n            var ret = this.maxValCheck(min);\n            if(ret != false){\n                temp.push(this.constructingArr(min, startTime, 12));\n            }\n            min += 720;\n            ret = this.maxValCheck(min % 1440);\n            if(ret != false){\n                temp.push(this.constructingArr(min, startTime, 12));\n            }\n        }else{\n            var min = this.convertToRailway(input.value.trim());\n            var ret = this.maxValCheck(min);\n            if(ret != false){\n                temp.push(this.constructingArr(min, startTime, 24));\n            }\n        }\n        this.dropdown.ltProp( 'selected', '' );\n        if( temp.length == 0 && this.data.ltPropValidateOnBlur ){\n            this.data.ltPropStartTime && temp.push( { time : this.data.ltPropStartTime, interval : \"\" } );\n            this.data.ltPropEndTime && temp.push( { time : this.data.ltPropEndTime, interval : \"\" } );\n        }\n        this.setData('dropdownData', temp);\n        this.dropdown.ltProp( 'selected', this.data.ltPropDefaultTime );\n    }\n\n    getCorrectTime(timeFormat) {\n\n        if( $L.moment ){\n            var date = $L.moment();\n            if( timeFormat == 12 ){\n                return date.i18N( \"hh:mm A\" );\n            } else{\n                return date.format( \"HH:mm\" );\n            }\n        }\n\n        var time = new Date(), hr = time.getHours(), min = time.getMinutes().toString(), meridian = this.getData('meridian'), mer = hr > 11 ? meridian.PM : meridian.AM;\n        if(min.length == 1){\n            min = '0' + min;\n        }\n        if(timeFormat == 12){\n            if( hr != 12 ) {\n                hr = (hr%12).toString();\n                if(hr.length == 1){\n                    hr = '0' + hr;\n                }\n            }\n            return hr + ':' + min + \" \" + mer;\n        }else{\n            if(hr < 10){\n                hr = '0' + hr;\n            }\n            return hr + \":\" + min;\n        }\n\n    }\n\n    handleWheel(evt) {\n        var input = evt.target, type = this.getData('ltPropType');\n        if( input.tagName != 'INPUT' || Math.abs( evt.deltaY ) <= Math.abs( evt.deltaX ) ) {\n            return\n        }\n        if(type == 'time' || ( type == \"datetime\" && input.id == \"time\" ) ){\n            if( this._emptytimeValue ){\n                return;\n            }\n            $L.fastdom.mutate(function(){\n               var selectedField = this.getData('selectedField');\n                if(!selectedField.prop || input.selectionStart > 3){\n                    // settting initial selection if input is not focused\n                    input.selectionStart = 0;\n                    input.selectionEnd = 2;\n                    this.setData('selectedField', {prop : 'hour', val : 0});\n                    selectedField = {prop : 'hour', val : 0};\n                }\n                if(evt.deltaY < -10){\n                    this.timeDecrease.call(this, input, {}, selectedField.prop, input.selectionStart, input.selectionEnd)\n                }else if(evt.deltaY > 10){\n                    this.timeIncrease.call(this, input, {}, selectedField.prop, input.selectionStart, input.selectionEnd)\n                }\n            }.bind(this))\n        }else if( type == 'date' || ( type == \"datetime\" && input.id == \"date\" ) ){\n            if(evt.deltaY < -10){\n                evt.keyCode = 40;\n                this.calendarKeydown.call(this, evt, input);\n            }else if(evt.deltaY > 10){\n                evt.keyCode = 38;\n                this.calendarKeydown.call(this, evt, input);\n            }\n        }\n        evt.preventDefault();   \n    }\n\n    convertToRailway(val, flag, format) {\n        var meridian = this.getData('meridian');\n        if(!flag){\n            var hr = parseInt(val.slice(0, 2));\n            var min = parseInt(val.slice(3, 5));\n            if(val.length != 5){\n                var mer = val.slice(6, val.length);\n                return (mer == meridian.PM ? ((hr % 12) + 12) : hr % 12) * 60 + min;\n            }else{\n                return (hr * 60 + min);\n            }\n        }else{\n            var hr = parseInt(val / 60) % 24;\n\n            var min = val % 60;\n            if(min < 10){\n                min = '0' + min;\n            }\n            var mer = ''\n            if(format == 12){\n                if(parseInt(hr / 12) == 1){\n                    if(hr > 12){\n                        hr = hr % 12;\n                    }\n                    mer = meridian.PM;\n                }else{\n                    mer = meridian.AM;\n                    hr = hr || 12;\n                }\n            }\n            if(hr < 10){\n                hr = '0' + hr;\n            }\n            return (hr + \":\" + min + \" \" + mer);\n        }\n    }\n\n    maxValCheck(val) {\n        var endTime = this.getData('endMinute');\n        var startTime = this.getData('startMinute');\n        var toChangeTime;\n        if(typeof val == 'string'){\n            toChangeTime =  this.convertToRailway(val);\n        }else{\n            toChangeTime = val\n        }\n        if(startTime < endTime){\n            if(toChangeTime <= endTime && toChangeTime >= startTime){\n                return true\n            }\n        }else{\n            if((toChangeTime < 1440 && toChangeTime >= startTime) || (toChangeTime >= 0 && toChangeTime <= endTime)){\n                return true;\n            }\n        }\n        return false\n    }\n\n    timeInValChange(arg) {\n        var timeFormat = this.getData('ltPropTimeFormat'), value,\n        val = this.data.ltPropValue,\n        type = this.data.ltPropType;\n\n        if(arg){\n            value = arg.newValue;\n        }else{\n            value = this.getData('ltPropDefaultTime');\n            if( ( val == undefined || type == 'datetime' ) && !value && $L.moment && ( type == \"time\" ? this.data.ltPropPlaceholder : ( this.data.ltPropTimePlaceholder || this.data.ltPropCommonPlaceholder ) ) ){\n                this._emptytimeValue = true;\n                if( type == 'datetime' ){\n                    this.checkCommonPlaceHolder();\n                }\n                return;\n            }\n        }\n        if(!value){\n            var startTime =  this.getData('ltPropStartTime');\n            if(startTime){\n                value = startTime;\n            }else{\n                value = this.getCorrectTime(timeFormat);\n            }\n        }\n        this.setData('ltPropDefaultTime', value.slice(0, timeFormat != 12 ? 5 : value.length));\n    }\n\n    checkCommonPlaceHolder() {\n        if( ( this.data || {} ).ltPropCommonPlaceholder ){\n            this.setData( 'showPlaceholder', !( this.data.ltPropCurrentDate || this.data.ltPropDefaultTime ) );\n        }\n    }\n\n    startEndTimeObs(arg) {\n        if(!arg || arg.item == 'ltPropStartTime')\n            {\n                var defaultVal = this._emptytimeValue ? this.getCorrectTime( this.data.ltPropTimeFormat ) : this.getData('ltPropDefaultTime');\n                var startTime = this.getData('ltPropStartTime')\n                if(!startTime){\n                    this.setData('ltPropStartTime', defaultVal)\n                    startTime = defaultVal\n                }\n                this.setData('startMinute', this.convertToRailway(startTime));\n            }\n        if(!arg || arg.item == 'ltPropEndTime') \n            {\n                var  endTime = this.getData('ltPropEndTime'), flag = 0\n                if(!endTime){\n                    var min = Math.max(0, parseInt(startTime.slice(3, 5)) - 1).toString();\n                    if(min.length == 1){\n                        min = '0' + min;\n                    }\n                    endTime = ( startTime.slice(0, 3) + min + \" \" + startTime.slice(6, startTime.length) ).trim();\n                    this.setData('ltPropEndTime', endTime)\n                }\n                this.setData('endMinute',  this.convertToRailway(endTime));\n            }\n        this.data.ltPropDropdown && this.dropdownConstruct();    \n    }\n\n    dateCallback(arg) {\n        if( arg.newValue == \"\" && arg.oldValue == undefined) {\n            return\n        }\n\n        this.englishDate();\n\n        if(this.getMethods('onDateChange')){\n           /**\n            * @method onDateChange\n            * @version 1.0.2\n            * @condition ltPropType date,datetime\n            */            \n            this.executeMethod('onDateChange', arg, this.$node, this._selected);\n        }\n        this.checkCommonPlaceHolder();\n        delete this._selected;\n    }\n\n    timeCallback(arg) {\n        if( arg.newValue == \"\" && arg.oldValue == undefined) {\n            return\n        }\n        if(this.getMethods('onValueChange')){\n           /**\n            * @method onValueChange\n            * @version 1.0.2\n            */            \n            this.executeMethod('onValueChange', arg, this.$node)\n        }\n    }\n\n    /*\n        Calculate left of dropdown container when it has to come below/above the select element when it exceeds window.innerWidth and there is space to the right\n    */\n    setLeftExceedForDown(element, container, bcr, containerbcr, xscroll, ww) {\n        var scrolledLeft = xscroll,\n        elementBCR = bcr,\n        elementLeft = this.rtlfunc.call( this, 'left', elementBCR, ww ),\n        elementWidth = elementBCR.width,\n        containerBCR = containerbcr,\n        containerWidth = containerBCR.width,\n        total = scrolledLeft + elementLeft + elementWidth - containerWidth;\n\n        return total\n    }\n\n    /*\n        Calculate left of dropdown container when it has to come below/above the select element when it doesn't exceed window.innerWidth\n    */\n    setLeftNotExceedForDown(element, bcr, xscroll, ww) {\n        var scrolledLeft = xscroll,\n        elementBCR = bcr,\n        elementLeft = this.rtlfunc.call( this, 'left', elementBCR, ww ),\n        total = scrolledLeft + elementLeft;\n\n        return total\n    }\n\n    /*\n        Calculate top of dropdown container when it has to come above the select element\n    */\n    setTopAboveForDown(element, container, bcr, containerbcr, yscroll) {\n        var scrolledHeight = yscroll,\n        elementBCR = bcr,\n        elementTop = elementBCR.top,\n        containerBCR = containerbcr,\n        containerHeight = containerBCR.height,\n        total = scrolledHeight + elementTop  - containerHeight;\n\n        return total\n    }\n\n    /*\n        Calculate top of dropdown container when it has to come below the select element\n    */\n    setTopBelowForDown(element, bcr, yscroll) {\n        var scrolledHeight = yscroll,\n        elementBCR = bcr,\n        elementTop = elementBCR.top,\n        elementHeight = elementBCR.height,\n        total = scrolledHeight + elementTop + elementHeight;\n\n        return total\n    }\n\n    /*\n        Calculate left of dropdown container when it has to come to right of the select element\n    */\n    setLeftForRight(element, bcr, xscroll, ww) {\n        var scrolledWidth = xscroll,\n        elementBCR = bcr,\n        elementLeft = this.rtlfunc.call( this, 'left', elementBCR, ww ),\n        elementWidth = elementBCR.width,\n        total = scrolledWidth + elementLeft + elementWidth;\n\n        return total\n    }\n\n    /*\n        Calculate right of dropdown container when it has to come to left of the select element of right dropdown\n    */\n    setRightForRight(element, container, bcr, elembcr, xscroll, ww) {\n        var scrolledWidth = xscroll,\n        elementBCR = bcr,\n        containerBCR = elembcr,\n        elementLeft = this.rtlfunc.call( this, 'left', elementBCR, ww ),\n        containerWidth = containerBCR.width,\n        total = scrolledWidth + elementLeft - containerWidth;\n\n        return total\n    }\n\n    /*\n        Calculate top of dropdown container when it has to come to right of dropdown and there is space below\n    */\n    setTopForRight(element, bcr, yscroll) {\n        var scrolledHeight = yscroll,\n        elementBCR = bcr,\n        elementTop = elementBCR.top,\n        total = scrolledHeight + elementTop;\n\n        return total\n    }\n\n    /*\n        Calculate top of dropdown container when it has to come to right of dropdown and there is no space below\n    */\n    setTopForRightAbove(element, container, bcr, elembcr, yscroll) {\n        var scrolledHeight = yscroll,\n        elementBCR = bcr,\n        elementTop = elementBCR.top,\n        elementHeight = elementBCR.height,\n        containerBCR = elembcr,\n        containerHeight = containerBCR.height,\n        total = scrolledHeight + elementTop + elementHeight - containerHeight;\n\n        return total\n    }\n\n    /**\n     * Set the CSS for your calendar\n     * refer commit ID 583ee6ccbeaa6b3729178bf9df0139032b016d19 and previous for the previous stable setCSS function.\n     * commit ID 583ee6ccbeaa6b3729178bf9df0139032b016d19 also gives a better understanding about the hard coded values in this function.\n     */\n    setCss() {\n        var link = this.$node.calendarDiv;\n\n        if( !link \n            || link.classList.contains( 'lyteCalendarHidden' ) \n        ) {\n            return;\n        }\n\n        // Get properties\n\n        // Get button\n        var body = link,\n        par = this.$node.querySelector( 'input' ).parentElement;\n\n        // Get Geometric propotions\n        var wwidth, wheight, flag, \n        bleft = 0, btop = 0,\n        wwidth = window.innerWidth,\n        wheight= window.innerHeight,\n        iwdth = wwidth,\n        drop = body.getBoundingClientRect(), \n        x = ( window.pageXOffset || document.documentElement.scrollLeft ) * ( this._dir ? - 1 : 1 ),\n        y = window.pageYOffset || document.documentElement.scrollTop,\n        height = body.offsetHeight,\n        width = body.offsetWidth, \n        position = this.getData( 'ltPropPosition' ),\n        offsets = par.getBoundingClientRect(),\n        scope = this.data.ltPropScope,\n        scopeElement = scope ? $L( this.$node ).closest( scope ).get( 0 ) : void 0,\n        scopeBcr = scopeElement ? scopeElement.getBoundingClientRect() : void 0;\n\n        if( scopeBcr ){\n            bleft = Math.max( bleft, scopeBcr.left );\n            btop = Math.max( btop, scopeBcr.top );\n            wwidth = Math.min( wwidth, scopeBcr.right );\n            wheight = Math.min( wheight, scopeBcr.bottom );\n        }\n\n        // Intialize flags\n        var downPos, \n        rightPos, \n        topPos, \n        leftPos,\n        pos;\n\n        // temp stores\n        var tempStore,\n        tempTop, \n        tempLeft, \n        tempMarginLeft, \n        tempMarginTop,\n        tempNum, \n        tempDenom, \n        tempPer,\n        oL = this.rtlfunc.call( this, 'left', offsets, iwdth ),\n        lT = this.rtlfunc.call( this, 'left' );\n\n        if( position === 'down' ) {\n            downPos = true;\n            tempTop = offsets.top + offsets.height; \n            if( tempTop + height > wheight \n                /*&& offsets.top > height */\n            ) {\n                downPos = ( wheight - offsets.top ) > ( offsets.bottom - btop );        \n            }\n\n            rightPos = true;\n            tempLeft = oL;\n            if( tempLeft + width > wwidth \n                && tempLeft > tempLeft + offsets.width - body.offsetWidth \n            ) {\n                rightPos = false;\n                \n            }\n            // else if( oL + width <= wwidth ) {\n            //     rightPos = true;\n            // }\n\n            if( downPos ) {\n                this.setData( 'pos', 'down' );\n                body.style.top = this.setTopBelowForDown( par, offsets, y ) + 'px';\n                \n            }\n            else {\n                this.setData( 'pos', 'up' );\n                body.style.top = this.setTopAboveForDown( par, body, offsets, drop, y, iwdth ) + 'px';\n            }\n\n            if( rightPos ) {\n                body.style.top = tempStore ? tempStore : body.style.top;\n                body.style[ lT ] = this.setLeftNotExceedForDown( par, offsets, x, iwdth ) + 'px';  \n            }\n            else {\n                body.style.top = tempStore ? tempStore : body.style.top;\n                body.style[ lT ] = this.setLeftExceedForDown( par, body, offsets, drop, x, iwdth ) + 'px'\n            }\n\n            \n        }\n        else if( position === 'right' ) {\n            rightPos = true;\n            if( oL + offsets.width + width > wwidth\n                && oL - drop.width > bleft \n            ) {   \n                rightPos = false;\n                \n            }\n\n            downPos = true;\n            if( offsets.top + drop.height > wheight ) {\n                downPos = ( wheight - offsets.top ) > ( offsets.bottom - btop )\n            }\n\n            if( rightPos ) {\n                this.setData( 'pos', 'right' );\n                body.style[ lT ]= this.setLeftForRight( par, offsets, x, iwdth ) + 'px'\n            }\n            else {\n                this.setData( 'pos', 'left' );\n                body.style[ lT ] = this.setRightForRight( par, body, offsets, drop, x, iwdth ) + 'px';\n            }\n\n            if( downPos ) {\n                body.style[ lT ] = tempStore ? tempStore : body.style[ lT ];\n                body.style.top = this.setTopForRight( par, offsets, y ) + 'px' \n            }\n            else {\n                body.style[ lT ] = tempStore ? tempStore : body.style[ lT ];\n                body.style.top = this.setTopForRightAbove( par, body, offsets, drop, y ) + 'px'\n            }\n        }\n        else if( position === 'up' ) {\n            topPos = true\n            if( offsets.top - drop.height < btop \n                /*&& offsets.top + offsets.height + height < wheight */\n            ) {\n                topPos = ( wheight - offsets.top ) < ( offsets.bottom - btop )\n            }\n\n            rightPos = true\n            if( oL + width > wwidth \n                && oL > oL + offsets.width - body.offsetWidth \n            ) {\n                rightPos = false\n            }\n            // else if( oL + width <= wwidth ) {\n            //     rightPos = true\n            // }\n\n            if( topPos ) {\n                this.setData( 'pos', 'up' );\n                body.style.top = this.setTopAboveForDown( par, body, offsets, drop, y ) + 'px';\n            }\n            else {\n                this.setData( 'pos', 'down' );\n                body.style.top = this.setTopBelowForDown( par, offsets, y ) + 'px'\n            }\n            if( rightPos ) {\n                body.style.top = tempStore ? tempStore : body.style.top;\n                body.style[ lT ] = this.setLeftNotExceedForDown( par, offsets, x, iwdth ) + 'px';\n            }\n            else{\n                body.style.top = tempStore ? tempStore : body.style.top;\n                body.style[ lT ] = this.setLeftExceedForDown( par, body, offsets, drop, x, iwdth ) + 'px';\n            }\n        } else if( position === 'left' ) {\n            leftPos = true;\n            if( oL - drop.width < bleft \n                && oL + drop.width < wwidth \n            ) {\n                leftPos = false;\n            }\n            // else {\n            //     leftPos = true;\n            // }\n\n            downPos = true;\n            if( offsets.top + drop.height > wheight ) {\n                downPos = ( wheight - offsets.top ) > ( offsets.bottom - btop );\n            }\n\n            if( leftPos ) {\n                this.setData( 'pos', 'left' );\n                body.style[ lT ] = this.setRightForRight( par, body, offsets, drop, x, iwdth ) + 'px';\n            }\n            else {\n                this.setData( 'pos', 'right' );\n                body.style[ lT ] = this.setLeftForRight( par, offsets, x, iwdth ) + 'px';\n            }\n            if( downPos ){\n                body.style[ lT ] = tempStore ? tempStore : body.style[ lT ];\n                body.style.top = this.setTopForRight( par, offsets, y ) + 'px';\n            }\n            else{\n                body.style[ lT ] = tempStore ? tempStore : body.style[ lT ];\n                body.style.top = this.setTopForRightAbove( par, body, offsets, drop, y ) + 'px';\n            }\n        } else if( position === 'downLeft' ) {\n            downPos = true;\n            tempTop = offsets.top + offsets.height;\n            if( tempTop + height > wheight /*&& offsets.top > height*/ ) {\n                downPos = ( wheight - offsets.top ) > ( offsets.bottom - btop );\n            } \n            // else {\n            //     downPos = true;\n            // }\n            if( !downPos ) {\n                tempTop = offsets.top - height;\n            }\n            rightPos = false\n            tempLeft = oL + offsets.width / 2 - width;\n            if( tempLeft < bleft ) {\n                tempLeft = bleft\n                rightPos = true\n            } \n            // else { \n            //     rightPos  = false\n            // }\n\n            body.style.top = tempTop + y + 'px';\n\n            body.style[ lT ] = tempLeft + x + 'px';\n            if( downPos ){\n                pos = 'downLeft';\n            } else {\n                pos = 'upLeft';\n            }\n            this.setData( 'pos', pos);\n\n        } else if( position === 'downRight' ) {\n            downPos = true;\n            tempTop = offsets.top + offsets.height;\n            if( tempTop + height > wheight /*&& offsets.top > height*/ ) {\n                downPos = ( wheight - offsets.top ) > ( offsets.bottom - btop );\n            } \n            // else {\n            //     downPos = true;\n            // }\n            if( !downPos ) {\n                tempTop = offsets.top - height\n            }\n            rightPos = true\n            tempLeft = oL + offsets.width / 2;\n            if( tempLeft + width > wwidth ) {\n                tempLeft = wwidth - width;\n                rightPos = false;\n            } \n            // else { \n            //     rightPos  = true;\n            // }\n\n            body.style.top = tempTop + y + 'px';\n\n            body.style[ lT ] = tempLeft + x + 'px';\n            if( downPos ){\n                pos = 'downRight';\n            } else {\n                pos = 'upRight';\n            }\n            this.setData( 'pos', pos);\n        } else if( position === 'upLeft' ) {\n            downPos = false;\n            tempTop = offsets.top - height;\n            if( tempTop < btop) {\n                downPos = ( wheight - offsets.top ) > ( offsets.bottom - btop );\n            } \n            // else {\n            //     downPos = false;\n            // }\n            if( downPos ) {\n                tempTop = offsets.top + offsets.height;\n            }\n            rightPos = false\n            tempLeft = offsets[ lT ] + offsets.width / 2 - width;\n            if( tempLeft < bleft ) {\n                tempLeft = bleft\n                rightPos = true\n            } \n            // else { \n            //     rightPos  = false\n            // }\n\n            body.style.top = tempTop + y + 'px';\n\n            body.style[ lT ] = tempLeft + x + 'px';\n            if( downPos ){\n                pos = 'downLeft';\n            } else {\n                pos = 'upLeft';\n            }\n            this.setData( 'pos', pos);\n\n        } else if( position === 'upRight' ) {\n            downPos = false;\n            tempTop = offsets.top - height;\n            if( tempTop < btop) {\n                downPos = ( wheight - offsets.top ) > ( offsets.bottom - btop );\n            } \n            // else {\n            //     downPos = false;\n            // }\n            if( downPos ) {\n                tempTop = offsets.top + offsets.height\n            }\n            rightPos = true\n            tempLeft = oL + offsets.width / 2;\n            if( tempLeft + width > wwidth ) {\n                tempLeft = wwidth - width;\n                rightPos = false;\n            } \n            // else { \n            //     rightPos  = true;\n            // }\n\n            body.style.top = tempTop + y + 'px';\n\n            body.style[ lT ] = tempLeft + x + 'px';\n            if( downPos ){\n                pos = 'downRight';\n            } else {\n                pos = 'upRight';\n            }\n            this.setData( 'pos', pos);\n        }\n            \n    }\n\n    preventFn() {\n        this.preventFocus = true;\n    }\n\n    static methods() {\n        return {\n            wormholeAppend : function( element, outlet ){\n\n                var __node = this.$node;\n\n                __node.calendarComp = element;\n                element.nodeN = __node;\n                __node.calendarDiv = element.querySelector( 'div#lyteCalendar' );\n                this._assCalendar = __node.calendarDiv.querySelector( 'lyte-calendar' );\n                // var func1 = this.calendarMousedown.bind(this);\n                // this.$node.calendarDiv.addEventListener('mousedown', func1, true);\n                // this.setData('eventListeners.mousedown', func1);\n               /**\n                * @utility revertToToday\n                * @condition ltPropType date,datetime\n                * @version 2.2.12\n                */            \n                __node.revertToToday = this._assCalendar.revertToToday;\n               /**\n                * @utility revertToSelected\n                * @condition ltPropType date,datetime\n                * @version 2.2.12\n                */            \n                __node.revertToSelected = this._assCalendar.revertToSelected;\n\n                var dropdown = this._assCalendar.querySelectorAll('lyte-dropdown');\n                for( var i = 0; i < dropdown.length; i++ ){\n                    var dropbody = dropdown[ i ].component.childComp || dropdown[ i ].querySelector( 'lyte-drop-box' );\n                    dropbody.addEventListener( 'mousedown', this.preventFn.bind( this ) );\n                }\n\n                if( this.data.ltPropAria ){\n                    try{\n                        $L( __node.calendarDiv ).trapFocus();\n                    }catch( err ){};\n                }\n            },\n\n            \"on-dateselected\":function(){\n                   this._selected = true;\n                   this._hideCalendar();\n             },\n             hide : function(){\n                $L( this.$node ).removeClass( 'lyteInputDropdownOpen' );\n                if(this.getMethods('onHide')){\n                   /**\n                    * @method onHide\n                    * @condition ltPropType time,datetime\n                    * @version 1.0.2\n                    */                \n                    this.executeMethod('onHide', arguments[0], arguments[1], this.$node);\n                }\n             },\n             beforeHide : function(){\n                if(this.getMethods('onBeforeHide')){\n                   /**\n                    * @method onBeforeHide\n                    * @condition ltPropType time,datetime\n                    * @version 1.0.2\n                    */                \n                    return this.executeMethod('onBeforeHide', arguments[0], arguments[1], this.$node);\n                }\n             },\n             show : function(){\n                $L( this.$node ).addClass( 'lyteInputDropdownOpen' );\n                if(this.getMethods('onShow')){\n                   /**\n                    * @method onShow\n                    * @condition ltPropType date,datetime\n                    * @version 1.0.2\n                    */                \n                    this.executeMethod('onShow', arguments[0], arguments[1], this.$node);\n                }\n             },\n             beforeShow : function(){\n                if(this.getMethods('onBeforeShow')){\n                   /**\n                    * @method onShow\n                    * @condition ltPropType date,datetime\n                    * @version 1.0.2\n                    */                \n                    return this.executeMethod('onBeforeShow', arguments[0], arguments[1], this.$node);\n                }\n             },\n             optionSelected : function(){\n                this._calmsfg = true;\n                delete this._emptytimeValue;\n                this.setData('ltPropDefaultTime', arguments[1].trim());\n\n                $L( 'input', this.$node ).get( -1 ).focus();\n             },\n\n             scroll : function(){\n                if(this.getMethods('onScroll')){\n                   /**\n                    * @method onScroll\n                    * @condition ltPropType time,datetime\n                    * @version 1.0.2\n                    */                \n                    this.executeMethod('onScroll', arguments[0], arguments[1]);\n                }\n             },\n\n             positionChange : function(){\n                if(this.getMethods('onPositionChanged')){\n                   /**\n                    * @method onPositionChanged\n                    * @condition ltPropType time,datetime\n                    * @version 1.0.2\n                    */                \n                    this.executeMethod('onPositionChanged', arguments[0], arguments[1]);\n                }\n             },\n\n             calendarNavigate : function( arg1, arg2, arg3, arg4 ){\n                $L.fastdom.measure( this.setCss.bind( this ) );\n                if( this.getMethods( 'onNavigate' ) ) {\n                   /**\n                    * @method onNavigate\n                    * @condition ltPropType date,datetime\n                    * @version 2.0.0\n                    */                \n                    this.executeMethod( 'onNavigate', arg1, arg2, arg3, arg4 )\n                }\n             },\n\n             viewDateChange : function( arg1, arg2 ){\n                   /**\n                    * @method onViewdateChange\n                    * @condition ltPropType date,datetime\n                    * @version 2.2.11\n                    */            \n                this.getMethods( 'onViewdateChange' ) && this.executeMethod( 'onViewdateChange', arg1, arg2, this.$node );\n             },\n\n             viewChange : function( evt, viewType, _this ){\n                $L.fastdom.measure( this.setCss.bind( this ) );\n                   /**\n                    * @method onViewChange\n                    * @condition ltPropType date,datetime\n                    * @version 2.2.11\n                    */            \n                this.getMethods( 'onViewChange' ) && this.executeMethod( 'onViewChange', evt, viewType, _this, this.$node )\n             }\n        };\n    }\n\n    valUpdate() {\n         if( !this.$node || !this) {\n             return;\n         }\n         delete this._timeout;\n         var type = this.data.ltPropType;\n         if( type == 'date' || type == \"datetime\" ){\n             var inn = this.$node.querySelector( 'input' ).value;\n             this.setData('ltPropCurrentDate', inn ? inn : \"\");\n         }else if(type == \"textarea\"){\n             var inn = this.$node.querySelector( 'textarea' ).value;\n             this.setData('ltPropValue', inn ? inn : \"\");\n         }else{\n             var inn = this.$node.querySelector( 'input' ).value;\n             // if( this.data.ltPropType == \"number\" && !frmblur && ( !inn || inn == this.$node.ltProp( 'value' ) ) ){\n             //  return\n             // }\n             this.setData('ltPropValue', inn ? inn : \"\");\n         }  \n    }\n\n    fixSelection(val, selectedField, input) {\n     if( this.data.ltPropReadonly ){\n         return;\n     }\n     // changing selection range\n             input.selectionStart = selectedField.val + val;\n             input.selectionEnd = input.selectionStart + 2;\n             this.timeClick.call(this, {}, input, selectedField.val + val );\n    }\n\n    replaceVal(input, val, start, end) {\n         var value;\n         if(typeof input == 'string'){\n             value = input\n         }else{\n             value = input.value\n         }\n         var regex = new RegExp('('+ value.slice(start, start + end) +')','i');\n          return value.trim().replace(regex, val);   \n    }\n\n    retVal(val1, val2, limit) {\n      if( parseInt( val1 + val2 ) > limit ) {\n         return '0' + val2\n      }\n      return val1 + val2;\n    }\n\n    convertToPm(limit, val, meridian) {\n         if( limit == 12 ) {\n             var mer = val.slice( 6, val.length ), time = val.slice( 0, 5 ), hr = val.slice( 0, 2 ), min = val.slice( 3, 5 )\n             if( hr == '00' && mer == 'AM' || hr == '12' && mer == 'PM' ) {\n                 return val\n             }\n             return hr + ':' + min + \" \" + ( meridian.AM == mer ? meridian.PM : meridian.AM )\n         }\n         return val\n    }\n\n    hourTimeSet(input, evt, selection, start, end) {\n          var inputVal = input.value.trim(), limit, meridian = this.getData('meridian');\n          var typedValue  = window._lyteUiUtils.getCorrectNumberCode( evt.which || evt.keyCode ) - 48;\n          var newVal = inputVal.slice(start + 1, end) + typedValue;\n          var timeFormat = this.data.ltPropTimeFormat,\n          blur = this.data.ltPropValidateOnBlur,\n          final;\n          \n          if(selection == 'hour'){\n             limit = timeFormat == 12 ? 12 : 24;\n          }else{\n             delete this._lasttyped;\n             limit = 60\n          }\n         // if(parseInt(newVal) > limit){\n             // newVal = '0' + typedValue;\n             // if((limit == 12 && newVal == '00' && inputVal.slice(6, 8) == meridian.PM)){\n             //     inputVal = this.replaceVal.call(this, input, meridian.AM, 6, meridian.AM.length);\n             // }else\n              if(limit == 60 && parseInt( newVal ) >= 60){\n                 newVal = '0' + typedValue;\n             }\n         // }else{\n             // if((limit == 12 && newVal == '12' && inputVal.slice(6, 8) == meridian.AM)){\n             //     inputVal = this.replaceVal.call(this, input, meridian.PM, 6, meridian.AM.length);\n             // } else if((limit == 12 && newVal == '00' && inputVal.slice(6, 8) == meridian.PM)){\n             //     inputVal = this.replaceVal.call(this, input, meridian.AM, 6, meridian.PM.length);\n             // }\n         // }\n\n         // if( selection == 'hour' && timeFormat == 12 && newVal == \"00\" ){\n         //     newVal = \"12\";\n         // }\n         if( selection == \"hour\" ){\n             final = this.getCrctHour( inputVal, start, end, limit, typedValue, meridian );\n             this._lasttyped = typedValue + '';\n         } else {\n             final = inputVal.slice(0, start) + newVal + inputVal.slice(end, inputVal.length);\n             if( !blur || blur && evt.type != 'keydown' ){\n                 var returnV1 = this.maxValCheck(final);\n                 if(returnV1 == false ){\n                     final = inputVal.slice(0, start) + this.retVal( inputVal.slice(start, start + 1), typedValue, limit ) + inputVal.slice(end, inputVal.length);\n                     returnV1 = this.maxValCheck(final);\n                     if(returnV1 == false){\n                         final = inputVal.slice(0, start) + '0' + typedValue + inputVal.slice(end, inputVal.length);\n                         returnV1 = this.maxValCheck(final);\n                         if(returnV1 == false){\n                             final = this.convertToPm( limit, final, meridian)\n                             returnV1 = this.maxValCheck(final);\n                             if(returnV1 == false){\n                                 return false;\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n\n         if( this.data.ltPropTimezoneHandling ){\n             final = this.check_dst( final, 1, 1 );\n         }\n\n         this.setData('ltPropDefaultTime', final);\n         // restore current selection\n         $L.fastdom.mutate(function(){\n             input.selectionStart = start;\n             input.selectionEnd = end;\n         })\n    }\n\n    _getCrctHour(str, limit, meridian) {\n         if( this.maxValCheck( str ) == false ){\n             if( limit == 12 ){\n                  str = this.convertToPm( limit, str, meridian );\n                  if( this.maxValCheck( str ) == false ){\n                     return false;\n                  } \n                  return str;\n             }\n             return false;\n         }\n         return str;\n    }\n\n    getCrctHour(inputVal, start, end, limit, typedValue, meridian) {\n         var str, hr, ret, allow,\n         blur = this.data.ltPropValidateOnBlur;\n         if( this._lasttyped != undefined ){\n             hr = this._lasttyped + typedValue;\n             if( hr == \"00\" && limit == 12 ){\n                 allow = true;\n                 hr = \"12\"\n             }\n             if( limit == 24 && parseInt( hr ) >= 24 || limit == 12 && parseInt( hr ) >= 13 ){\n                 ret = false;\n             } else {\n                 str = hr + inputVal.slice( end );\n                 if( !blur ){\n                     ret = this._getCrctHour( str, limit, meridian );\n                 } else {\n                     return str;\n                 }\n             }\n             if( ret != false ){\n                 return ret;\n             } else if( str ) {\n                 var em = this.data.endMinute,\n                 endTime = this.convertToRailway( str );\n                 if( endTime - em < 60 && endTime - em >= 0 ){\n                     return this.convertToRailway( em, true, limit ).trim();\n                 }\n             }\n         }\n         hr = inputVal.slice( start + 1, end ) + typedValue;\n         if( hr == \"00\" && limit == 12  ){\n             if( !allow ){\n                 return inputVal;\n             }\n             hr = \"12\"\n         }\n         if( limit == 24 && parseInt( hr ) >= 24 || limit == 12 && parseInt( hr ) >= 13 ){\n             ret = false;\n         } else {\n             str = hr + inputVal.slice( end );\n             if( !blur ){\n                 ret = this._getCrctHour( str, limit, meridian );\n             } else {\n                 return str;\n             }\n         }\n         if( ret != false ){\n             return ret;\n         }\n\n         hr = inputVal.slice( 0, start + 1 ) + typedValue;\n         if( hr == \"00\" && limit == 12  ){\n             if( !allow ){\n                 return inputVal;\n             }\n             hr = \"12\"\n         }\n         if( limit == 24 && parseInt( hr ) >= 24 || limit == 12 && parseInt( hr ) >= 13 ){\n             ret = false;\n         } else {\n             str = hr + inputVal.slice( end );\n             if( !blur ){\n                 ret = this._getCrctHour( str, limit, meridian );\n             } else {\n                 return str;\n             }\n         }\n         if( ret != false ){\n             return ret;\n         }\n\n         hr = '0' + typedValue;\n         if( hr == \"00\" && limit == 12  ){\n             if( !allow ){\n                 return inputVal;\n             }\n             hr = \"12\"\n         }\n         str = hr + inputVal.slice( end );\n         if( !blur ){\n             ret = this._getCrctHour( str, limit, meridian );\n         } else {\n             return str;\n         }\n         if( ret != false ){\n             return ret;\n         }\n         hr = typedValue + '0';\n         if( hr == \"00\" && limit == 12  ){\n             if( !allow ){\n                 return inputVal;\n             }\n             hr = \"12\"\n         }\n         if( limit == 24 && parseInt( hr ) >= 24 || limit == 12 && parseInt( hr ) >= 13 ){\n             ret = false;\n         } else {\n             str = hr + inputVal.slice( end );\n             if( !blur ){\n                 ret = this._getCrctHour( str, limit, meridian );\n             } else {\n                 return str;\n             }\n         }\n         if( ret != false ){\n             return ret;\n         }\n\n         if( this.data.ltPropConvertToNearest ){\n            return this.findNearestTime( inputVal, start, end, limit, typedValue, meridian );\n         }\n         return inputVal;\n    }\n\n    findNearestTime(inputVal, start, end, limit, typedValue, meridian) {\n         var hr, ret;\n         if( this._lasttyped != undefined ){\n             hr = this._lasttyped + typedValue;\n             if( limit == 24 && parseInt( hr ) >= 24 || limit == 12 && parseInt( hr ) >= 13 ){\n                 ret = false;\n             } else {\n                 return this._findNearest( hr + inputVal.slice( end ), limit );\n             }\n         }\n         hr = inputVal.slice( start + 1, end ) + typedValue;\n         if( limit == 24 && parseInt( hr ) >= 24 || limit == 12 && parseInt( hr ) >= 13 ){\n             ret = false;\n         } else {\n             return this._findNearest( hr + inputVal.slice( end ), limit );\n         }\n         hr = inputVal.slice( 0, start + 1 ) + typedValue;\n         if( limit == 24 && parseInt( hr ) >= 24 || limit == 12 && parseInt( hr ) >= 13 ){\n             ret = false;\n         } else {\n             return this._findNearest( hr + inputVal.slice( end ), limit );\n         }\n         hr = '0' + typedValue;\n         if( limit == 24 && parseInt( hr ) >= 24 || limit == 12 && parseInt( hr ) >= 13 ){\n             ret = false;\n         } else {\n             return this._findNearest( hr + inputVal.slice( end ), limit );\n         }\n         return inputVal;\n    }\n\n    _findNearest(str, limit) {\n       var value = this.convertToRailway( str ),\n       end = this.data.endMinute,\n       start = this.data.startMinute,\n       startDiff = Math.abs( start - value ),\n       endDiff = Math.abs( end - value );\n       if( startDiff > endDiff ){\n          return this.convertToRailway( end, true, limit ).trim();\n       } else {\n         return this.convertToRailway( start, true, limit ).trim();\n       }\n    }\n\n    timeIncrease(input, evt, selection, start, end, flag) {\n           if( this.data.ltPropReadonly ){\n              return\n           }\n           var inputVal = input.value.trim(), limit, currentValue = parseInt(inputVal.slice(start, end)), interval, timeFormat = this.getData('ltPropTimeFormat'), final, meridian = this.getData('meridian');\n           if(selection == 'hour'){\n              limit = timeFormat == 12 ? 12 : 24;\n              if(flag){\n                  interval = 1;\n              }else{\n                  interval =  this.data.ltPropHourInterval;\n              }\n           }else{\n              limit = 60;\n              interval =  this.data.ltPropMinuteInterval;\n           }\n           var newVal,\n           allow;\n           if( $L.moment && $L.moment.lyteMoment.prototype.add ){\n              var momentFormat = timeFormat == 12 ? \"hh:mm A\" : \"HH:mm\",\n              moment;\n              inputVal = inputVal.replace( meridian.AM, 'AM' ).replace( meridian.PM, 'PM' );\n\n              if( this.data.ltPropTimezoneHandling && this.data.ltPropCurrentDate ){\n                  moment = this.check_dst( inputVal, true );\n              } else {\n                  moment = $L.moment( inputVal, momentFormat );\n              }\n\n              if( moment.validate() ){\n                  final = moment.add( interval, limit == 60 ? 'minutes' : 'hours' ).format( momentFormat ).replace( 'AM', meridian.AM ).replace( 'PM', meridian.PM );\n              } else {\n                  allow = true;\n              }\n           } \n           if( allow ) {\n               newVal = (currentValue + interval) % limit;\n               if(limit == 12 && newVal < currentValue && inputVal.slice(6, inputVal.length) == meridian.AM){\n                  if(newVal == 0){\n                      newVal = '12';\n                  }\n                 inputVal = this.replaceVal.call(this, input, meridian.PM, 6, inputVal.length);\n               }else if(limit == 12 && newVal < currentValue && inputVal.slice(6, inputVal.length) == meridian.PM){\n                  if(currentValue != 12 || newVal == 0){\n                      inputVal = this.replaceVal.call(this, input, meridian.AM, 6, inputVal.length);\n                  }\n               }else if(limit == 12 && newVal == currentValue && inputVal.slice(6, inputVal.length) == meridian.AM){\n                      newVal = '12';\n                      inputVal = this.replaceVal.call(this, input, meridian.PM, 6, inputVal.length);\n               }else if(limit == 60 && newVal <= currentValue) {\n                   var ret = this.timeIncrease.call(this, input, evt, 'hour', 0, 2, true);\n                   if(ret == false){\n                      return false;\n                   }\n                   inputVal = input.value.trim();\n               }\n              newVal = newVal.toString();\n              if(newVal.length == 1){\n                  newVal = '0' + newVal;\n              }\n              final = inputVal.slice(0, start) + newVal + inputVal.slice(end, inputVal.length);\n          }\n          var returnV = this.maxValCheck(final)\n          if(returnV == false){\n              return false\n          }\n          this.setData('ltPropDefaultTime', final);\n          // restore current selection\n          $L.fastdom.mutate(function(){\n              input.selectionStart = start;\n              input.selectionEnd = end;\n          })\n     }\n\n    timeDecrease(input, evt, selection, start, end, flag) {\n        if( this.data.ltPropReadonly ){\n            return\n         }\n         var inputVal = input.value.trim(), limit, currentValue = parseInt(inputVal.slice(start, end)), interval, timeFormat = this.getData('ltPropTimeFormat'), final, meridian = this.getData('meridian');\n         if(selection == 'hour'){\n            limit = timeFormat == 12 ? 12 : 24;\n            if(flag){\n                interval = 1;\n            }else{\n                interval =  this.getData('ltPropHourInterval');\n            }\n         }else{\n            limit = 60;\n            interval =  this.getData('ltPropMinuteInterval');\n         }\n         var newVal,\n         allow;\n         if( $L.moment && $L.moment.lyteMoment.prototype.subtract ){\n            var momentFormat = timeFormat == 12 ? \"hh:mm A\" : \"HH:mm\",\n            moment;\n            inputVal = inputVal.replace( meridian.AM, 'AM' ).replace( meridian.PM, 'PM' );\n            \n            if( this.data.ltPropTimezoneHandling && this.data.ltPropCurrentDate ){\n                moment = this.check_dst( inputVal, true );\n            } else {\n                moment = $L.moment( inputVal, momentFormat );\n            }\n\n            if( moment.validate() ){\n                final = moment.subtract( interval, limit == 60 ? 'minutes' : 'hours' ).format( momentFormat ).replace( 'AM', meridian.AM ).replace( 'PM', meridian.PM );\n            } else {\n                allow = true;\n            }\n         } \n         if( allow) {\n             newVal = (currentValue - interval + limit) % limit;\n             if(limit == 12 && newVal > currentValue && inputVal.slice(6, inputVal.length) == meridian.AM){\n                 inputVal = this.replaceVal.call(this, input, meridian.PM, 6, inputVal.length);\n             } else if(limit == 12 && (newVal > currentValue || currentValue == 12) && inputVal.slice(6, inputVal.length) == meridian.PM){\n                inputVal = this.replaceVal.call(this, input, meridian.AM, 6, inputVal.length);\n             }else if(limit == 12 && newVal == 0){\n                if(inputVal.slice(6, inputVal.length) == meridian.PM){\n                    newVal = '12';\n                } \n             }else if(limit == 60 && newVal >= currentValue) {\n                var ret = this.timeDecrease.call(this, input, evt, 'hour', 0, 2, true);\n                if(ret == false){\n                    return false;\n                }\n                inputVal = input.value.trim()\n             }\n            newVal = newVal.toString();\n            if(newVal.length == 1){\n                newVal = '0' + newVal;\n            }\n            final = inputVal.slice(0, start) + newVal + inputVal.slice(end, inputVal.length);\n        }\n        var returnV = this.maxValCheck(final);\n        if(returnV == false){\n            return false\n        }\n        this.setData('ltPropDefaultTime', final);\n        // restore current selection\n        $L.fastdom.mutate(function(){\n            input.selectionStart = start;\n            input.selectionEnd = end;\n        })\n   }\n\n    findCalendarRange(evt, input, allow) {\n         // var flag = false;\n         if(input.value && this.dateValidation(input.value) != false){\n                 var start = input.selectionStart, i;\n                 var end = input.selectionEnd;\n                 var range = this.getData('dateRange');\n                 for(i in range){\n                     if( allow && i != this.data.selectedDateField ){\n                         continue;\n                     }\n                     // checking selected pos\n                      var returnedRange = this.setRangeByMoment( input, range, i );\n\n                      // One bug in this check. It will cause error when format is given without separators like MMDDYYYY\n\n                     if( ( returnedRange[ 0 ] <= start && returnedRange[ 1 ] >= start ) || allow ){\n                         if( !this.data.ltPropPreventSelection ){\n                             input.selectionStart = returnedRange[ 0 ];\n                             input.selectionEnd = returnedRange[ 1 ];\n                         } else if( allow ) {\n                            input.selectionStart = input.selectionEnd = returnedRange[ 1 ]; \n                         }\n                         this.setData('selectedDateField', i);\n                         // flag = true;\n                         break;\n                     }\n                 }\n             }\n          // return flag;   \n    }\n\n    setRangeByMoment(input, range, key) {\n       var start, end;\n       if( $L.moment ){\n           var format = this.data.ltPropFormat, \n           value = input.value,\n           is_i18n = this.data.ltPropCalendarProperties.i18n,\n           moment = $L.moment( value, this._assCalendar.component.getRelevantFormat( format ), {\n             i18n : is_i18n\n           }),\n           ns = is_i18n ? 'i18N' : 'format';\n\n           if( moment.validate() ){\n             var length = 0, sliceForm = format.slice( range [ key ] [ 0 ], range  [ key ][ 1 ] );\n             for( var i = 0; i < this.data.dateOrder.length; i++ ){\n                 var current = this.data.dateOrder[ i ], newValue = moment[ ns ]( current.format );\n                 if( current.format == sliceForm ){\n                     break;\n                 }\n                 value = value.replace( newValue, '' );\n                 length += newValue.length\n             }\n             var formatted = moment[ ns ]( sliceForm );\n             start = length + value.indexOf( formatted );\n             end = start + formatted.length;\n           } else {\n              start = range[ key ] [ 0 ];\n              end = range[ key ] [ 1 ];\n           }\n       } else {\n         start = range[ key ][ 0 ];\n         end = range[ key ][ 1 ];\n       }\n       return [ start, end ];\n    }\n\n    hideCalendar() {\n         Array.from( document.getElementsByTagName( 'lyte-input' ) ).forEach( function( item ){\n             var cal_div = item.calendarDiv;\n\n             if( item != this.$node && cal_div && !$L( cal_div ).hasClass( 'lyteCalendarHidden' ) ){\n                 item.component._hideCalendar();\n             }\n         }.bind( this ) );\n    }\n\n    _hideCalendar(bool, __force) {\n\n         var cal = this.$node.calendarDiv;\n\n         if( !cal || $L( cal ).hasClass( 'lyteCalendarHidden' ) ){\n             return;\n         }\n\n         if( !__force && !this._selected && !this.data.ltPropCalendarProperties.disableNavigation && cal.contains( document.activeElement ) ){\n             return;\n         }\n\n         var callback,\n         cb = 'onBeforeCalendarClose';\n\n         if( this.getMethods( cb ) ) {\n                /**\n                 * @method onBeforeCalendarClose\n                 * @condition ltPropType date,datetime\n                 * @version 2.2.8\n                 */            \n             callback = this.executeMethod( cb, cal, this.$node, !!this._selected );\n         }\n         if( callback == false ){\n             this.$node.focus();\n             return\n         } else if( callback && callback.then ){\n             this._calendarCloseStart = true;\n             Promise.resolve( callback ).then( this.mainHideFn.bind( this, bool ) );\n         } else {\n             this.mainHideFn( bool );\n         }\n    }\n\n    mainHideFn(bool) {\n\n         var comp = this,\n         inputs = this.$node,\n         __calendar = inputs.calendarDiv;\n\n         delete comp._calendarCloseStart;\n         __calendar.classList.add('lyteCalendarHidden')\n         inputs.classList.remove( 'calendarOpen' );\n\n         Array.from( comp._assCalendar.querySelectorAll( 'lyte-dropdown' ) ).forEach( function( item ){\n             item.close();\n         });\n\n         if( this.data.ltPropAria ){\n             $L( 'input,textarea', inputs ).attr( \"aria-expanded\", \"false\" );\n          }\n\n         if( comp.getMethods( 'onCalendarClose' ) ) {\n            /**\n             * @method onCalendarClose\n             * @condition ltPropType date,datetime\n             * @version 1.0.2\n             */            \n             comp.executeMethod( 'onCalendarClose', __calendar, inputs )\n         }\n         comp.data.ltPropHeaderType == 'drilldown' && inputs.revertToSelected();\n         if( bool ){\n             inputs.blur();\n             comp._closedbyscrl = true;\n         } \n\n         if( this.data.ltPropAria ){\n             var exst_active = document.activeElement;\n\n             if( exst_active == document.body || __calendar.contains( exst_active ) ){\n                 $L( '.lyteInputCalendarIcon', this.$node ).focus();\n             }\n\n             this.setData( \"isExpanded\", \"false\" );\n         }\n    }\n\n    showCalendar(event, input) {\n     if( this._byManual ) {\n         delete this._byManual;\n         return;\n     }\n      this.hideCalendar();\n      // removing hidden class\n       if( this.data.ltPropReadonly && !this.data.ltPropPreventKeys || this._calendarCloseStart ){\n         return;\n      }\n      if( this.getMethods( 'onBeforeOpen' )  ){\n         var retVal = this.executeMethod( 'onBeforeOpen', event, this.$node );\n         if( retVal == false ){\n             this._prevclick = true;\n             setTimeout( function(){\n                 delete this._prevclick;\n             }.bind( this ), 100 );\n             return;\n         }\n      }\n      if( !this.data.ltPropBindToBody ){\n          this.setData( 'ltPropBindToBody', true );   \n      }\n      this.$node.calendarDiv.classList.remove('lyteCalendarHidden')\n      $L.fastdom.measure( this.scrollFunc.bind( this ) );\n      // initial selection\n      $L.fastdom.mutate(function(){\n         if( !this.data.ltPropReadonly ){\n              // if( !this.data.ltPropPreventSelection ){\n              //    input.selectionStart = 0;\n              //    input.selectionEnd = 0;\n              // }\n              this.findCalendarRange(event, input );\n          }\n          this.$node.classList.add( 'calendarOpen' );\n          if( this.data.ltPropType == 'datetime' ){\n             if( this.dropdown ){\n                 this.dropdown.close();\n             }\n          }\n\n          if( this.data.ltPropAria ){\n             $L( 'input,textarea', this.$node ).attr( \"aria-expanded\", \"true\" );\n          }\n\n          // if( !this.data.ltPropCalendarProperties.disableNavigation ){\n          //    this.setData( \"navigation\", true );\n          // }\n\n\n          if( this.data.ltPropAria ){\n             window.requestAnimationFrame( function(){\n                 // this._assCalendar.focusCalendar();\n                 this.setData( \"navigation\", true );\n                 this.setData( \"isExpanded\", \"true\" );\n             }.bind( this ) );\n          }\n\n          if(this.getMethods('onCalendarOpen')){\n            /**\n             * @method onCalendarOpen\n             * @condition ltPropType date,datetime\n             * @version 1.0.2\n             */            \n             this.executeMethod('onCalendarOpen', this.$node.calendarDiv, this.$node);\n          }   \n      }.bind(this))\n    }\n\n    // calendarMousedown : function(event){\n    //      if( this.$node.calendarDiv.contains( event.target.correspondingElement || event.target ) ) {\n    //          this.preventFocus = true\n    //      }\n    // },\n\n    timeClick(evt, input, startVal) {\n     if( this.data.ltPropReadonly && !this.data.ltPropPreventKeys ){\n         return;\n     }\n     if( !this.data.ltPropReadonly && !this._emptytimeValue ){\n         var start, startVal, endVal;\n         // measuring clicked position\n             start = Math.min( 2, parseInt( ( startVal == undefined ? input.selectionStart : startVal ) / 3 ) );\n         // measuring selection \n             switch(start){\n                 case 2 : {\n                     startVal = 6;\n                     endVal = input.value.length;\n                     this.setData('selectedField', {prop : 'meridian', val : 6});\n                 }\n                 break;\n                 case 1 : {\n                     startVal = 3;\n                     endVal = 5;\n                     this.setData('selectedField', {prop : 'minute', val : 3});\n                 }\n                 break;\n                 default : {\n                     startVal = 0;\n                     endVal = 2;\n                     this.setData('selectedField', {prop : 'hour', val : 0});\n                 }\n             }\n\n         input.selectionStart = startVal;\n         input.selectionEnd = endVal;\n       }\n       if(this.dropbox && this.dropbox.classList.contains('lyteDropdownHidden') && evt.type == \"click\"){\n             this.open_dropdown();\n         }\n    }\n\n    open_dropdown() {\n         this.dropdown.ltProp( 'selected', '' );\n         this.setData('dropdownData', this.getData('originalData'));\n         this.dropdown.ltProp( 'selected', this.data.ltPropDefaultTime );\n         this.dropdown.toggle();\n    }\n\n    calendarKeydown(evt, input) {\n         \n         if( evt.key == \"Escape\" ){\n             return this._hideCalendar( void 0, true );\n         }\n\n         if( !input.value || this.data.ltPropReadonly ){\n             return;\n         }\n         var keyCode = evt.keyCode,\n\n         time = this.dateValidation(input.value);\n             if(time != false){\n                 var selected = this.getData('selectedDateField');                       \n                 if([37, 38, 39, 40, 9].indexOf(keyCode) != -1){\n                         if(input.selectionEnd == input.selectionStart){\n                             this.findCalendarRange(evt, input);\n                             selected = this.data.selectedDateField;\n                         }\n                         var start = input.selectionStart;\n                         var end = input.selectionEnd;\n                         if([38, 40].indexOf(keyCode) != -1){\n                            evt.preventDefault();\n                         switch(selected){\n                             case 'year' : {\n                                 if(keyCode == 40){\n                                     time.setFullYear(time.getFullYear() - 1);\n                                 }else{\n                                     time.setFullYear(time.getFullYear() + 1);\n                                 }   \n                             }\n                             break;\n                             case 'month' : {\n                                 if(keyCode == 40){\n                                     time.setMonth(time.getMonth()  - 1);\n                                 }else{\n                                     time.setMonth(time.getMonth() + 1);\n                                 }\n                             }\n                             break;\n                             default : {\n                                 if(keyCode == 40){\n                                     time.setDate(time.getDate() - 1);\n                                 }else{\n                                     time.setDate(time.getDate() + 1);\n                                 }\n                             }\n                         }\n                         if( this._assCalendar.component.checkDate( time ) ){\n                             this.setData('ltPropCurrentDate', this.getDateFromFormat(time, this.getData('ltPropFormat')));\n                         }\n                         $L.fastdom.measure( this.findCalendarRange.bind( this, {}, input, true ) )\n                     } else {\n                         if((input.selectionEnd == input.value.length && (keyCode == 39 || (!evt.shiftKey && keyCode == 9))) || (input.selectionStart == 0 && (keyCode == 37 || (evt.shiftKey && keyCode == 9)))){\n                             return\n                         }else{\n                             var daterange = this.getData('dateRange'),\n                             dateOrder = this.data.dateOrder,\n                             index;\n\n                             for( var i = 0; i < dateOrder.length; i++ ){\n                                 if( dateOrder[ i ].name == selected ){\n                                     index = i;\n                                     break;\n                                 }\n                             }\n\n                             if( keyCode == 39 || ( !evt.shiftKey && keyCode == 9 ) ) {\n                                 if( i + 1 == dateOrder.length ){\n                                     start = end = daterange[ selected ][ 1 ] + 1;\n                                 } else {\n                                     var returned = this.setRangeByMoment( input, daterange, dateOrder[ index + 1 ].name );\n                                     start = end = Math.abs( ( returned[ 0 ] + returned[ 1 ] ) * 0.5 )\n                                 }\n                             }else if( keyCode == 37 || ( evt.shiftKey && keyCode == 9 ) ){\n                                 if( i == 0 ){\n                                     start = end = daterange[ selected ][ 0 ] + 1;\n                                 } else {\n                                     var returned = this.setRangeByMoment( input, daterange, dateOrder[ index - 1 ].name );\n                                     start = end = Math.abs( ( returned[ 0 ] + returned[ 1 ] ) * 0.5 )\n                                 }\n                             }\n                             $L.fastdom.measure( this.findCalendarRange.bind( this, {}, input ) );\n                             if( this.data.ltPropPreventSelection ){\n                                 return;\n                             }\n                             // start = input.selectionStart;\n                             // end = input.selectionEnd;\n                             evt.preventDefault();\n                         }\n                     }\n                     // restore current selection\n                     // $L.fastdom.mutate(function(){\n                         input.selectionStart = start;\n                         input.selectionEnd = end;\n                     // })\n                  }\n              }\n    }\n\n    focusCallback(evt) {\n         if( this.getMethods( 'onFocus' ) ) {\n            /**\n             * @method onFocus\n             * @version 1.0.6\n             */            \n             this.executeMethod( 'onFocus', evt, this.$node )\n         }\n    }\n\n    focusout() {\n         if(!this.preventFocus){\n             var cal = this.$node.calendarDiv;\n             if( !cal || cal.classList.contains('lyteCalendarHidden') ) {\n                 return\n             }\n\n             var data = this.data;\n\n             if( data.navigation ){\n                 return;\n             }\n\n             clearTimeout( this._hidecall );\n             this._hidecall = setTimeout( this._hideCalendar.bind( this ), 0 );\n         }else {\n             delete this.preventFocus;\n         }\n    }\n\n    maxLen(value) {\n\n         var max = this.data.ltPropMaxlength;\n         return max != undefined ? value.toString().match( new RegExp('.{0,' + max + '}') )[ 0 ] : value;\n    }\n\n    showCalendarAction(event, input) {\n          var $node = this.$node;\n\n         $node.classList.add( 'lyteInputFocus' )\n         this.focusCallback.call( this, event );\n\n         if( this.data.ltPropAria ){\n             return;\n         }\n\n         if( $L( $node.calendarDiv ).hasClass( 'lyteCalendarHidden' ) || !this.data.ltPropBindToBody ){\n             this.showCalendar( event, input );\n         }\n    }\n\n    input_blur(event, flag) {\n\n         var r_target = event.relatedTarget;\n\n         if( this.data.ltPropAria && r_target && this.$node.contains( r_target ) ){\n             return;\n         }\n\n\n         delete this._lasttyped;\n         var ty = /date/i.test( this.data.ltPropType ), \n         mt = this.getMethods( 'onBlur' );\n\n         if( ty ){\n             if( r_target && this.data.ltPropHeaderType == \"dropdown\" ){\n                 var drop = r_target.closest( 'lyte-drop-box' );\n                 if( drop ){\n                     var origindd = drop.origindd,\n                     $node = this.$node,\n                     wormhole = $node.calendarComp;\n\n                     if( origindd && wormhole && wormhole.contains( origindd ) ){\n                         return $node.focus();\n                     }\n                 }\n             }\n\n         }\n\n\n         this.$node.classList.remove( 'lyteInputFocus' )\n         if( !flag ) {\n             var type = this.getData( 'ltPropType' )\n             if( this._calmsfg ) {\n                 this.valUpdate();\n                 clearTimeout( this._blurcall );\n                 this._blurcall = setTimeout( function(){\n                     if( ty ){\n                         this.focusout.call( this )\n                     }\n                     if( mt ) {\n                         this.executeMethod( 'onBlur', event, this.$node )\n                     }\n                 }.bind( this ), 0)\n                 delete this._calmsfg;\n             } else {\n                 if( type == \"number\" ) {\n                     var max = this.data.ltPropMax,\n                     min = this.data.ltPropMin,\n                     value = parseFloat( event.target.value ),\n                     happened = false;\n\n                     if( !isNaN( value ) ){\n                         if( [ undefined, null, '' ].indexOf( min ) == -1 && min.constructor == Number ){\n                             value = Math.max( min, value );\n                             happened = value == min;\n                         } \n                         if( [ undefined, null, '' ].indexOf( max ) == -1 && max.constructor == Number ){\n                             value = Math.min( max, value );\n                             happened = happened || ( value == max );\n                         }\n                         if( happened ){\n                             event.target.value = value;\n                         }\n                     }\n                 }\n                 this.valUpdate.call( this );\n                 if( ty ){\n                     this.focusout.call( this )\n                 }\n                 if( mt ) {\n                    /**\n                     * @method onBlur\n                     * @version 1.0.6\n                     */                            \n                     this.executeMethod( 'onBlur', event, this.$node )\n                 }\n             }\n         }\n    }\n\n    open_cal_for_icon(evt) {\n         if(  $L( this.$node.calendarDiv ).hasClass( 'lyteCalendarHidden' ) || !this.data.ltPropBindToBody ){\n             this.showCalendar( evt, this.$node.getElementsByTagName( 'input' )[ 0 ] );\n         }\n    }\n\n    static actions() {\n        return {\n\n                calendarKey : function( evt ){\n                    if( evt.key == \"Escape\" ){\n                        this._hideCalendar( void 0, true );\n                    }\n                },\n\n                togglePassword : function(){\n                    this.setData( 'ltPropPasswordVisibility', !this.data.ltPropPasswordVisibility );\n                },\n\n                calIconClick : function( evt, __this ){\n                    this.open_cal_for_icon( evt );\n                },\n\n                calIconFocus : function( evt, __this ){\n                    var __rel = evt.relatedTarget;\n\n                    if( __rel && this.$node.contains( __rel ) ){\n                        return;\n                    }\n\n                    this.showCalendarAction( evt, __rel );\n                },\n\n                calIconBlur : function( evt ){\n\n                    var __rel = evt.relatedTarget,\n                    calendar = this._assCalendar;\n\n                    if( !( calendar && __rel && calendar.contains( __rel ) ) ){\n                        this._hideCalendar();\n                    }\n\n                    if( __rel && this.$node.contains( __rel ) ){\n                        return;\n                    }\n\n                    this.input_blur( evt );\n                },\n\n                calIconKey : function( evt ){\n                    switch( evt.key ){\n                        case \"Enter\" :\n                        case ' ' : {\n                             this.open_cal_for_icon( evt );\n                        }\n                        break;\n                    }\n                },\n\n                resizeSelect : function( evt ){\n                    this.rsizefun( evt )\n                },\n\n                preventDrag : function( evt ){\n                    evt.preventDefault();\n                },\n\n                clsIcon : function( evt ){\n                    this.$node.ltProp( 'value', '' );\n                    this.$node.focus();\n                    if( this.data.isSearch ){\n                        /**\n                         * @event on-ip-clear\n                         * @version 2.0.0\n                         */                    \n                        this.throwEvent( 'on-ip-clear', evt );\n                    }\n                    if( this.getMethods( 'onClear' ) ) {\n                        /**\n                         * @method onClear\n                         * @version 2.0.0\n                         */                    \n                        this.executeMethod( 'onClear', evt, this.$node );\n                    }\n                },\n\n                calmsdown : function( evt, _this ){\n                    this._calmsfg = true;\n\n                    var target = evt.target;\n\n                    if( this.$node.calendarDiv.contains( target.correspondingElement || target ) ) {\n                        this.preventFocus = true\n                    }\n                },\n\n                 numberKeydown : function( evt, _this ){\n                    var ff = /firefox/ig.test( window.navigator.userAgent );\n                    if( !( window._lyteUiUtils.isAndroid && !( ff ) ) ) {\n                        var key = evt.which || evt.keyCode, prev, value = _this.value, isIE = /rv:11/ig.test( window.navigator.userAgent );\n                        if( /^(8|9|27|37|39|13|187|189)$/.test( key ) || ( ff && /^173$/i.test( key ) ) || ( key >= 48 && key <=57 ) || ( key >= 96 && key <= 105 ) || evt.metaKey || evt.ctrlKey || ( /^(38|40)$/.test( key ) && !isIE ) ){\n                            return;\n                        }\n                        if( /^(69|190)$/.test( key ) ){\n                            if( ( !/\\./i.test( value ) && key == 190 ) || ( key == 69 && ( !/e/i.test( value ) && value != \"\" ) ) ) {\n                                return;\n                            }\n                        }\n                        evt.preventDefault();\n                        if( key == 38 ){\n                            value = Number( value || 0 ) + Number( _this.step );\n                        } else if( key == 40 ) {\n                            value = Number( value || 0 ) - Number( _this.step );\n                        }\n                        if( isIE && /^(38|40)$/.test( key ) ){\n                            var newVal = parseInt( this.maxLen( value ) );\n                            if( !isNaN( newVal ) ) {\n                                newVal = Math.min( Math.max( newVal, _this.min ? _this.min : -Infinity ), _this.max ? _this.max : Infinity );\n                                if( !isNaN( newVal ) ) {\n                                    _this.value = newVal;\n                                }\n                            }\n                        }\n                     }\n                 },\n\n                 numberPaste : function( evt, _this ) {\n                    var clip = evt.clipboardData || window.clipboardData,\n                    newVal = _this.value + clip.getData( 'text' ).replace(/\\'|\\\"/g, '');\n                    if( /^([0-9]+|\\.(?!e){1,}|\\+|\\-)([0-9\\.\\e]{0,}$)/i.test( newVal ) ){\n                        return;\n                    }\n                    if( newVal.length == this.maxLen( newVal ) && !/rv:11/ig.test( window.navigator.userAgent ) ){\n                        return;\n                    }\n                    evt.preventDefault();\n                 },\n\n                 focusClass : function(evt){\n                    this.$node.classList.add( 'lyteInputFocus' )\n                    this.focusCallback.call( this, evt )\n                 },\n\n                 \"blurThrow\":function(event, flag){\n                    this.input_blur( event, flag );\n                 },\n\n                 input : function( evt, _this ){\n                    if( this.data.ltPropType == 'number' ){\n                        var value = _this.value, newVal1 = this.maxLen( value ), newVal;\n                        newVal = Math.min( newVal1, _this.max != undefined && _this.max != '' ? _this.max : Infinity )\n                        if( value !== newVal1 || newVal1 != newVal ){\n                            if( newVal1 == newVal ) {\n                                _this.value = newVal1;\n                            } else if ( isNaN( newVal ) ){\n                                _this.value = parseFloat( newVal1 );\n                            } else {\n                                _this.value = newVal;\n                            }\n                        }\n                    }\n                    if(this.getData('ltPropAutoUpdate')){\n                        clearTimeout( this._iptime );\n                        var updly = this.data.ltPropUpdateDelay;\n                        if( updly != undefined ){\n                            this._iptime = setTimeout( this.valUpdate.bind( this ), updly );\n                        } else {\n                            this.valUpdate.call( this );\n                        }\n                    }\n                 },\n\n                 \"showcalendar\":function(event, input){\n                    this.showCalendarAction( event, input );\n                 },\n\n                 calendarClick : function(evt, input){\n                    \n                    var __focus = this._focus,\n                    __data = this.data;\n\n                    if( __focus && window._lyteUiUtils.isMobile || ( __data.ltPropReadonly && !__data.ltPropPreventKeys ) ){      \n                        delete this._focus;     \n                        return;     \n                    }\n                    if( !__focus && /date/i.test( __data.ltPropType ) && !this._prevclick ){\n                        \n                        var calendar_elem = this.$node.calendarDiv;\n\n                        if( !this.data.ltPropAria && ( !calendar_elem || $L( calendar_elem ).hasClass( 'lyteCalendarHidden' ) ) ){\n                            this.showCalendar( evt, input);\n                        }\n                    }\n                    this.findCalendarRange(evt, input);\n                 },\n\n                 calendarKeydown : function(){\n                    this.calendarKeydown.apply(this, arguments)\n                 },\n\n                 timeBlur : function(evt, input){\n                    if( this._emptytimeValue && input.value ){\n                        this.checkTimeStr( input, true );\n                    } else if( this.data.ltPropValidateOnBlur && !this._emptytimeValue ){\n                        var ret = this._getCrctHour( input.value, this.data.ltPropTimeFormat, this.data.meridian );\n                        this.setData( 'ltPropDefaultTime', ret ? ret : this._findNearest( input.value, this.data.ltPropTimeFormat ) );\n                    }\n                    this.$node.classList.remove( 'lyteInputFocus' )\n                    this.setData('selectedField', {});\n                    if( this.getMethods( 'onBlur' ) ) {\n                        if( this._calmsfg ){\n                            this.executeMethod( 'onBlur', evt, this.$node )\n                        } else {\n                            setTimeout( function(){ \n                                this.executeMethod( 'onBlur', evt, this.$node )\n                            }.bind( this ), 0 )\n                        }\n                    }\n                 },\n\n                 timeInput : function( _this ){\n                    if( this._emptytimeValue ){\n                        this.checkTimeStr( _this );\n                    } else {\n                        var value = _this.value || \"\",\n                        format = this.data.ltPropTimeFormat,\n                        form,\n                        meridian = this.data.meridian;\n                        if( format == 12 ){\n                            form = \"hh:mm A\";\n                            value = value.replace( meridian.AM, 'AM' ).replace( meridian.PM, 'PM' );\n                        } else {\n                            form = \"HH:mm\";\n                        }\n                        if( value && $L.moment && !$L.moment( value, form ).validate() ){\n                            _this.value = this.data.ltPropDefaultTime;\n                        }\n                    }\n\n                 },\n\n                 timeFocus : function(evt, input){\n                    this.$node.classList.add( 'lyteInputFocus' )\n                    var value = input.value.trim();\n                    this.setData('selectedField', {prop : 'hour', val : 0});\n                    input.selectionStart = 0;\n                    this.fixSelection.call(this, 0, {prop : 'hour', val : 0}, input);\n                    this.focusCallback.call( this, evt )\n                 },\n\n                 timeKeydown : function(evt, input){\n                    if( this.data.ltPropReadonly || this._emptytimeValue ){\n                        return;\n                    }\n\n\n                    if( /enter/i.test( evt.key ) ){\n                        if( this.data.ltPropAria && $L( this.dropbox ).hasClass( 'lyteDropdownHidden' ) ){\n                            this.open_dropdown();\n                            // evt.preventDefault();\n                            evt.stopPropagation();\n                            evt.stopImmediatePropagation();\n                        }\n                        return;\n                    }\n\n\n                    var selectedField = this.getData('selectedField'), meridian = this.getData('meridian'), timeFormat = this.getData('ltPropTimeFormat'), flag = true, oriDrop = this.getData('originalData'), rendered = this.getData('dropdownData'),\n                    keyCode = window._lyteUiUtils.getCorrectNumberCode( evt.which || evt.keyCode ),\n                    prev_nav = this.data.ltPropPreventDropdownNavigation,\n                    is_drop_open =  this.dropbox && !$L( this.dropbox ).hasClass( 'lyteDropdownHidden' );\n\n                    if( !prev_nav && is_drop_open && /38|40|13/.test( keyCode ) ){\n                        return;\n                    }\n\n                    if( prev_nav && is_drop_open && /38|40/.test( keyCode ) ){\n                        evt.stopPropagation();\n                    }\n\n                    if(selectedField.prop && !( evt.ctrlKey || evt.metaKey ))\n                        {\n                            var start = input.selectionStart, end = input.selectionEnd;\n                            if(start == end){\n                                this.timeClick( {}, input, start );\n                                start = input.selectionStart, end = input.selectionEnd;\n                                selectedField = this.getData('selectedField');\n                            } else {\n                                if( start == 0 && end == input.value.length ){\n                                    start = 0;\n                                    end = 2;\n                                    this.timeClick(  {}, input, start );\n                                    selectedField = this.getData( 'selectedField' );\n                                }\n                            }\n                            var dontcall;\n                            if(keyCode != 9){\n                                evt.preventDefault();\n                            }\n                            if([9, 37, 39].indexOf(keyCode) != -1){\n                                if((evt.shiftKey || keyCode == 37) && selectedField.prop != 'hour' && keyCode != 39){\n                                    this.fixSelection.call(this, -3, selectedField, input);\n                                    evt.preventDefault();\n                                    dontcall = true;\n                                }\n                                else if((((!evt.shiftKey || keyCode == 39) && selectedField.prop != 'minute' && timeFormat == 24) || (!evt.shiftKey && selectedField.prop != 'meridian' && timeFormat == 12)) && keyCode != 37){\n                                    this.fixSelection.call(this, 3, selectedField, input);\n                                    evt.preventDefault();\n                                    dontcall = true;\n                                }\n                                flag = false;\n\n                            }else if(keyCode >=48 && keyCode <= 57 && selectedField.prop != 'meridian'){\n                                if(selectedField.prop == 'hour'){\n                                    this.hourTimeSet.call(this, input, evt, \"hour\", start, end);\n                                }else if(selectedField.prop == 'minute'){\n                                    this.hourTimeSet.call(this, input, evt, 'minute', start, end);\n                                }\n                                this.data.ltPropDropdown && this.constructNewDrop(input, timeFormat);\n                            }else if((keyCode == 38 || keyCode == 40) && selectedField.prop != 'meridian'){\n                                if(keyCode == 38){\n                                    this.timeIncrease.call(this, input, evt, selectedField.prop, start, end);\n                                }\n                                else{\n                                    this.timeDecrease.call(this, input, evt, selectedField.prop, start, end);\n                                }\n                                flag = false;\n                                dontcall = true;\n                            }else if(selectedField.prop == 'meridian'){\n                                var val = input.value.trim().slice(6,input.value.length), final, key = String.fromCharCode(keyCode).toUpperCase();\n                                if(meridian.PM.toUpperCase().indexOf(key) == 0){\n                                    val = meridian.PM;\n                                }else if(meridian.AM.toUpperCase().indexOf(key) == 0){\n                                    val = meridian.AM;\n                                }\n                                else if([38, 40].indexOf(keyCode) != -1){\n                                    if(val == meridian.PM){\n                                        val = meridian.AM\n                                    }else{\n                                        val = meridian.PM\n                                    }\n                                }\n                                if(val != meridian.AM){\n                                //  if(input.value.trim().slice(0, 2) == '12'){\n                                //      final = this.replaceVal.call(this, input, '00', 0, 2);\n                                //  }\n                                // }else{\n                                    if(input.value.trim().slice(0, 2) == '00'){\n                                        final = this.replaceVal.call(this, input, '12', 0, 2);\n                                    }\n                                }\n                                if(val){\n                                    final = this.replaceVal.call(this, final ? final : input, val, start, end);\n                                }\n                                if( !this.data.ltPropValidateOnBlur ){\n                                    var returnV = this.maxValCheck(final);\n                                    if(returnV == false){\n                                        return false;\n                                    }\n                                }\n                                this.setData('ltPropDefaultTime', final);\n                                flag = false;\n                            }\n                            !dontcall && this.fixSelection.call(this, 0, this.getData('selectedField'), input);\n                         if(flag)\n                            {\n                                $L.fastdom.mutate(function(){\n                                    // restore current selection\n                                    input.selectionStart = start;\n                                    input.selectionEnd = end;\n                                })\n                            }\n                         if(oriDrop.length != rendered.length && (keyCode < 48 || keyCode > 57)){\n                            this.dropdown.ltProp( 'selected', '' );\n                            this.setData('dropdownData', oriDrop);\n                            this.dropdown.ltProp( 'selected', this.data.ltPropDefaultTime );\n                         }  \n                      } else if( /^8|46$/i.test( keyCode ) ) {\n                        evt.preventDefault();\n                      }\n                 },\n\n                 timeClick : function(){\n                    this.timeClick.apply(this, arguments)\n                 }\n         };\n    }\n\n    checkTimeStr(_this, frmblur) {\n       if( this._emptytimeValue ){\n           var value = _this.value || \"\",\n           format = this.data.ltPropTimeFormat,\n           form,\n           meridian = this.data.meridian;\n           if( format == 12 ){\n               form = \"hh:mm A\";\n               value = value.replace( meridian.AM, 'AM' ).replace( meridian.PM, 'PM' );\n           } else {\n               form = \"HH:mm\";\n           }\n           if( value && $L.moment( value, form ).validate() ){\n               var ret = this._getCrctHour( _this.value, format, meridian );\n               this.setData( 'ltPropDefaultTime', ret ? ret : this._findNearest( _this.value, format ) );\n               delete this._emptytimeValue;\n           } else if( value && frmblur ){\n               if( this.data.ltPropStartTime == this.data.ltPropDefaultTime ){\n                   this.setData( 'ltPropDefaultTime', \"\" );\n               }\n               this.setData( 'ltPropDefaultTime', this.data.ltPropStartTime );\n               delete this._emptytimeValue;\n           }\n       }\n    }\n\n    check_dst(arr, check, return_value) {\n       var Lc = this.$addon.objectUtils,\n       moment = $L.moment,\n       _this = this,\n       data = _this.data,\n       date = data.ltPropCurrentDate,\n       format = data.ltPropFormat,\n       timeFormat = data.ltPropTimeFormat == 12,\n       __format = timeFormat ? 'hh:mm A' : 'HH:mm',\n       fn = function( item ){            \n           return $L.moment( date + ' ' + item.time, format + ' ' + __format ).format( __format ) != item.time;\n       },\n       common = function( item ){\n           if( item.className ){\n               Lc( item, 'delete', 'className' );\n           }\n       };\n\n       if( !moment ){\n           return;\n       }\n\n       if( check ){\n           if( date ){\n               var __moment = $L.moment( date + ' ' + arr, format + ' ' + __format  );\n               if( return_value ){\n                   return __moment.format( __format );\n               }\n               return __moment;\n           }\n           if( return_value ){\n               return arr;\n           }\n           return $L.moment( arr, __format  );\n       }\n\n       if( date ){\n           arr.forEach( function( item ){\n               if( fn( item ) ){\n                   if( !item.className ){\n                       Lc( item, 'add', 'className', 'lyteDropdownActive' );\n                   }\n               } else {\n                   common( item );\n               }\n           });\n       } else {\n           arr.forEach( common );\n       }\n    }\n\n    static observers() {\n        return {\n            textareaFuncObs : function(){\n                var __this = this,\n                __data = __this.data;\n\n                if( __data.ltPropType == \"textarea\" ){\n                    var resize = __data.ltPropTextAreaResize,\n                    __horizontal = resize.horizontal,\n                    __vertical = resize.vertical,\n                    to_value = ( __horizontal || __vertical ),\n                    __class = \"lyteTextareaResize\",\n                    vert = 'lyteTextareaResizeVertical',\n                    hori = 'lyteTextareaResizeHorizontal';\n\n                    this.setData( 'resize', to_value );\n\n                    if( !to_value ){\n                        $L( this.$node ).addClass( 'lyteTextareaNoResize' );\n                    }\n\n                    if( __horizontal && !__vertical ){\n                        __class += ( \" \" + hori );\n                    } else if( __vertical && !__horizontal ){\n                        __class += ( \" \" + vert );\n                    }\n\n                    this.setData( 'resizeClass', __class )\n                }\n            }.observes( 'ltPropTextAreaResize', 'ltPropTextAreaResize.{}' ).on( 'didConnect' ),\n\n            btobody : function( arg ){\n                if( !arg.newValue ){\n                    delete this.$node.revertToToday;\n                }\n            }.observes( 'ltPropBindToBody' ),\n\n            disAbs : function(){\n                this.$node.classList[ this.data.ltPropDisabled ? 'add' : 'remove' ]( 'lyteInputDisabled' );\n            }.observes( 'ltPropDisabled' ).on( 'didConnect' ),\n\n            readAbs : function(){\n                this.$node.classList[ this.data.ltPropReadonly ? 'add' : 'remove' ]( 'lyteInputReadonly' );\n            }.observes( 'ltPropReadonly' ).on( 'didConnect' ),\n\n            heightFuncObs : function( arg ){\n                this.heightFunc();\n            }.observes('ltPropHeight').on('didConnect'),\n\n            widthfunObs : function(){\n                this.widthfun();\n            }.observes( 'ltPropWidth' ).on( 'didConnect' ),\n\n            appearanceFunObs : function(){\n                this.appearanceFun();\n            }.observes('ltPropAppearance').on('didConnect'),\n\n            directionfunObs : function(){\n                this.directionfun();\n            }.observes('ltPropDirection').on('didConnect'),\n\n            input_wrap_obs : function( arg ){\n                var oldValue = ( arg || { oldValue : \"\" } ).oldValue,\n                newValue = this.data.ltPropInputWrapperClass,\n                __$node = $L( this.$node );\n\n                __$node.removeClass( oldValue ).addClass( newValue );\n\n                if( !arg && this.data.ltPropAria && /date/i.test( this.data.ltPropType ) ){\n                    __$node.addClass( \"lyteInputWithCalendarIcon\" );\n                }\n\n            }.observes( 'ltPropInputWrapperClass' ).on( 'didConnect' ),\n\n            focusObs : function(){\n                var __data = this.data,\n                $node = this.$node;\n\n                if( __data.ltPropFocus ){\n                    $node.focus();\n                    \n                    if( __data.ltPropFocusAtEnd ){\n                        var elem = $node.getElementsByTagName( __data.ltPropType == \"textarea\" ? \"textarea\" : \"input\" )[ 0 ];\n\n                        if( elem ){\n                            window.requestAnimationFrame( function(){\n                                elem.selectionStart = elem.value.length;\n                            } );\n                        }\n                    }\n                }\n                // this.data.ltPropFocus = false\n                $node.ltProp( 'focus', false );\n\n            }.observes( 'ltPropFocus').on( 'didConnect' ),\n\n            boxObs : function( arg ){\n                var type = this.data.ltPropType,\n                appearance = this.data.ltPropAppearance;\n\n                if( type == \"search\" && appearance == \"box\" ){\n                    this.setData( 'isBox', 'lyteInputBoxSearch' );\n                } else {\n                    this.setData( 'isBox', '' );\n                }\n\n                if( arg && arg.item == \"ltPropType\" ){\n                    this.didDestroy( true );\n                    this.init( true );\n                    this.didConnect( true );\n                }\n\n            }.observes( 'ltPropType', 'ltPropAppearance' ).on( 'init' ),\n\n            dateRegexObs : function( arg ){\n                this.dateRegexFind( arg );\n            }.observes('ltPropFormat'),\n\n            timeFormatChange : function(){\n                this.timeInValChange();\n            }.observes('ltPropTimeFormat'),\n\n            wheelObs : function(arg){\n                if(arg.newValue){\n                    this.$node.addEventListener('wheel', this.getData('eventListeners.timeWheel'));\n                }else{\n                    this.$node.removeEventListener('wheel', this.getData('eventListeners.timeWheel'));\n                }\n            }.observes('ltPropWheel'),\n\n            timeBoundObs : function(arg){\n                if(arg &&  arg.newValue == \"\" && arg.oldValue == undefined) {\n                    return\n                }\n                if(!arg || (arg && arg.item != 'ltPropDefaultTime')){\n                    this.startEndTimeObs(arg);\n                }else{\n                    if( arg && !arg.newValue ){\n                        this.timeInValChange();\n                        return;\n                    }\n                    if(this.setData('preventObs')){\n                        this.setData('ltPropValue', arg.newValue);\n                    }\n\n                    this.englishTime();\n\n                    if(this.getMethods('onTimeChange')){\n                       /**\n                        * @method onTimeChange\n                        * @version 1.0.2\n                        * @condition ltPropType time,datetime\n                        */                \n                        this.executeMethod('onTimeChange', arg, this.$node);\n                    }\n                    this._manualset = true;\n                    if( this.data.ltPropType == 'time' ) {\n                        this.setData( 'ltPropValue', arg.newValue )\n                    } else {\n                        this.checkCommonPlaceHolder();\n                    }\n                    delete this._manualset;\n                }\n            }.observes('ltPropStartTime', 'ltPropEndTime', 'ltPropDefaultTime'),\n\n            dateChangeCallback : function( arg ){\n\n                var __type = this.data.ltPropType;\n\n                if( this.data.ltPropTimezoneHandling ){\n                    this.check_dst( this.data.originalData );\n\n                    var default_time = this.data.ltPropDefaultTime;\n\n                    if( default_time ){\n                        this.setData( 'ltPropDefaultTime', this.check_dst( default_time, 1, 1 ) );\n                    }\n\n                    if( __type == \"time\" ){\n                        return;\n                    }\n                }\n\n                var callDelay = this.data.ltPropCallbackDelay;\n\n                this._manualset = true;\n                if( __type ) {\n                    this.setData( 'ltPropValue', arg.newValue )\n                } \n                delete this._manualset;\n                if( callDelay == undefined ){\n                    this.dateCallback( arg );\n                } else {\n                    clearTimeout( this.__datachange );\n                    this.__datachange = setTimeout( this.dateCallback.bind( this ), callDelay, arg );\n                }\n                this.checkCommonPlaceHolder();\n            }.observes('ltPropCurrentDate'),\n\n            valChangeObs : function(arg){\n                var callDelay = this.data.ltPropCallbackDelay;\n                if( !this._manualset ){\n                    var tp = this.data.ltPropType;\n                    if( tp == 'date' ) {\n                        this.setData( 'ltPropCurrentDate', arg.newValue );\n                    } else if( tp == \"time\" ) {\n                        this.setData( 'ltPropDefaultTime', arg.newValue );\n                    }\n                }\n                if( callDelay == undefined ){\n                    this.timeCallback( arg );\n                } else {\n                    clearTimeout( this.__valuechange );\n                    this.__valuechange  = setTimeout(this.timeCallback.bind(this), callDelay , arg);\n                }\n            }.observes('ltPropValue'),\n\n            firePosCallBack: function() {\n\n                var calendar = this.$node.calendarDiv,\n                pos = this.data.pos;\n\n                $L( calendar ).removeClass( 'lyteInputCalendarUp lyteInputCalendarDown' ).addClass( 'lyteInputCalendar' + ( /up/i.test( pos ) ? 'Up' : 'Down' ) );\n\n                if( this.getMethods( 'onPositionChanged' )) {\n                   /**\n                    * @method onDateChange\n                    * @version 1.0.6\n                    * @condition ltPropType time,datetime\n                    */            \n                    this.executeMethod( 'onPositionChanged', pos, calendar );\n                }\n            }.observes('pos'),\n\n            password_obs : function( arg ){\n\n                 var __data = this.data,\n                 __visibility = __data.ltPropPasswordVisibility;\n\n                 if( __data.ltPropType == \"password\" && __data.ltPropPasswordIcon ){\n                     this.setData({\n                         passwordClass : 'lyteInput' + ( __visibility ? 'Hide' : \"Show\" ) + 'PasswordIcon',\n                         passwordTooltip : __data.ltPropPasswordTooltip[ __visibility ? \"hide\" : \"show\" ],\n                         ltPropFocus : true\n                     });\n\n                     var __input = this.$node.getElementsByTagName( \"input\" )[ 0 ];\n\n                     __input.setAttribute( \"type\", __visibility ? \"text\" : \"password\" );\n                     window.requestAnimationFrame( function(){\n                         __input.selectionStart = __input.selectionEnd = __input.value.length;\n                     });\n\n                     if( !arg ){\n                         $L( this.$node ).addClass( 'lyteInputWithPasswordToggleButton' );\n                     }\n                 }\n\n            }.observes( 'ltPropPasswordVisibility' ).on( 'didConnect' ),\n\n            attrObs : function( arg ){\n\n               var data = this.data;\n\n               if( data.ltPropAria ){\n                   var elems = $L( \"input,textarea\", this.$node ),\n                   aria1 = \"ltPropAriaAttributes\",\n                   aria2 = \"ltPropTimeAriaAttributes\";\n\n                   if( !arg || arg.item == aria1 ){\n                       window._lyteUiUtils.setAttribute( elems.get( 0 ), data[ aria1 ] || {}, arg ? arg.oldValue : {} )\n                   }\n\n                   if( data.ltPropType == \"datetime\" && ( !arg || arg.item == aria2 ) ){\n                       window._lyteUiUtils.setAttribute( elems.get( 1 ), data[ aria2 ] || {}, arg ? arg.oldValue : {} )\n                   }\n               }\n\n            }.observes( 'ltPropAriaAttributes', 'ltPropAriaAttributes.{}', 'ltPropTimeAriaAttributes' ).on( 'didConnect' ),\n\n            single_obs : function( arg ){\n\n               if( !arg.path ){\n                   return;\n               }\n\n               var key = arg.path.replace( /^\\./, '' ),\n               newValue = arg.newValue,\n               data = this.data;\n\n               if( data.ltPropAria ){\n                   var obj = {};\n                   obj[ key ] = newValue;\n\n                   window._lyteUiUtils.setAttribute( $L( 'input,textarea', this.$node ).get( /time/i.test( arg.item ) ? -1 : 0 ), obj, {} );\n               }\n\n            }.observes( 'ltPropAriaAttributes.*', 'ltPropTimeAriaAttributes.*' )\n        };\n    }\n}\n\n[ 'click', 'scroll', 'resize', 'orientationchange' ].forEach( function( item ){\n    window.addEventListener( item, window._lyteInput, true ); \n} )\n\n/**\n * @syntax Text\n * @attribute ltPropType=text\n * <lyte-input  lt-prop-type=\"text\" lt-prop-placeholder=\"enter text here\" lt-prop-label=\"Name\"> </lyte-input>\n */\n\n/**\n * @syntax Number\n * @attribute ltPropType=number\n * <lyte-input lt-prop-label=\"Age\" lt-prop-type=\"number\"  lt-prop-placeholder=\"Enter number here\"> </lyte-input>\n */\n\n/**\n * @syntax Textarea\n * @attribute ltPropType=textarea\n * <lyte-input lt-prop-type=\"textarea\" lt-prop-id=\"lyteinput\" lt-prop-placeholder=\"Enter your comments\" lt-prop-label=\"Comments\" lt-prop-rows=\"5\" lt-prop-cols=\"80\" > </lyte-input>\n */\n\n/**\n * @syntax Date\n * @attribute ltPropType=date\n * <lyte-input lt-prop-type=\"date\" lt-prop-id=\"lyteinput\" lt-prop-format=\"MM/DD/YYYY\" lt-prop-label=\"Select DOB\" lt-prop-placeholder=\"Select your DOB\" > </lyte-input>\n */\n\n/**\n * @syntax Time\n * @attribute ltPropType=time\n * <lyte-input lt-prop-type=\"time\" lt-prop-time-format=12 lt-prop-wheel=true lt-prop-label=\"Select Time\" > </lyte-input>\n */\n\n/**\n * @syntax Date Time\n * @attribute ltPropType=datetime\n * <lyte-input lt-prop-type=\"datetime\" lt-prop-placeholder=\"Select Date\" lt-prop-format=\"MM/DD/YYYY\" lt-prop-label=\"Date & Time\"  > </lyte-input>\n */\n\n/**\n * @syntax Date Yielded\n * @attribute ltPropType=date\n * @attribute ltPropYield=true\n * <lyte-input lt-prop-type=\"date\" lt-prop-yield = true lt-prop-format=\"MM/DD/YYYY\" lt-prop-label=\"Select DOB\" lt-prop-placeholder=\"Select your DOB\" > \n *     <template is = \"registerYield\" yield-name = \"footer\">\n *         calendar footer\n *     </template>\n * </lyte-input>\n */\n\n/**\n * @syntax Time Yielded\n * @attribute ltPropType=time\n * @attribute ltPropYield=true\n * <lyte-input lt-prop-type=\"time\" lt-prop-yield = true lt-prop-time-format=12 lt-prop-wheel=true lt-prop-label=\"Select Time\" > </lyte-input>\n *     <template is = \"registerYield\" yield-name = \"item\">\n *         {{itemValue.time}}\n *     </template>\n * </lyte-input>\n */\n\n/**\n * @syntax Date Time yielded\n * @attribute ltPropType=datetime\n * @attribute ltPropYield=true\n * <lyte-input lt-prop-type=\"datetime\" lt-prop-yield = true lt-prop-placeholder=\"Select Date\" lt-prop-format=\"MM/DD/YYYY\" lt-prop-label=\"Date & Time\"  > </lyte-input>\n *     <template is = \"registerYield\" yield-name = \"item\">\n *         {{itemValue.time}}\n *     </template>\n *     <template is = \"registerYield\" yield-name = \"footer\">\n *         calendar footer\n *     </template>\n * </lyte-input>\n */\n\n/**\n* @syntax Password\n* @attribute ltPropType=password\n* <lyte-input lt-prop-type=\"password\" lt-prop-label=\"password\" lt-prop-placeholder=\"Enter password here\"> </lyte-input>\n* </lyte-input>\n*/\n\n/**\n* @syntax staticBuilder\n* @attribute ltPropType=text\n* <lyte-input lt-prop-type=\"text\" lt-prop-placeholder=\"enter text here\" lt-prop-label=\"Name\"> </lyte-input>\n*/\nexport { LyteInputComponent };","import './lyte-wormhole.js';\nimport { prop } from \"@slyte/core\";\nimport { Component } from \"../component.js\";\nimport $L from \"@zoho/lyte-dom\";\n\nwindow.addModalEvent = function(event) {\n    window.addEventListener('resize',function(event){\n        // console.log(Math.max(document.documentElement.clientHeight, window.innerHeight || 0));\n        if(window.LytePopup._lyteModalRTId){\n            // console.log(LytePopup._lyteModalRTId);\n            clearTimeout(window.LytePopup._lyteModalRTId);\n            window.LytePopup._lyteModalRTId = false;\n        }\n        window.LytePopup._lyteModalRTId = setTimeout(function(){\n            // for(var i = LytePopup.components.length - 1 ; i >= 0 ; i--){\n            for(var i = 0  ; i < LytePopup.components.length ; i++){\n            // console.log(LytePopup.components[i].$node);\n                if(LytePopup.components[i].$node && LytePopup.components[i].$node.nodeName == \"LYTE-MODAL\" && LytePopup.components[i].childComp.style.visibility == \"visible\" && LytePopup.components[i].childComp.querySelector('.lyteModal')){\n                    LytePopup.components[i].$node.component.setData('resizeCalled',true);\n                    if(LytePopup.components[i].getData('ltPropParentModalId') == '' && LytePopup.components[i].getData('ltPropDependentModalId') != '') {\n                        LytePopup.components[i].$node.component.updateScrollHandling();\n                    }\n                    else if(LytePopup.components[i].getData('ltPropParentModalId') == '' && LytePopup.components[i].getData('ltPropDependentModalId') == '') {\n                        if((i == LytePopup.components.length - 1) && LytePopup.components[i].renderSidewise){\n                            continue;\n                        }\n                        LytePopup.components[i].$node.component.updateScrollHandling();\n                    }\n                }\n            }\n            LytePopup._lyteModalRTId = false;\n        },100);\n    },true);\n\n    document.addEventListener('click',function(event){\n        var ele = event.target;\n        while(!$L(ele).hasClass('modalWrapper') && ele.tagName != \"LYTE-MODAL-FREEZE\" && ele.tagName != 'LYTE-DROP-BOX' && ele.tagName != 'HTML'){\n            ele = ele.parentElement;\n            if(!ele){\n                return\n            }\n        }\n        if(ele.tagName == \"HTML\" || ele.tagName == \"LYTE-MODAL-FREEZE\"){\n            for(var i = window.LytePopup.components.length -1 ; i>=0; i--){\n                if(window.LytePopup.components[i].$node.tagName == \"LYTE-MODAL\" && window.LytePopup.components[i].childComp.style.visibility == \"visible\"){\n                    var modal = window.LytePopup.components[i].$node;\n                    var dontClose = true\n                    if(modal.component.getData('ltPropAllowContainment') && ele.tagName === 'HTML'){\n                        dontClose = false\n                    }\n                    if(modal && modal.component.getData('ltPropOverlayClose') && dontClose){\n                        modal.ltProp('show',false);\n                        break;\n                    }\n                }\n            }\n        }\n        else{\n            /*  If ele is having modalWrapper class ie. a modal and it is not the modal that is opened at last which is the current modal element in the page\n            this means the click has happened outside the current modal\n            so the current modal should be closed */\n            if(ele.classList.contains('modalWrapper') && window.LytePopup.components.length > 1 && window.LytePopup.components[window.LytePopup.components.length -1].$node.tagName == \"LYTE-MODAL\"){\n                var modal = window.LytePopup.components[window.LytePopup.components.length -1];\n                var dontClose = true\n                if(modal.getData('ltPropAllowContainment') && ele.tagName === 'HTML'){\n                    dontClose = false\n                }\n                if(!(modal.childComp.contains(ele)) && modal.childComp.style.visibility == \"visible\" && modal.getData('ltPropOverlayClose') && dontClose){\n                    modal.$node.ltProp('show',false);\n                }\n            }\n        }\n    },true);\n};\n\n/**\n * Renders a modal\n * @component lyte-modal\n * @version 1.0.0\n * @dependencies lyte-wormhole\n * @methods onBeforeShow,onShow,onBeforeClose,onClose,onResize\n * @utility alignModal,calculateOffset,trapFocus, reflectTransitionChange\n */\n\n/**\n * @customElement lyte-modal-header\n */\n/**\n * @customElement lyte-modal-content\n */\n/**\n * @customElement  lyte-modal-footer\n */\n\nclass LyteModalComponent extends Component {\n    constructor() {\n        super();\n    }\n\n    data() {\n        return {\n            //config from callee\n\n            /**\n             * @componentProperty {boolean} ltPropShow\n             * @version 1.0.0\n             * @default false\n             */\n            \"ltPropShow\":prop(\"boolean\",{\"default\": false}),\n\n            /**\n             * @componentProperty {boolean} ltPropFreeze\n             * @version 1.0.0\n             * @default true\n             */\n            \"ltPropFreeze\":prop(\"boolean\",{\"default\": true}),\n\n            /**\n             * @componentProperty {boolean} ltPropShowCloseButton\n             * @version 1.0.0\n             * @default true\n             */\n            \"ltPropShowCloseButton\":prop(\"boolean\",{\"default\": true}),\n\n            /**\n             * @componentProperty {boolean} ltPropCloseOnEscape\n             * @version 1.0.0\n             * @default true\n             */\n            \"ltPropCloseOnEscape\":prop(\"boolean\",{\"default\": true}),\n            /**\n             * @typedef {object} transition\n             * @property {slideFromTop|slideFromBottom|slideFromLeft|slideFromRight|fadeIn|zoom} animation\n             * @property {string} duration\n             */\n            /**\n             * @componentProperty {transition} ltPropTransition\n             * @version 1.0.0\n             * @default { \"animation\" :\"slideFromTop\" , \"duration\":\"0.5s\"}\n             */\n            \"ltPropTransition\":prop(\"object\",{\"default\":{\"animation\":\"slideFromTop\",\"duration\":\"0.5\"}}),\n            /**\n             * @typedef {object} offset\n             * @property {string} top\n             * @property {string} left\n             * @property {string} bottom\n             * @property {string} right\n             */\n            /**\n             * @componentProperty {offset} ltPropOffset\n             * @version 1.0.0\n             * @default { \"top\" :\"center\", \"left\" :\"center\"}\n             */\n            \"ltPropOffset\":prop(\"object\",{\"default\":{\"top\":\"center\",\"left\":\"center\"}}),\n            /**\n             * @typedef {object} dimmer\n             * @property {colorstring} color\n             * @property {string} opacity\n             */\n            /**\n             * @componentProperty {dimmer} ltPropDimmer\n             * @version 1.0.0\n             */\n            \"ltPropDimmer\":prop(\"object\"), //,{\"default\":{\"color\":\"black\",\"opacity\":\"0.4\"}}\n\n            /**\n             * @componentProperty {boolean} ltPropDraggable\n             * @version 1.0.0\n             * @default false\n             *\n             */\n            \"ltPropDraggable\":prop(\"boolean\",{\"default\": false}),\n\n            /**\n             * @componentProperty {boolean} ltPropAllowMultiple\n             * @version 1.0.0\n             * @default false\n             *\n             */\n            \"ltPropAllowMultiple\":prop(\"boolean\",{\"default\": false}),\n\n            /**\n             * @componentProperty {boolean} ltPropScrollable\n             * @version 1.0.0\n             * @default false\n             *\n             */\n            \"ltPropScrollable\":prop(\"boolean\",{\"default\": false}),\n\n            /**\n             * @componentProperty {string} ltPropMaxHeight\n             * @version 1.0.0\n             * @suffix px,pt,cm,mm,vh,vm,em\n             */\n            \"ltPropMaxHeight\":prop(\"string\",{\"default\":\"\"}),\n\n            /**\n             * @componentProperty {string} ltPropMaxWidth\n             * @version 1.0.0\n             * @suffix px,pt,cm,mm,vh,vm,em\n             */\n            \"ltPropMaxWidth\":prop(\"string\",{\"default\":\"\"}),\n\n            /**\n             * @componentProperty {string} ltPropWidth\n             * @version 1.0.0\n             * @suffix px,pt,cm,mm,vh,vm,em\n             */\n            \"ltPropWidth\":prop(\"string\",{\"default\":\"\"}),\n\n            /**\n             * @componentProperty {string} ltPropHeight\n             * @version 1.0.0\n             * @default auto\n             * @suffix px,pt,cm,mm,vh,vm,em\n             */\n            \"ltPropHeight\":prop(\"string\",{\"default\":\"auto\"}),\n\n            /**\n             * @componentProperty {string} ltPropWrapperClass\n             * @version 1.0.0\n             */\n            \"ltPropWrapperClass\":prop(\"string\",{\"default\":\"\"}),\n\n            /**\n             * @componentProperty {boolean} ltPropBindToBody\n             * @version 1.0.0\n             * @default false\n             *\n             */\n            \"ltPropBindToBody\":prop(\"boolean\",{\"default\":false}),\n\n            /**\n             * @experimental ltPropShowCopy\n             */\n            \"ltPropShowCopy\":prop(\"boolean\",{\"default\": false}),\n\n            /**\n             * @componentProperty {boolean} ltPropReRenderModal\n             * @version 1.0.0\n             * @default false\n             *\n             */\n            \"ltPropReRenderModal\":prop(\"boolean\",{\"default\":false}),\n\n            /**\n             * @componentProperty {boolean} ltPropOverlayClose\n             * @version 1.0.0\n             * @default false\n             *\n             */\n            \"ltPropOverlayClose\":prop(\"boolean\",{\"default\":false}),\n\n            /**\n             * @componentProperty {boolean} ltPropAria\n             * @version 3.1.0\n             * @default false\n             *\n             */\n            \"ltPropAria\" : prop( 'boolean', { default : false } ),\n\n            /**\n             * @componentProperty {object} ltPropAriaAttributes\n             * @version 3.1.0\n             */\n            \"ltPropAriaAttributes\" : prop( 'object', { default : {} } ),\n\n            /**\n             * @componentProperty {boolean} ltPropPreventFocus\n             * @version 3.3.0\n             * @default false\n             *\n             */\n            \"ltPropPreventFocus\" : prop('boolean', { default : false } ),\n\n            /**\n             * @componentProperty {boolean} ltPropSetContentHeight\n             * @version 3.9.0\n             * @default false\n             *\n             */\n            \"ltPropSetContentHeight\" : prop('boolean', { default : false } ),\n\n            /**\n             * @componentProperty {number} ltPropCloseDuration\n             * @version 3.10.0\n             * @default undefined\n             */\n            \"ltPropCloseDuration\" : prop(\"number\",{\"default\" : undefined}),\n\n            /**\n             * @componentProperty {boolean} ltPropOverlapModal\n             * @version 3.19.0\n             * @default true\n             *\n             */\n            \"ltPropOverlapModal\" : prop('boolean', { default : true } ),\n\n            /**\n             * @componentProperty {boolean} ltPropIgnoreInlineDirection\n             * @version 3.19.0\n             * @default true\n             *\n             */\n            \"ltPropIgnoreInlineDirection\" : prop('boolean', { default : false } ),\n\n            /**\n             * @componentProperty {boolean} ltPropAllowContainment\n             * @version 3.68.0\n             * @default false\n             *\n             */\n\n             \"ltPropAllowContainment\" : prop('boolean' , {\n                default : false\n            }),\n            \"ltPropFocusOnClose\" : prop('boolean' , {\n                default : false\n            }),\n            \"ltPropPadding\" : prop('string' , {\n                default : \"\"\n            }),\n\n            \"ltPropDependentModalId\": prop('string', {default: ''}),\n            \"ltPropParentModalId\": prop('string', {default: ''}),\n            \"ltPropShowWormhole\" : prop('boolean' , {\n                default : false\n            }),\n\n            \n            //local properties\n            \"first\":prop(\"boolean\",{\"default\":true}),\n            'resizeCalled' : prop(\"boolean\",{\"default\":false}),\n            'initializedPosition' : prop(\"boolean\",{\"default\":false}),\n            \"prevHeight\" : prop(\"number\"),\n            \"returnedFalse\" : prop(\"boolean\",{\"default\" : false}),\n            \"prevModalHeight\" : prop(\"number\"),\n            \"prevModalWidth\" : prop(\"number\"),\n            \"calculateHW\" : prop(\"boolean\", {\"default\":false}),\n            \"checkAria\" : prop(\"number\", {\"default\":0}),\n            \"beforeDragPosition\" : prop('object' , {default : {xPos:0,yPos:0}}),\n            \"resetTriggered\" : prop('boolean' , {default : false})\n            // \"modalCreationOrder\" : Lyte.attr('number' , {'default' : -1}),\n        };\n    }\n\n    addDragHandler() {\n        var dragHeader = this.actualModalDiv.querySelector('lyte-modal-header');\n        if(this.$node.ltProp(\"draggable\")){\n            $L(dragHeader).addClass('lyteModalDragRunning');\n        }\n        if(dragHeader){\n            dragHeader.parentEle = this;\n            if(this.$node.ltProp(\"draggable\")){\n                dragHeader.addEventListener('mousedown',this.handleMove,true);\n                dragHeader.addEventListener('touchstart',this.handleMove,true);\n                dragHeader.classList.add('lyteModalHeaderDraggable');\n            }\n            else{\n                dragHeader.removeEventListener('mousedown',this.handleMove,true);\n                dragHeader.removeEventListener('touchstart',this.handleMove,true);\n                dragHeader.classList.remove('lyteModalHeaderDraggable');\n            }\n        }\n        else{\n            console.warn(\"This modal is not draggable because it has no header\");\n            this.$node.ltProp(\"draggable\",false);\n        }\n    }\n\n    handleMove(e) {\n        if(e.button === 2){\n            return\n        }\n        var drag = e.currentTarget.parentEle.actualModalDiv, mouseOffset;\n        window.LytePopup.node=drag;\n        if(e.type == \"mousedown\"){\n            mouseOffset = { x : e.clientX, y : e.clientY};\n        }\n        if(e.type == \"touchstart\"){\n            mouseOffset = { x : e.touches[0].clientX, y : e.touches[0].clientY};\n        }\n        if(e.currentTarget.parentEle.getData('ltPropTransition').animation == \"fadeIn\"){\n            LytePopup.xPos=mouseOffset.x-this.getBoundingClientRect().left;\n            LytePopup.yPos=mouseOffset.y-this.getBoundingClientRect().top;\n        }\n        else{\n            LytePopup.xPos=mouseOffset.x;\n            LytePopup.yPos=mouseOffset.y;\n        }\n        var elePos = drag.getBoundingClientRect();\n        drag.style.transitionDuration = \"0s\";\n        if(e.type == \"mousedown\"){\n            window.addEventListener('mousemove',e.currentTarget.parentEle.handleDrag,true);\n            window.addEventListener('mouseup',e.currentTarget.parentEle.stopDrag,true);\n        }\n        if(e.type == \"touchstart\"){\n            document.body.addEventListener('touchmove',e.currentTarget.parentEle.handleDrag,true);\n            document.body.addEventListener('touchend',e.currentTarget.parentEle.stopDrag,true);\n        }\n\n    }\n\n    handleDrag(e) {\n        var drag = window.LytePopup.node;\n        var curComp = $L(drag).closest('lyte-wormhole')[0]._callee\n        var dragBounding = drag.getBoundingClientRect()\n        var compStyle = window.getComputedStyle(drag);\n        if(!window.LytePopup.node){\n            return;\n        }\n        var curleft = 0\n        var curtop = 0\n        var mouseOffset;\n        if(e.type == \"mousemove\"){\n            mouseOffset = { x : e.clientX, y : e.clientY};\n        }\n        if(e.type == \"touchmove\"){\n            mouseOffset = { x : e.touches[0].clientX, y : e.touches[0].clientY};\n        }\n        if(window.LytePopup.node.closest('lyte-wormhole')._callee.component.getData('ltPropTransition').animation == \"fadeIn\"){\n            curleft = (mouseOffset.x-window.LytePopup.xPos)\n            curtop = (mouseOffset.y-window.LytePopup.yPos)\n            if(!curComp.getData('ltPropAllowContainment')){\n                drag.style.left = curleft+'px';\n                drag.style.top = curtop+'px';\n            } else {\n                if(curleft + drag.getBoundingClientRect().width <= window.innerWidth && (curleft >= 0)){\n                    drag.style.left = curleft + 'px';\n                }else if(curleft < 0){\n                    drag.style.left = \"0px\";\n                } else {\n                    drag.style.left = ( window.innerWidth - drag.getBoundingClientRect().width ) + 'px';\n                }\n        \n                if(curtop + drag.getBoundingClientRect().height <= window.innerHeight && (curtop >= 0)){\n                    drag.style.top = curtop + 'px';\n                }else if(curtop < 0){\n                    drag.style.top = \"0px\";\n                } else {\n                    drag.style.top = ( window.innerHeight - drag.getBoundingClientRect().height ) + 'px';\n                }\n            }\n\n        }\n        else{\n          var matrix = window.LytePopup.node.closest('lyte-wormhole')._callee.component.transform\n          if((window.LytePopup.node.closest('lyte-wormhole')._callee.component.getData('ltPropTransition').animation == \"zoom\") && !matrix){\n            matrix = {}\n            matrix.x = 0;\n            matrix.y = 0\n          } \n            var x = matrix.x+(mouseOffset.x-window.LytePopup.xPos),\n                y = matrix.y+(mouseOffset.y-window.LytePopup.yPos);\n                drag.style.transform = \"translate(\"+x+\"px, \"+y+\"px)\";\n\n                dragBounding = drag.getBoundingClientRect()\n\n            if(curComp.getData('ltPropAllowContainment')){\n                if(dragBounding.left + dragBounding.width > window.innerWidth && (dragBounding.left >= 0)){\n                    x = (window.innerWidth - dragBounding.width) - parseFloat(compStyle.left)\n                } else if(dragBounding.left<0){\n                    x =  - parseFloat(compStyle.left)\n                }\n                if(dragBounding.top + dragBounding.height > window.innerHeight && (dragBounding.top >= 0)){\n                    y = (window.innerHeight - dragBounding.height) - parseFloat(compStyle.top)\n                } else if(dragBounding.top<0){\n                    y = - parseFloat(compStyle.top)\n                }\n                drag.style.transform = \"translate(\"+x+\"px, \"+y+\"px)\";\n            }\n\n\n        }\n        window.getSelection().removeAllRanges();\n    }\n\n    stopDrag(e) {\n        var targetElem = e.target;\n        if(!$L(targetElem).hasClass('lyteModalDragRunning')){\n            targetElem = $L('.lyteModalDragRunning')[0]\n        }\n        while(targetElem && targetElem !== document){\n            if(targetElem.parentEle){\n                if(e.type == \"mouseup\"){\n                    this.removeEventListener('mousemove',targetElem.parentEle.handleDrag,true);\n                    this.removeEventListener('mouseup',targetElem.parentEle.stopDrag,true);\n                }\n                if(e.type == \"touchend\"){\n                    this.removeEventListener('touchmove',targetElem.parentEle.handleDrag,true);\n                    this.removeEventListener('touchend',targetElem.parentEle.stopDrag,true);\n                }\n                break;\n            }\n            targetElem = targetElem.parentElement ? targetElem.parentElement : document;\n        }\n        if(window.LytePopup.node){\n            var comp = window.LytePopup.node.closest('lyte-wormhole')._callee.component;\n            window.LytePopup.node.style.transitionDuration = comp.getData('ltPropTransition').duration;\n            if(comp.getData('ltPropTransition').animation != \"fadeIn\"){\n                var matrix = new window.WebKitCSSMatrix(window.getComputedStyle(comp.actualModalDiv).transform);\n                comp.transform = {'x' : matrix.m41, 'y' : matrix.m42};\n            }\n            LytePopup.node = null;\n        }\n    }\n\n    clearFastdomBatch() {\n        if(this.fastdomfn1){\n            $L.fastdom.clear(this.fastdomfn1);\n        }\n        if(this.fastdomfn2){\n            $L.fastdom.clear(this.fastdomfn2);\n        }\n        if(this.fastdomfn3){\n            $L.fastdom.clear(this.fastdomfn3);\n        }\n        if(this.fastdomfn4){\n            $L.fastdom.clear(this.fastdomfn4);\n        }\n        if(this.fastdomfn5){\n            $L.fastdom.clear(this.fastdomfn5);\n        }\n        if(this.fastdomfn6){\n            $L.fastdom.clear(this.fastdomfn6);\n        }\n        if(this.fastdomfn7){\n            $L.fastdom.clear(this.fastdomfn7);\n        }\n        if(this.fastdomfn8){\n            $L.fastdom.clear(this.fastdomfn8);\n        }\n        if(this.beforeShowId){\n            clearTimeout(this.beforeShowId);\n        }\n    }\n\n    /**\n     * The method is going to set height and width of the modal\n     *\n     */\n    updateScrollHandling() {    //It sets the height and width of the modal\n        if(!this.$node.ltProp(\"freeze\")){\n            // this.$node.ltProp(\"scrollable\",true);\n            this.setData(\"calculateHW\",true);\n        }\n        var modalElem = this.actualModalDiv;\n        var oldHeight, oldWidth, newHeight, newWidth,\n        w =  Math.max(document.documentElement.clientWidth, window.innerWidth || 0),\n        contentNode = modalElem.querySelector(\"lyte-modal-content\");\n        // contentNode = contentNode ? contentNode : modalElem;\n        modalElem.style.maxWidth = \"\";\n        modalElem.style.maxHeight = \"\";\n        modalElem.style.height = this.$node.ltProp(\"height\")?this.$node.ltProp(\"height\"):\"auto\";\n        modalElem.style.width = this.$node.ltProp(\"width\")?( (!(this.getData('ltPropOverlapModal')) && this.$node.ltProp(\"width\").indexOf('%') != -1) ? ((parseFloat(this.$node.ltProp(\"width\"))/100) * w) + \"px\" : this.$node.ltProp(\"width\") ):\"auto\";\n        // console.log(this.$node.ltProp(\"width\"));\n        /*------------------------------ MEASURE STARTS --------------------------*/\n        this.fastdomfn2 = $L.fastdom.measure(function() {    //Measures the initial height and width\n            delete this.fastdomfn2;\n            var modalElemOffset = modalElem.getBoundingClientRect();\n            /*IF maxwidth or maxheigth given as a percentage then to calculate the actual width or height\n                                we need the modalElements parent element's width and height*/\n            var modalParentOff = modalElem.parentElement.getBoundingClientRect();\n            var cs = window.getComputedStyle(modalElem);\n            var borderDimensionY = ((cs.borderTopWidth ? parseFloat(cs.borderTopWidth) : 0) +\n                                     (cs.borderBottomWidth ? parseFloat(cs.borderBottomWidth) : 0));\n            var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0) - (this.getData('ltPropFreeze') ? parseInt(window.getComputedStyle(modalElem.parentElement).top) : 0);\n            // console.log(modalElemOffset);\n            /*------------------------------ MUTATE STARTS --------------------------*/\n            this.fastdomfn3 = $L.fastdom.mutate(function(){    //Checks for the max height and width provided by the user and sets the modal height and width based on that\n                delete this.fastdomfn3;\n                if(this.$node.ltProp(\"maxWidth\")){\n                    // this.$node.ltProp(\"scrollable\",true);\n                    // this.setData(\"calculateHW\",true);\n                    // oldWidth = modalElemOffset.width /*- borderDimensionX*/;\n                    newWidth = this.$node.ltProp(\"maxWidth\").indexOf('%') != -1 ? ((parseFloat(this.$node.ltProp(\"maxWidth\"))/100) * modalParentOff.width) : parseFloat(this.$node.ltProp(\"maxWidth\"));\n                    modalElem.style.maxWidth = newWidth + \"px\";\n                    // if(oldWidth < newWidth){\n                    //     modalElem.style.width = oldWidth+\"px\";\n                    //     // newWidth = oldWidth;\n                    // }\n                    modalElem.style.overflowX = \"auto\";\n                }\n                else{\n                    newWidth = modalElemOffset.width /*- borderDimensionX*/;\n                }\n\n                if(this.$node.ltProp(\"maxHeight\")){\n                    this.childComp.querySelector(\".modalWrapper\").classList.add(\"scrollable\");\n                    // this.$node.ltProp(\"scrollable\",true);\n                    this.setData(\"calculateHW\",true);\n                    oldHeight = modalElemOffset.height - borderDimensionY;\n                    var newH = this.$node.ltProp(\"maxHeight\").indexOf('%') != -1 ? ((parseFloat(this.$node.ltProp(\"maxHeight\"))/100) * modalParentOff.height) : parseFloat(this.$node.ltProp(\"maxHeight\"));\n                    // modalElem.style.height = newH + \"px\";\n                    modalElem.style.maxHeight = newH + \"px\";\n                    newHeight = newH - borderDimensionY;\n                }\n                else{\n                    /*  +1 is added here to the oldHeight as offsetHeights are rounded off values. ie. 5.5 => 6.\n                        So, if 5.5 + 5.5 = 11. But offsetHeight will give 6 + 6 by rounding off 5.5 which is != 11.\n                        So for safety we add extra 1 px to the total height.\n                    */\n                    oldHeight = modalElem.offsetHeight - borderDimensionY + 1;\n                    //If height is provided in px or em then we dont compare if it is greater than window height as it is fixed\n                    if(this.$node.ltProp('height') && this.$node.ltProp('height') != \"auto\"/* && ((this.$node.ltProp('height')).indexOf('px') != -1 || (this.$node.ltProp('height')).indexOf('em') != -1)*/){\n                        newHeight = oldHeight;\n                        this.setData(\"calculateHW\",true);\n                    }\n                    else{\n                        newHeight = oldHeight > h ? h-40 : oldHeight;\n                    }\n                    if(this.$node.ltProp(\"scrollable\")){\n                        if(!(this.$node.ltProp('height')) || this.$node.ltProp('height') == \"auto\"){\n                            newHeight = h-40;\n                        }\n                        this.setData(\"calculateHW\",true);\n                    }\n                    if(contentNode /*this.actualModalDiv.querySelector(\"lyte-modal-content\")*/ && contentNode.offsetHeight /*this.actualModalDiv.querySelector(\"lyte-modal-content\")*/ > oldHeight - ((this.actualModalDiv.querySelector(\"lyte-modal-header\") ? this.actualModalDiv.querySelector(\"lyte-modal-header\").offsetHeight : 0) + (this.actualModalDiv.querySelector(\"lyte-modal-footer\") ? this.actualModalDiv.querySelector(\"lyte-modal-footer\").offsetHeight : 0))){\n                        // this.$node.ltProp(\"scrollable\",true);\n                        this.setData(\"calculateHW\",true);\n                    }\n                }\n                if(this.getData(\"calculateHW\") && contentNode){\n                    var modalheader = this.actualModalDiv.querySelector(\"lyte-modal-header\"), modalFooter = this.actualModalDiv.querySelector(\"lyte-modal-footer\");\n                    var modalHOff = null,modalFOff = null;\n                    /*------------------------------ MEASURE STARTS --------------------------*/\n                    this.fastdomfn4 = $L.fastdom.measure(function(){   //measures the content haeder, content and footer dimensions\n                        delete this.fastdomfn4;\n                        if(modalheader){\n                            modalHOff = modalheader.offsetHeight;\n                        }\n                        if(modalFooter){\n                            modalFOff = modalFooter.offsetHeight;\n                        }\n                        var diff = 0;\n                        var modalHeight = modalElem.getBoundingClientRect().height;\n                        // if(this.getData('resizeCalled')){\n                        //     //to get the difference between previous height and current height\n                        //     if(this.getData('prevHeight') < modalHeight){\n                        //         diff = modalHeight - this.getData('prevHeight');\n                        //     }\n                        //     this.setData('resizeCalled',false);\n                        // }\n                        this.setData('prevHeight',modalHeight);\n                        /*------------------------------ MUTATE STARTS --------------------------*/\n                        this.fastdomfn5 = $L.fastdom.mutate(function(){   //Sets the final height and width of the modal\n                            delete this.fastdomfn5;\n                            var newH = (newHeight - ((modalHOff ? modalHOff : 0)+ (modalFOff ? modalFOff : 0)));\n                            contentNode.style.maxHeight = (newH > 0 ? newH : 50) + diff +\"px\";\n                            contentNode.style.overflowY = \"auto\";\n                            if(this.$node.ltProp('height') != \"auto\" && this.getData('ltPropSetContentHeight')){\n                                contentNode.style.height = newH + \"px\";\n                            }\n                            // if(this.getData('first')){\n                            //     contentNode.style.height = (oldHeight - ((modalHOff ? modalHOff.height : 0)+ (modalFOff ? modalFOff.height : 0))) +\"px\";\n                            // }\n                            // modalElem.style.width = this.$node.ltProp(\"width\")?this.$node.ltProp(\"width\"):\"auto\";\n                            // this.actualModalDiv.style.maxWidth = newWidth > 0 ? (newWidth +\"px\"):(\"70%\");\n                            modalElem = null;\n                            contentNode = null;\n                            modalheader = null;\n                            modalFooter = null;\n                            if(!this.getData('initializedPosition')){\n                                this.computeOffsetImpl();\n                                this.setData('initializedPosition',true);\n                            }\n                            else if(this.getData('resizeCalled')){\n                                this.computeOffsetImplOnResize();\n                                this.setData('resizeCalled',false);\n                            }\n                        },this);\n                        /*------------------------------ MUTATE ENDS --------------------------*/\n                    },this);\n                    /*------------------------------ MEASURE ENDS --------------------------*/\n                }\n                else{\n                    this.childComp.querySelector(\".modalWrapper\").classList.remove(\"scrollable\");\n                    modalElem = null;\n                    contentNode = null;\n                    if(!this.getData('initializedPosition')){\n                        this.computeOffsetImpl();\n                        this.setData('initializedPosition',true);\n                    }\n                    else if(this.getData('resizeCalled')){\n                        this.computeOffsetImplOnResize();\n                        this.setData('resizeCalled',false);\n                    }\n                }\n\n                if (!this.$node.ltProp(\"freeze\")) {\n                    this.childComp.querySelector(\".modalWrapper\").classList.add('noFreeze');\n                    if(!this.renderSidewise){\n                        this.actualModalDiv.style.position = \"fixed\";\n                    }\n                }\n                // else{\n                //     this.childComp.querySelector(\".modalWrapper\").style.position = \"fixed\";\n                // }\n            },this);\n            /*------------------------------ MUTATE ENDS --------------------------*/\n        },this);\n        /*------------------------------ MEASURE ENDS --------------------------*/\n\n\n    }\n\n    callOnShow() {\n        // if(this.getData('ltPropFreeze')){\n        //     this.childComp.querySelector(\"lyte-modal-freeze\").style.transitionDuration = this.getData('ltPropTransition').duration + \"s\";\n        // }\n        this.$node.classList.add('lyteModalOpened');\n        var _this = this\n        setTimeout(function(){\n          var style = window.getComputedStyle(_this.actualModalDiv);\n          var matrix = new window.WebKitCSSMatrix(style.transform);\n          _this.setData('beforeDragPosition' , {\n            xPos : matrix.m41,\n            yPos : matrix.m42,\n            scale : matrix.a\n          })\n          window._lyteUiUtils.dispatchEvent('lyteModalOpened' , _this.actualModalDiv)\n        },(parseFloat(this.getData('ltPropTransition').duration)*1000+10))\n        if(this.getMethods(\"onShow\")){\n            this.executeMethod(\"onShow\",this);\n        }\n        if(this.addAriaValues){\n            this.addAriaValues();\n        }\n    }\n\n    callOnResize() {\n        // this.updateScrollHandling();\n        var dependentModalId = this.getData('ltPropDependentModalId');\n        if(dependentModalId != '') {\n            var dependentModalObj = $L(dependentModalId)[0].component;\n            dependentModalObj.updateScrollHandling();\n        }\n        // if(this.isResponsibleForSidewiseRender()){\n        //     LytePopup.components[1].$node.component.updateScrollHandling();\n        // }\n        var style = window.getComputedStyle(this.actualModalDiv);\n        var matrix = new window.WebKitCSSMatrix(style.transform);\n        this.setData('beforeDragPosition' , {\n          xPos : matrix.m41,\n          yPos : matrix.m42,\n          scale : matrix.a\n        })\n        if(this.getMethods(\"onResize\")){\n            this.executeMethod(\"onResize\",this);\n        }\n    }\n\n    enableTransform(val, pos, duration) {\n        this.$node.ltProp('showCopy',true);\n        var self = this;\n        setTimeout(function(){\n            if(pos == 'x'){\n                self.actualModalDiv.style.transform = \"translate(\"+val+\"px,0px)\";\n                self.transform = {'x' : val, 'y' : 0};\n            }\n            if(pos == 'y'){\n                self.actualModalDiv.style.transform = \"translate(0px,\"+val+\"px)\";\n                self.transform = {'x' : 0, 'y' : val};\n            }\n        },(duration != undefined ? duration : undefined))\n\n    }\n\n    /**\n     * The method is going to redo the left and top computation when the modal is opened and the window is resized\n     *\n     */\n    computeOffsetImplOnResize() {\n        /*------------------------------ MEASURE STARTS --------------------------*/\n         $L.fastdom.measure(function() {\n            var modalEle = this.actualModalDiv,\n                modalElePosition = modalEle.getBoundingClientRect(),\n                parentStyle = window.getComputedStyle(modalEle.parentElement),\n                parentTop = parseInt(parentStyle.top), //Takes the modalWrapper's top value and subtracts it from the modals top to nullify the parent's top\n                parentLeft = parseInt(parentStyle.left),\n                correctedTop = modalEle.offsetTop,\n                w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0) - (this.getData('ltPropFreeze') ? parentLeft : 0),\n                h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0) - (this.getData('ltPropFreeze') ? parentTop : 0),\n                prevWinH = this.getData('prevWinH'),\n                prevWinW = this.getData('prevWinW'),\n                transform = this.transform /*new WebKitCSSMatrix(window.getComputedStyle(modalEle).transform)*/,\n                newTop = null,\n                newLeft = null,\n                offsetObj = this.getData('ltPropOffset'),\n                heightDiff = this.getData('prevModalHeight') - modalElePosition.height,\n                widthDiff = this.getData('prevModalWidth') - modalElePosition.width,\n                freezeLayer, wrapperDiv;\n                this.calculateForSidewiseRender();\n            if(this.renderSidewise){\n                this.renderProps.windowWidth = w;\n                w = this.getData('ltPropTransition').animation == 'slideFromRight' ? this.renderProps.left : (this.renderProps.windowWidth - this.renderProps.right);\n                freezeLayer = this.childComp.querySelector('lyte-modal-freeze');\n                wrapperDiv = this.actualModalDiv.parentElement;\n            }\n            if(this.getData('ltPropTransition').animation === \"fadeIn\" || this.getData('ltPropTransition').animation === \"zoom\"){\n              prevWinH = modalElePosition.height\n              prevWinW = modalElePosition.width\n                if(w < prevWinW){\n                    if((offsetObj.left && offsetObj.left == \"center\") || (offsetObj.right && offsetObj.right == \"center\")){\n                        newLeft = ((prevWinW - w) / 2);\n                    }\n                    else if(offsetObj.right){\n                        newLeft = modalElePosition.left - (prevWinW - w);\n                    }\n                    else if(offsetObj.left){\n                        newLeft = modalElePosition.left;\n                    }\n                }\n                if(w > prevWinW){\n                    if((offsetObj.left && offsetObj.left == \"center\") || (offsetObj.right && offsetObj.right == \"center\")){\n                        newLeft = ((w - prevWinW) / 2);\n                    }\n                    else if(offsetObj.right){\n                        newLeft = modalElePosition.left + (w - prevWinW);\n                    }\n                    else if(offsetObj.left){\n                        newLeft = modalElePosition.left;\n                    }\n                }\n                if(h < prevWinH){\n                    if((offsetObj.top && offsetObj.top == \"center\") || (offsetObj.bottom && offsetObj.bottom == \"center\")){\n                        newTop = (h - modalElePosition.height)/2 /*correctedTop - ((prevWinH - h) / 2)*/;\n                    }\n                    else if(offsetObj.bottom){\n                        newTop = correctedTop - (prevWinH - h);\n                    }\n                    else if(offsetObj.top){\n                        newTop = correctedTop;\n                    }\n                }\n                if(h > prevWinH){\n                    if((offsetObj.top && offsetObj.top == \"center\") || (offsetObj.bottom && offsetObj.bottom == \"center\")){\n                        newTop = (h - modalElePosition.height)/2 /*correctedTop + ((h - prevWinH) / 2)*/;\n                    }\n                    else if(offsetObj.bottom && offsetObj.bottom != \"center\"){\n                        newTop = correctedTop + (h - prevWinH);\n                    }\n                    else if(offsetObj.top && offsetObj.top != \"center\"){\n                        newTop = correctedTop;\n                    }\n                }\n                $L.fastdom.mutate(function() {\n                    if(newTop){\n                        modalEle.style.top = newTop + \"px\";\n                    }\n                    if(newLeft){\n                        modalEle.style.left = newLeft + \"px\";\n                    }\n                    this.callOnResize();\n                },this);\n            }\n            else{\n                if(w < prevWinW){\n                    if((offsetObj.left && offsetObj.left == \"center\") || (offsetObj.right && offsetObj.right == \"center\")){\n                        newLeft = transform.x - ((prevWinW - w) / 2) + (widthDiff / 2);\n                    }\n                    else if(offsetObj.right){\n                        newLeft = transform.x - (prevWinW - w) + widthDiff;\n                    }\n                    else if(offsetObj.left){\n                        newLeft = transform.x;\n                    }\n                    this.transform.x = newLeft;\n                }\n                if(w > prevWinW){\n                    if((offsetObj.left && offsetObj.left == \"center\") || (offsetObj.right && offsetObj.right == \"center\")){\n                        newLeft = transform.x + ((w - prevWinW) / 2) + (widthDiff / 2);\n                    }\n                    else if(offsetObj.right){\n                        newLeft = transform.x + (w - prevWinW) + widthDiff;\n                    }\n                    else if(offsetObj.left){\n                        newLeft = transform.x;\n                    }\n                    this.transform.x = newLeft;\n                }\n                if(h < prevWinH){\n                    if((offsetObj.top && offsetObj.top == \"center\") || (offsetObj.bottom && offsetObj.bottom == \"center\")){\n                        newTop = transform.y - ((prevWinH - h) / 2) + (heightDiff / 2);\n                    }\n                    else if(offsetObj.bottom){\n                        newTop = transform.y - (modalElePosition.bottom - h + parseInt(offsetObj.bottom)) /*(prevWinH - h)*/;\n                    }\n                    else if(offsetObj.top){\n                        newTop = transform.y;\n                    }\n                    this.transform.y = newTop;\n                }\n                if(h > prevWinH){\n                    if((offsetObj.top && offsetObj.top == \"center\") || (offsetObj.bottom && offsetObj.bottom == \"center\")){\n                        newTop = transform.y + ((h - prevWinH) / 2) + (heightDiff / 2);\n                    }\n                    else if(offsetObj.bottom && offsetObj.bottom != \"center\"){\n                        newTop = transform.y + (h - modalElePosition.bottom - parseInt(offsetObj.bottom))/*(h - prevWinH)*/;\n                    }\n                    else if(offsetObj.top && offsetObj.top != \"center\"){\n                        newTop = transform.y;\n                    }\n                    // console.log(\"prev top\", this.transform.y);\n                    // console.log(\"new top\", newTop);\n                    this.transform.y = newTop;\n                }\n                $L.fastdom.mutate(function() {\n                    modalEle.style.transitionDuration = \"0s\";\n                    if(this.getData('ltPropTransition').animation === \"slideFromTop\" || this.getData('ltPropTransition').animation === \"slideFromBottom\"){\n                        if(w < prevWinW){\n                            if((offsetObj.left && offsetObj.left == \"center\") || (offsetObj.right && offsetObj.right == \"center\")){\n                                modalEle.style.left = modalElePosition.left - ((prevWinW - w) / 2) + (widthDiff/2) + \"px\";\n                            }\n                            else if(offsetObj.right){\n                                modalEle.style.left = modalElePosition.left - (prevWinW - w) + widthDiff + \"px\";\n                            }\n                            else if(offsetObj.left){\n                                modalEle.style.left = modalElePosition.left + \"px\";\n                            }\n                            // modalEle.style.left = modalElePosition.left - ((prevWinW - w)/2) + \"px\";\n                        }\n                        if(w > prevWinW){\n                            if((offsetObj.left && offsetObj.left == \"center\") || (offsetObj.right && offsetObj.right == \"center\")){\n                              modalEle.style.left = modalElePosition.left + ((w - prevWinW) / 2) + (widthDiff/2) + \"px\";\n                            }\n                            else if(offsetObj.right){\n                                modalEle.style.left = modalElePosition.left + (w - prevWinW) + widthDiff + \"px\";\n                            }\n                            else if(offsetObj.left){\n                                modalEle.style.left = modalElePosition.left + \"px\";\n                            }\n                            // modalEle.style.left = modalElePosition.left + ((w - prevWinW)/2) + \"px\";\n                        }\n                        modalEle.style.transform = \"translate(0px,\"+this.transform.y+\"px)\";\n                    }\n                    else if(this.getData('ltPropTransition').animation === \"slideFromLeft\" || this.getData('ltPropTransition').animation === \"slideFromRight\"){\n                        if(h < prevWinH){\n                            if((offsetObj.top && offsetObj.top == \"center\") || (offsetObj.bottom && offsetObj.bottom == \"center\")){\n                                modalEle.style.top = correctedTop - ((prevWinH - h) / 2) + (heightDiff/2) + \"px\";\n                            }\n                            else if(offsetObj.bottom){\n                                modalEle.style.top = correctedTop - (prevWinH - h) + \"px\";\n                            }\n                            else if(offsetObj.top){\n                                modalEle.style.top = correctedTop + \"px\";\n                            }\n                            // modalEle.style.top = modalElePosition.top - ((prevWinH - h)/2) + \"px\";\n                        }\n                        if(h > prevWinH){\n                            if((offsetObj.top && offsetObj.top == \"center\") || (offsetObj.bottom && offsetObj.bottom == \"center\")){\n                                modalEle.style.top = correctedTop + ((h - prevWinH) / 2) + (heightDiff/2) + \"px\";\n                            }\n                            else if(offsetObj.bottom && offsetObj.bottom != \"center\"){\n                                modalEle.style.top = correctedTop + (h - prevWinH) + \"px\";\n                            }\n                            else if(offsetObj.top && offsetObj.top != \"center\"){\n                                modalEle.style.top = correctedTop + \"px\";\n                            }\n                            // modalEle.style.top = modalElePosition.top + ((h - prevWinH)/2) + \"px\";\n                        }\n                        modalEle.style.transform = \"translate(\"+this.transform.x+\"px,0px)\";\n                        if(this.renderSidewise){\n                            if(this.getData('ltPropTransition').animation == 'slideFromRight'){\n                                var rightValue = this.renderProps.windowWidth - this.renderProps.left;\n                                if(freezeLayer){\n                                    freezeLayer.style.right = rightValue + \"px\";\n                                }\n                                if(wrapperDiv){\n                                    wrapperDiv.style.right = rightValue - 5 + \"px\";\n                                }\n                            }\n                            if(this.getData('ltPropTransition').animation == 'slideFromLeft'){\n                                if(freezeLayer){\n                                    freezeLayer.style.left = this.renderProps.right + \"px\";\n                                }\n                                if(wrapperDiv){\n                                    wrapperDiv.style.left = (this.renderProps.right + 1) + \"px\";\n                                }\n                            }\n                        }\n                    }\n                    this.callOnResize();\n                    // modalEle.style.transitionDuration = this.$node.ltProp(\"transition\").duration+\"s\";\n                },this);\n            }\n            this.setData('prevModalHeight',modalElePosition.height);\n            this.setData('prevModalWidth',modalElePosition.width);\n            this.setData('prevWinH',h);\n            this.setData('prevWinW',w);\n        },this);\n        /*------------------------------ MEASURE ENDS --------------------------*/\n        // modalEle = null;\n    }\n\n    isResponsibleForSidewiseRender() {\n        var components = window.LytePopup.components;\n        if(components.length > 1 && components[components.length - 2] === this && components[components.length - 1].renderSidewise){\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * The method is going to calculate the left and top value of the modal and perform the animation\n     *\n     */\n    computeOffsetImpl(arg, triggeredFromTransChange) {\n        var lyteSelf = this;\n        //sets the left and top of the modal based on user provided values\n        var _this = this.nodeName && this.nodeName === \"LYTE-MODAL\" ? this.component : this;\n        /*------------------------------ MEASURE STARTS --------------------------*/\n        _this.fastdomfn6 = $L.fastdom.measure(function() {\n           delete _this.fastdomfn6;\n           if(!_this.actualModalDiv){\n               return;\n           }\n           _this.calculateForSidewiseRender();\n           var modalEle = _this.actualModalDiv;\n           var freezeLayer, wrapperDiv;\n           var offsetObj = lyteSelf.$addon .deepCopyObject(_this.$node.ltProp('offset'));\n           var modalRect = modalEle.getBoundingClientRect();\n           var modalElePosition = {top: modalRect.top,\n                                   right: modalRect.right,\n                                   bottom: modalRect.bottom,\n                                   left: modalRect.left,\n                                   width: modalEle.offsetWidth,\n                                   height: modalEle.offsetHeight\n                               };\n           var parentLeft = 0, parentTop = 0;\n           if(_this.getData('ltPropFreeze')){\n               var parentStyle = window.getComputedStyle(modalEle.parentElement);\n               parentLeft = parseInt(parentStyle.left);\n               parentTop = parseInt(parentStyle.top);\n           }\n           var w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0) - parentLeft;\n           if(_this.renderSidewise){\n               _this.renderProps.windowWidth = w;\n               w = _this.getData('ltPropTransition').animation == 'slideFromRight' ? _this.renderProps.left : (_this.renderProps.windowWidth - _this.renderProps.right);\n               freezeLayer = _this.childComp.querySelector('lyte-modal-freeze');\n               wrapperDiv = _this.actualModalDiv.parentElement;\n           }\n           var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0) - parentTop;\n            // $L.fastdom.mutate(() => {\n               modalEle.style.transitionDuration = (arg != undefined ? arg : _this.$node.ltProp(\"transition\").duration)+\"s\";\n           // },this);\n           _this.setData('prevWinH',h);\n           _this.setData('prevWinW',w);\n           _this.setData('prevModalHeight',modalElePosition.height);\n           _this.setData('prevModalWidth',modalElePosition.width);\n           if(offsetObj){\n               if(offsetObj.left === \"center\" || offsetObj.right === \"center\"){\n                   var offLeft = (w - modalElePosition.width)/2;\n                   if(offLeft < 0){\n                       offLeft = 20;\n                   }\n                   offsetObj.left = offLeft;\n               }\n               if(offsetObj.top === \"center\" || offsetObj.bottom === \"center\"){\n                   var offTop = (h - modalElePosition.height)/2;\n                   if(offTop < 0){\n                       offTop = 20;\n                   }\n                   offsetObj.top = offTop;\n               }\n               if(offsetObj.right && offsetObj.right !== \"center\"){\n                   if(offsetObj.right.indexOf(\"%\") > -1){\n                       offsetObj.left = w-(modalElePosition.width+(w/parseFloat(offsetObj.right)));\n                   }\n                   else{\n                       offsetObj.left = w-(modalElePosition.width+parseFloat(offsetObj.right));\n                   }\n               }\n               if(offsetObj.bottom && offsetObj.bottom !== \"center\"){\n                   if(offsetObj.bottom.indexOf(\"%\") > -1){\n                       offsetObj.top = h-(modalElePosition.height+(h/parseFloat(offsetObj.bottom)));\n                   }\n                   else{\n                       offsetObj.top = h-(modalElePosition.height+parseFloat(offsetObj.bottom));\n                   }\n               }\n               if(offsetObj.left === \"\" || offsetObj.left == undefined){\n                   _this.data.ltPropOffset.left = \"center\";\n                   offsetObj.left = ((w - modalElePosition.width)/2);\n               }\n               if(offsetObj.top === \"\" || offsetObj.top == undefined){\n                   _this.data.ltPropOffset.top = \"center\";\n                   offsetObj.top = ((h - modalElePosition.height)/2);\n               }\n               if(_this.getData('ltPropTransition').originElement){\n                   var ele = document.querySelector(_this.getData('ltPropTransition').originElement);\n                   if(!ele){\n                       console.error(\"The originElement provided does not exist. Kindly Check!\");\n                   }\n                   else{\n                       var eleOffset = ele.getBoundingClientRect();\n                       offsetObj.originElementPos = {xDiff : (eleOffset.left + (eleOffset.width/2)) - (parseFloat(offsetObj.left) + (modalElePosition.width/2)),\n                                                     yDiff : (eleOffset.top + (eleOffset.height/2)) - (parseFloat(offsetObj.top) + (modalElePosition.height/2)) };\n                   }\n               }\n               /*------------------------------ MUTATE STARTS --------------------------*/\n                _this.fastdomfn7 = $L.fastdom.mutate(function() {\n                   delete _this.fastdomfn7;\n                   if(_this.getData('first')){\n                       window.LytePopup.bindTransitionEnd(_this.actualModalDiv);\n                   }\n                   if(_this.getData('ltPropTransition').animation == \"slideFromTop\"){\n                       modalEle.style.left = parseFloat(offsetObj.left) + \"px\";\n                       modalEle.style.top = (-1 * modalElePosition.height) + \"px\";\n                       if(triggeredFromTransChange){\n                           modalEle.style.transform = \"translate(0px,\"+(parseInt(offsetObj.top)+modalElePosition.height)+\"px)\";\n                           _this.transform = {'x' : 0, 'y' : (parseInt(offsetObj.top)+modalElePosition.height)};\n                           return;\n                       }\n                       _this.enableTransform(parseInt(offsetObj.top)+modalElePosition.height,\"y\",arg);\n                   }\n                   else if(_this.getData('ltPropTransition').animation == \"slideFromBottom\"){\n                       modalEle.style.left = parseFloat(offsetObj.left) + \"px\";\n                       modalEle.style.top = h+1 + \"px\";\n                       if(triggeredFromTransChange){\n                           modalEle.style.transform = \"translate(0px,\"+(-1 * (h - parseInt(offsetObj.top) + 1))+\"px)\";\n                           _this.transform = {'x': 0, 'y': (-1 * (h - parseInt(offsetObj.top) + 1))};\n                           return;\n                       }\n                       _this.enableTransform(-1 * (h - parseInt(offsetObj.top) + 1),\"y\",arg);\n                   }\n                   else if(_this.getData('ltPropTransition').animation == \"slideFromLeft\"){\n                       if(_this.renderSidewise){\n                           if(freezeLayer){\n                               freezeLayer.style.left = _this.renderProps.right + \"px\";\n                           }\n                           if(wrapperDiv){\n                               wrapperDiv.style.left = _this.renderProps.right + \"px\";\n                           }\n                       }\n                       modalEle.style.top = parseFloat(offsetObj.top) + \"px\";\n                       modalEle.style.left = (-1 * modalElePosition.width) + \"px\";\n                       if(triggeredFromTransChange){\n                           modalEle.style.transform = \"translate(\"+(parseInt(offsetObj.left)+modalElePosition.width)+\"px,0px)\";\n                           _this.transform = {'x' : (parseInt(offsetObj.left)+modalElePosition.width), 'y' : 0};\n                           return;\n                       }\n                       _this.enableTransform(parseInt(offsetObj.left)+modalElePosition.width,'x',arg);\n                   }\n                   else if(_this.getData('ltPropTransition').animation == \"slideFromRight\"){\n                       if(_this.renderSidewise){\n                           var rightValue = _this.renderProps.windowWidth - _this.renderProps.left;\n                           if(freezeLayer){\n                               freezeLayer.style.right = rightValue + \"px\";\n                           }\n                           if(wrapperDiv){\n                               wrapperDiv.style.right = rightValue - 5 + \"px\";\n                           }\n                       }\n                       modalEle.style.top = parseFloat(offsetObj.top) + \"px\";\n                       modalEle.style.left = w + 1 + \"px\";\n                       if(triggeredFromTransChange){\n                           modalEle.style.transform = \"translate(\"+(-1 * (w - parseInt(offsetObj.left) + 1))+\"px,0px)\";\n                           _this.transform = {'x' : (-1 * (w - parseInt(offsetObj.left) + 1)), 'y' : 0};\n                           return;\n                       }\n                       _this.enableTransform(-1 * (w - parseInt(offsetObj.left) + 1),'x',arg);\n                   }\n                   else if(_this.getData('ltPropTransition').animation == \"fadeIn\"){\n                       modalEle.style.left = parseFloat(offsetObj.left) + \"px\";\n                       modalEle.style.top = parseFloat(offsetObj.top) + \"px\";\n                       if(triggeredFromTransChange){\n                           modalEle.style.transform = \"\";\n                           return;\n                       }\n                       _this.$node.ltProp('showCopy',true);\n                       // setTimeout(function(){\n                           modalEle.style.opacity = 1;\n                       // },200);\n                   }\n                   else if(_this.getData('ltPropTransition').animation == \"zoom\"){\n                       _this.$node.ltProp('showCopy',true);\n                       var transform = \"scale(0)\";\n                       if(offsetObj.originElementPos){\n                           transform = \"translateX( \"+ offsetObj.originElementPos.xDiff + \"px) translateY( \"+ offsetObj.originElementPos.yDiff + \"px) scale(0)\";\n                       }\n                       modalEle.style.left = parseFloat(offsetObj.left) + \"px\";\n                       modalEle.style.top = parseFloat(offsetObj.top) + \"px\";\n                       modalEle.style.transition = \"none\";\n                       if(triggeredFromTransChange){\n                           modalEle.style.transform = offsetObj.originElementPos ? 'translateX(0) translateY(0) scale(1)' : 'scale(1)';\n                           setTimeout(function(){\n                               modalEle.style.transition = \"\";\n                           },16)\n                           return;\n                       }\n                       modalEle.style.transform = transform;\n                       modalEle.style.opacity = 1;\n                       setTimeout(function(){\n                           modalEle.style.transition = \"\";\n                           modalEle.style.transitionDuration = (arg != undefined ? arg : _this.$node.ltProp(\"transition\").duration)+\"s\";\n                           if(offsetObj.originElementPos){\n                               modalEle.style.transform = 'translateX(0) translateY(0) scale(1)';\n                           }\n                           else{\n                               modalEle.style.transform = 'scale(1)';\n                           }\n                       },50);\n                   }\n\n                   if(_this.$node.ltProp(\"freeze\")){\n                       document.body.classList.add('bodyWrapper');\n                       // LytePopup.bodywrapperCount += 1;\n                   }\n                   if(_this.getData('first')){\n                       // LytePopup.bindTransitionEnd(_this.actualModalDiv);\n                       _this.callOnShow();\n                       _this.setData(\"first\",false);\n                   }\n               },_this);\n               /*------------------------------ MUTATE ENDS --------------------------*/\n           }\n           else{\n               _this.setData('ltPropOffset',{left:\"center\", top:\"center\"});\n               // _this.data.ltPropOffset.left = \"center\";\n               // _this.data.ltPropOffset.top = \"center\";\n               offsetObj.left = ((w - modalElePosition.width)/2);\n               offsetObj.top = ((h - modalElePosition.height)/2);\n               if(!_this.$node.ltProp(\"scrollable\")){\n                   if(offsetObj.left < 0){\n                       offsetObj.left = 20;\n                   }\n                   if(offsetObj.top < 0){\n                       offsetObj.top = 20;\n                   }\n               }\n               if(_this.getData('ltPropTransition').originElement){\n                   var ele = document.querySelector(_this.getData('ltPropTransition').originElement);\n                   if(!ele){\n                       console.error(\"The originElement provided does not exist. Kindly Check!\");\n                   }\n                   else{\n                       var eleOffset = ele.getBoundingClientRect();\n                       offsetObj.originElementPos = {xDiff : (eleOffset.left + (eleOffset.width/2)) - (offsetObj.left + (modalElePosition.width/2)),\n                                                     yDiff : (eleOffset.top + (eleOffset.height/2)) - (offsetObj.top + (modalElePosition.height/2)) };\n                   }\n               }\n               /*------------------------------ MUTATE STARTS --------------------------*/\n               _this.fastdomfn8 = $L.fastdom.mutate(function() {\n                   delete _this.fastdomfn8;\n                   if(_this.getData('first')){\n                       window.LytePopup.bindTransitionEnd(_this.actualModalDiv);\n                   }\n                   if(_this.getData('ltPropTransition').animation == \"slideFromTop\"){\n                       modalEle.style.left = parseFloat(offsetObj.left) + \"px\";\n                       modalEle.style.top = (-1 * modalElePosition.height) + \"px\";\n                       if(triggeredFromTransChange){\n                           modalEle.style.transform = \"translate(0px,\"+(parseInt(offsetObj.top)+modalElePosition.height)+\"px)\";\n                           _this.transform = {'x' : 0, 'y' : (parseInt(offsetObj.top)+modalElePosition.height)};\n                           return;\n                       }\n                       _this.enableTransform(parseInt(offsetObj.top)+modalElePosition.height,\"y\",arg);\n                   }\n                   else if(_this.getData('ltPropTransition').animation == \"slideFromBottom\"){\n                       modalEle.style.left = parseFloat(offsetObj.left) + \"px\";\n                       modalEle.style.top = h+1 + \"px\";\n                       if(triggeredFromTransChange){\n                           modalEle.style.transform = \"translate(0px,\"+(-1 * (h - parseInt(offsetObj.top) + 1))+\"px)\";\n                           _this.transform = {'x': 0, 'y': (-1 * (h - parseInt(offsetObj.top) + 1))};\n                           return;\n                       }\n                       _this.enableTransform(-1 * (h - parseInt(offsetObj.top) + 1),\"y\",arg);\n                   }\n                   else if(_this.getData('ltPropTransition').animation == \"slideFromLeft\"){\n                       if(_this.renderSidewise){\n                           if(freezeLayer){\n                               freezeLayer.style.left = _this.renderProps.right + \"px\";\n                           }\n                           if(wrapperDiv){\n                               wrapperDiv.style.left = _this.renderProps.right + \"px\";\n                           }\n                       }\n                       modalEle.style.top = parseFloat(offsetObj.top) + \"px\";\n                       modalEle.style.left = (-1 * modalElePosition.width) + \"px\";\n                       if(triggeredFromTransChange){\n                           modalEle.style.transform = \"translate(\"+(parseInt(offsetObj.left)+modalElePosition.width)+\"px,0px)\";\n                           _this.transform = {'x' : (parseInt(offsetObj.left)+modalElePosition.width), 'y' : 0};\n                           return;\n                       }\n                       _this.enableTransform(parseInt(offsetObj.left)+modalElePosition.width,'x',arg);\n                   }\n                   else if(_this.getData('ltPropTransition').animation == \"slideFromRight\"){\n                       if(_this.renderSidewise){\n                           var rightValue = _this.renderProps.windowWidth - _this.renderProps.left;\n                           if(freezeLayer){\n                               freezeLayer.style.right = rightValue + \"px\";\n                           }\n                           if(wrapperDiv){\n                               wrapperDiv.style.right = rightValue - 5 + \"px\";\n                           }\n                       }\n                       modalEle.style.top = parseFloat(offsetObj.top) + \"px\";\n                       modalEle.style.left = w + 1 + \"px\";\n                       if(triggeredFromTransChange){\n                           modalEle.style.transform = \"translate(\"+(-1 * (w - parseInt(offsetObj.left) + 1))+\"px,0px)\";\n                           _this.transform = {'x' : (-1 * (w - parseInt(offsetObj.left) + 1)), 'y' : 0};\n                           return;\n                       }\n                       _this.enableTransform(-1 * (w - parseInt(offsetObj.left) + 1),'x',arg);\n                   }\n                   else if(_this.getData('ltPropTransition').animation == \"fadeIn\"){\n                       modalEle.style.left = parseFloat(offsetObj.left) + \"px\";\n                       modalEle.style.top = parseFloat(offsetObj.top) + \"px\";\n                       if(triggeredFromTransChange){\n                           modalEle.style.transform = \"\";\n                           return;\n                       }\n                       _this.$node.ltProp('showCopy',true);\n                       // setTimeout(function(){\n                           modalEle.style.opacity = 1;\n                       // },200);\n                   }\n                   else if(_this.getData('ltPropTransition').animation == \"zoom\"){\n                       _this.$node.ltProp('showCopy',true);\n                       var transform = \"scale(0)\";\n                       if(offsetObj.originElementPos){\n                           transform = \"translateX( \"+ offsetObj.originElementPos.xDiff + \"px) translateY( \"+ offsetObj.originElementPos.yDiff + \"px) scale(0)\";\n                       }\n                       modalEle.style.left = parseFloat(offsetObj.left) + \"px\";\n                       modalEle.style.top = parseFloat(offsetObj.top) + \"px\";\n                       modalEle.style.transition = \"none\";\n                       if(triggeredFromTransChange){\n                           modalEle.style.transform = offsetObj.originElementPos ? 'translateX(0) translateY(0) scale(1)' : 'scale(1)';\n                           setTimeout(function(){\n                               modalEle.style.transition = \"\";\n                           },16)\n                           return;\n                       }\n                       modalEle.style.transform = transform;\n                       modalEle.style.opacity = 1;\n                       setTimeout(function(){\n                           modalEle.style.transition = \"\";\n                           modalEle.style.transitionDuration = (arg != undefined ? arg : _this.$node.ltProp(\"transition\").duration)+\"s\";\n                           if(offsetObj.originElementPos){\n                               modalEle.style.transform = 'translateX(0) translateY(0) scale(1)';\n                           }\n                           else{\n                               modalEle.style.transform = 'scale(1)';\n                           }\n                       },50);\n                   }\n                   if(_this.$node.ltProp(\"freeze\")){\n                       document.body.classList.add('bodyWrapper');\n                       // LytePopup.bodywrapperCount += 1;\n                   }\n                   if(_this.getData('first')){\n                       _this.callOnShow();\n                       _this.setData(\"first\",false);\n                   }\n               },_this);\n               /*------------------------------ MUTATE ENDS --------------------------*/\n           }\n       },_this);\n        /*------------------------------ MEASURE ENDS --------------------------*/\n        // modalEle = null;\n    }\n\n    /**\n     * The method is going to check if sidewise render will be done and assigns the values that will be used for sidewise rendering of the modal\n     *\n     */\n    calculateForSidewiseRender() {\n        if(window.LytePopup.components.length > 1){\n            var prevModal;\n            // if(this.getData('modalCreationOrder') > 0) {\n            // // if(LytePopup.components[LytePopup.components.length - 2].$node.tagName === \"LYTE-MODAL\"){\n                // prevModal = LytePopup.components[this.getData('modalCreationOrder')-1];\n            // }\n            var parentModalId = this.getData('ltPropParentModalId');\n            if( parentModalId != '') {\n                prevModal = $L(parentModalId)[0].component;\n            }\n            else if(parentModalId == '' && this.getData('ltPropDependentModalId') == '') {\n                var curModalIndexInArray = window.LytePopup.components.indexOf(this);\n\t\t\t\tif((curModalIndexInArray > 0) && (window.LytePopup.components[curModalIndexInArray - 1].$node.tagName === \"LYTE-MODAL\")){\n\t\t\t\t\tprevModal = window.LytePopup.components[curModalIndexInArray - 1];\n\t\t\t\t}\n            }\n            if(!this.getData('ltPropOverlapModal') && prevModal && prevModal.getData('ltPropAllowMultiple') && [\"slideFromLeft\",\"slideFromRight\"].indexOf(this.getData('ltPropTransition').animation) != -1){\n                this.renderSidewise = true;\n                var prevModalOffset = prevModal.actualModalDiv.getBoundingClientRect();\n                this.renderProps = {\n                    prevModal : prevModal,\n                    left : Math.round(prevModalOffset.left),\n                    right : Math.round(prevModalOffset.right),\n                    width : Math.round(prevModalOffset.width)\n                };\n            }\n        }\n    }\n\n    closeModal() {\n        var freezeLayer = this.childComp.querySelector('lyte-modal-freeze');\n        if(this.renderSidewise){\n            if(this.getData('ltPropTransition').animation == \"slideFromRight\"){\n                if(freezeLayer){\n                    freezeLayer.style.right = \"\";\n                }\n                this.actualModalDiv.parentElement.style.right = \"\";\n            }\n            if(this.getData('ltPropTransition').animation == \"slideFromLeft\"){\n                if(freezeLayer){\n                    freezeLayer.style.left = \"\";\n                }\n                this.actualModalDiv.parentElement.style.left = \"\";\n            }\n            delete this.renderSidewise;\n            delete this.renderProps;\n        }\n        if(window._lyteUiUtils.getRTL()){\n            if(!this.getData('ltPropIgnoreInlineDirection')){\n              if(this.getData('ltPropTransition').animation == \"slideFromLeft\"){\n                  this.getData('ltPropTransition').animation = \"slideFromRight\";\n              }\n              else if(this.getData('ltPropTransition').animation == \"slideFromRight\"){\n                  this.getData('ltPropTransition').animation = \"slideFromLeft\";\n              }\n            var offset = this.getData('ltPropOffset'),\n                newOffset = {};\n            for(window.key in offset){\n                if(window.key == \"left\" && offset[window.key] != \"center\"){\n                    newOffset.right = offset[window.key];\n                }\n                else if(window.key == \"right\"){\n                    newOffset.left = offset[window.key];\n                }\n                else{\n                    newOffset[window.key] = offset[window.key];\n                }\n            }\n            this.setData('ltPropOffset',newOffset);\n          }\n        }\n        if(this.getData('ltPropTransition').animation == \"zoom\"){\n            this.actualModalDiv.style.opacity = \"0\";\n            this.actualModalDiv.style.transform = \"\";\n        }\n        if(!this.$node.ltProp('freeze')){\n            this.childComp.querySelector(\".modalWrapper\").classList.remove('noFreeze');\n        }\n        this.$node.ltProp({\"showCopy\":false,\"show\":false});\n        // LytePopup.closePopup(this);\n\n        if(!this.$node.ltProp('freeze')){\n            this.actualModalDiv.style.position = \"\";\n        }\n        this.$node.classList.remove('lyteModalOpened');\n        if(this.actualModalDiv){\n            this.actualModalDiv.style.transform = \"\";\n        }\n\n\t\tvar transitionDuration = this.getData('ltPropTransition').duration;\n\t\tvar closeDuration = this.getData('ltPropCloseDuration');\n\t\tif(closeDuration) {\n\t\t\ttransitionDuration = (closeDuration / 1000);\n\t\t}\n\t\tvar _this = this;\n\t\tsetTimeout(function() {\n\t\t\tvar modalElem = _this.$node;\n            if(modalElem){\n                modalElem.ltProp({\"showCopy\":false, \"show\": false});\n                modalElem.classList.remove('lyteModalOpened');\n                $L(_this.childComp).addClass('lyteModalHidden');\n                if( _this.getData('ltPropTransition').animation == \"zoom\"){\n                    _this.actualModalDiv.style.opacity = \"0\";\n                    _this.actualModalDiv.style.transform = \"\";\n                }\n            }\n            if(_this.getMethods(\"onClose\")){\n                _this.executeMethod(\"onClose\",_this);\n            }\n\t\t}, (transitionDuration * 1000));\n\n        window._lyteUiUtils.dispatchEvent('lyteModalClosed' , this.actualModalDiv)\n        if(window._lyteUiUtils.popupStack.modalStack.length < 1 ){\n            document.body.classList.remove('bodyWrapper');\n            document.body.classList.remove('lyteBodyWrapper');\n        }\n        this.setData('ltPropShowWormhole' , false);\n        // if(this.getMethods(\"onClose\")){\n        //     this.executeMethod(\"onClose\",this);\n        // }\n        window.LytePopup.checkAndRemoveWrapper();\n    }\n\n    onBeforeCloseHandling(event) {\n        var result = true;\n        var w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n        var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n        if(this.actualModalDiv){\n            window._lyteUiUtils.dispatchEvent('lyteModalBeforeClose' , this.actualModalDiv)\n        }\n        if(this.getMethods(\"onBeforeClose\")){\n            result = this.executeMethod(\"onBeforeClose\",event,this);\n        }\n        if(result === undefined || result){\n            if(this.actualModalDiv && this.childComp){\n                if(this.getData('ltPropFreeze') && this.addedFreezeDetails){\n                    window.LytePopup.hideOrShowFreeze(\"close\",this);\n                    delete this.addedFreezeDetails;\n                }\n                var animDur = parseFloat(this.$node.ltProp('transition').duration) * 1000;\n                var self = this;\n                // console.log(\"duration\",animDur);\n                // var t1 = performance.now();\n                this.timeOutId = setTimeout(function(){\n                    delete self.timeOutId;\n                    // var t2 = performance.now();\n                    // console.log(t2 -t1);\n                    self.closeModal();\n                },animDur);\n                var modalEle = this.actualModalDiv;\n                if(this.getData('ltPropCloseDuration')){\n                    modalEle.style.transitionDuration = (this.getData('ltPropCloseDuration') / 1000)+\"s\";\n                }\n                else{\n                    modalEle.style.transitionDuration = (animDur / 1000)+\"s\";\n                }\n                // console.log(\"transitionDuration\", modalEle.style.transitionDuration);\n                var modalElemOffset;\n                var transform = \"scale(0)\", transformVal;\n                /*------------------------------ MEASURE STARTS --------------------------*/\n                $L.fastdom.measure(function(){\n                    modalElemOffset = modalEle.getBoundingClientRect();\n                    if(this.getData('ltPropTransition').animation == \"zoom\" && this.getData('ltPropTransition').originElement){\n                        var ele = document.querySelector(this.getData('ltPropTransition').originElement);\n                        if(!ele){\n                            Console.error(\"The originElement provided does not exist. Kindly Check!\");\n                        }\n                        else{\n                            var eleOffset = ele.getBoundingClientRect();\n                            var modalElePosition = {top: modalElemOffset.top,\n                                                    right: modalElemOffset.right,\n                                                    bottom: modalElemOffset.bottom,\n                                                    left: modalElemOffset.left,\n                                                    width: modalEle.offsetWidth,\n                                                    height: modalEle.offsetHeight\n                                                };\n                            var originElementPos = {xDiff : (eleOffset.left + (eleOffset.width/2)) - (modalElePosition.left + (modalElePosition.width/2)),\n                                                          yDiff : (eleOffset.top + (eleOffset.height/2)) - (modalElePosition.top + (modalElePosition.height/2)) };\n                            transform = \"translateX( \"+ originElementPos.xDiff + \"px) translateY( \"+ originElementPos.yDiff + \"px) scale(0)\"\n                        }\n                    }\n                },this);\n                /*------------------------------ MEASURE ENDS --------------------------*/\n                /*------------------------------ MUTATE STARTS --------------------------*/\n                $L.fastdom.mutate(function(){\n                    if(this.getData('ltPropTransition').animation == \"slideFromTop\"){\n                        // modalEle.style.transform = \"translateY(-100%)\";\n                        transformVal = -(Math.ceil(modalElemOffset.height) + parseInt(modalEle.style.top) + 10) + \"px\";\n                        modalEle.style.transform = \"translateY(\"+transformVal+\")\";\n                    }\n                    else if(this.getData('ltPropTransition').animation == \"slideFromBottom\"){\n                        // modalEle.style.transform = \"translateY(100%)\";\n                        transformVal = (h - parseInt(modalEle.style.top) + 10) + \"px\";\n                        modalEle.style.transform = \"translateY(\"+transformVal+\")\";\n                    }\n                    else if(this.getData('ltPropTransition').animation == \"slideFromLeft\"){\n                        // modalEle.style.transform = \"translateX(-100%)\";\n                        transformVal = -(Math.ceil(modalElemOffset.width) + parseInt(modalEle.style.left) + 10) + \"px\";\n                        modalEle.style.transform = \"translateX(\"+transformVal+\")\";\n                    }\n                    else if(this.getData('ltPropTransition').animation == \"slideFromRight\"){\n                        // modalEle.style.transform = \"translateX(100%)\";\n                        transformVal = (((this.renderProps && this.renderProps.left) || w ) - parseInt(modalEle.style.left) + 10) + \"px\";\n                        modalEle.style.transform = \"translateX(\"+transformVal+\")\";\n                    }\n                    else if(this.getData('ltPropTransition').animation == \"fadeIn\"){\n                        modalEle.style.opacity = 0;\n                    }\n                    else if(this.getData('ltPropTransition').animation == \"zoom\"){\n                        modalEle.style.transform = transform;\n                    }\n                    delete this.transform;\n                    if(!(this.$node.classList.contains('lyteModalOpened'))){\n                        modalEle.style.transform = \"\";\n                    }\n                },this);\n                $L.fastdom.mutate(function(){\n                    modalEle = null;\n                });\n                /*------------------------------ MUTATE ENDS --------------------------*/\n\n                modalEle.classList.remove('lyteModalFromTop','lyteModalFromBottom','lyteModalFromLeft','lyteModalFromRight','lyteModalFadeIn','lyteZoom');\n                if(this.$node.ltProp('freeze') && this.childComp.querySelector(\"lyte-modal-freeze\")){\n                    var freezeLayer = this.childComp.querySelector(\"lyte-modal-freeze\");\n                    setTimeout(function(){\n                        freezeLayer.style.opacity = 0;\n                        freezeLayer.style.visibility = \"\";\n                    }.bind(this), 300);\n                }\n                window.LytePopup.closePopup(this);\n                // LytePopup.bindTransitionEnd(this.actualModalDiv);\n                this.setData(\"first\",true);\n                this.setData('initializedPosition',false);\n                this.setData('calculateHW', false);\n            }\n            this.$node.alignModal = null;\n            this.$node.resetPosition = null;\n            this.$node.alignLyteModal = null;\n            this.$node.calculateOffset = null;\n            this.$node.reflectTransitionChange = null;\n        }\n        else{\n            this.setData('returnedFalse',true);\n            this.$node.ltProp('show',true);\n        }\n    }\n\n    onBeforeShowHandling() {\n        var result = true;\n        if(this.getMethods(\"onBeforeShow\")){\n            result = this.executeMethod(\"onBeforeShow\",this) ;\n        }\n        // if(!_lyteUiUtils.modalCreationOrder){\n        //   _lyteUiUtils.modalCreationOrder = 0\n        // }\n        // _lyteUiUtils.modalCreationOrder += 1\n        // this.setData('modalCreationOrder' , _lyteUiUtils.modalCreationOrder-1);\n        if(result === undefined || result){\n            this.setData('checkAria', this.getData('checkAria')+1);\n            this.addDragHandler();\n            this.updateScrollHandling();\n\n            var modalEle = this.actualModalDiv;\n            var val = \"\";\n            modalEle.style.transitionDuration = this.$node.ltProp(\"transition\").duration+\"s\";\n            var classVal = \"lyteModalFrom\";\n            var modalStyle = this.actualModalDiv.style;\n            var modalElemOffset = this.actualModalDiv.getBoundingClientRect();\n            var windowWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n\n            switch(this.$node.ltProp(\"transition\").animation){\n                case \"slideFromTop\":\n                    classVal += \"Top\";\n                    break;\n                case \"slideFromBottom\":\n                    classVal += \"Bottom\";\n                    break;\n                case \"slideFromLeft\":\n                    classVal += \"Left\";\n                    break;\n                case \"slideFromRight\":\n                    classVal += \"Right\";\n                    break;\n                case \"fadeIn\":\n                    classVal = \"lyteModalFadeIn\";\n                    break;\n                case \"zoom\":\n                    classVal = \"lyteZoom\";\n                    break;\n            }\n            /*------------------------------ MUTATE STARTS --------------------------*/\n            this.fastdomfn1 = $L.fastdom.mutate(function(){\n                delete this.fastdomfn1;\n                this.actualModalDiv.classList.add(classVal);\n                this.actualModalDiv.style.opacity = \"\";\n                modalEle = null;\n            },this);\n            /*------------------------------ MUTATE ENDS --------------------------*/\n            window.LytePopup.addPopup(this);\n            this.calculateForSidewiseRender();\n            if(this.$node.ltProp('freeze')){\n                var freezeLayer = this.childComp.querySelector(\"lyte-modal-freeze\");\n                if(this.renderSidewise){\n                    if(this.getData('ltPropTransition').animation == 'slideFromRight'){\n                        freezeLayer.style.right = (windowWidth - this.renderProps.left) + \"px\";\n                    }\n                    if(this.getData('ltPropTransition').animation == 'slideFromLeft'){\n                        freezeLayer.style.left = this.renderProps.right + \"px\";\n                    }\n\n                }\n                var freezeStyle = freezeLayer.style;\n                // freezeStyle.opacity = this.getData('ltPropDimmer').opacity;\n                if(this.getData('ltPropDimmer') && this.getData('ltPropDimmer').color){\n                    freezeStyle.background = this.getData('ltPropDimmer').color;\n                }\n                if(!this.addedFreezeDetails){\n                    freezeStyle.opacity = this.getData('ltPropDimmer') && this.getData('ltPropDimmer').opacity ? this.getData('ltPropDimmer').opacity : \"\";\n                }\n            }\n            this.$node.alignModal = this.computeOffsetImpl.bind(this, 0, true)\n            this.$node.resetPosition = function(){\n              window.LytePopup.x = this.getData('beforeDragPosition').xPos\n              LytePopup.y = this.getData('beforeDragPosition').yPos\n              LytePopup.xPos = this.getData('beforeDragPosition').xPos\n              LytePopup.yPos = this.getData('beforeDragPosition').yPos\n              this.component.transform.x = this.getData('beforeDragPosition').xPos\n              this.component.transform.y = this.getData('beforeDragPosition').yPos\n              if(this.getData('ltPropTransition').animation === \"zoom\"){\n                this.component.actualModalDiv.style.transform = \"translate(\"+this.getData('beforeDragPosition').xPos+\"px ,\"+this.getData('beforeDragPosition').yPos+\"px) scale(\"+this.getData('beforeDragPosition').scale+\")\"\n              } else {\n                this.component.actualModalDiv.style.transform = \"translate(\"+this.getData('beforeDragPosition').xPos+\"px ,\"+this.getData('beforeDragPosition').yPos+\"px)\"\n              }\n            }\n            this.$node.alignLyteModal = function(){\n              this.component.updateScrollHandling()\n              this.component.computeOffsetImpl.bind(this.component, 0, true)\n            }\n            this.$node.calculateOffset = this.updateScrollHandling.bind(this);\n            this.$node.reflectTransitionChange = this.reflectTransitionChange.bind(this);\n        }\n        else{\n            this.setData('returnedFalse',true);\n            this.$node.ltProp({\"showCopy\":false,\"show\":false});\n        }\n    }\n\n    /**\n     * The method is going to change the transition property when the modal is opened with different animation and closed with different animation\n     * This util function is required to be triggered by the developer after they change the ltPropTransition value\n     * The function can be triggered in onShow inside a setTimeout of 500ms or before the ltPropShow of the modal is set to false\n     *\n     */\n    reflectTransitionChange() {\n        this.computeOffsetImpl(null, true);\n    }\n\n    didDestroy() {\n        //   _lyteUiUtils.modalCreationOrder -= 1;\n        this.setData('ltPropShowWormhole', false);\n        this.$node.classList.remove('lyteModalOpened');\n        if(this.timeOutId){\n            clearTimeout(this.timeOutId);\n            delete this.timeOutId;\n        }\n        if(this.beforeCloseId){\n            clearTimeout(this.beforeCloseId);\n            delete this.beforeCloseId;\n        }\n        if(this.renderSidewise){\n            delete this.renderSidewise;\n            delete this.renderProps;\n        }\n        if(this.childComp){\n            this.clearFastdomBatch();\n            if(this.getData('ltPropFreeze') && this.addedFreezeDetails){\n                window.LytePopup.hideOrShowFreeze(\"close\",this);\n                delete this.addedFreezeDetails;\n            }\n            window.LytePopup.closePopup(this);\n            this.childComp.remove();\n            delete this.actualModalDiv;\n            delete this.childComp;\n            // if(this.$node.ltProp('freeze')){\n            //     LytePopup.bodywrapperCount -= 1;\n            //     if(LytePopup.bodywrapperCount == 0 || LytePopup.components.length == 0){\n            //         document.body.classList.remove('bodyWrapper');\n            //     }\n            // }\n            window.LytePopup.checkAndRemoveWrapper();\n        }\n        // LytePopup.components = [];\n    }\n\n    static actions() {\n        return {\n            close : function(){\n               this.$node.ltProp(\"show\",false);\n            }\n        };\n    }\n\n    static methods() {\n        return {\n            beforeWormholeAppend : function(arg){\n                if(this.childComp){\n                    delete this.childComp;\n                }\n                if(this.actualModalDiv){\n                    delete this.actualModalDiv;\n                }\n                this.childComp = arg;\n                this.actualModalDiv = this.childComp.querySelector(\".lyteModal\");\n            }\n        };\n    }\n\n    static observers() {\n        return {\n            showToggled : function(){\n\n                var event = event || window.event;\n                if(this.getData('returnedFalse')){\n                    this.setData('returnedFalse',false);\n                    return;\n                }\n                if(this.$node.ltProp(\"reRenderModal\")){\n                    if(this.$node.ltProp(\"show\")){\n                        this.$node.ltProp({\"showCopy\":false, \"show\":false});\n                        window.LytePopup.closePopup(this);\n                        this.setData(\"first\",true);\n                        this.setData('initializedPosition',false);\n                    }\n                    this.$node.ltProp(\"reRenderModal\",false);\n                }\n                if(this.timeOutId){\n                    delete this.timeOutId;\n                    this.closeModal();\n                    window.LytePopup.closePopup(this);\n                }\n                if(this.$node.ltProp(\"show\") && !this.$node.ltProp(\"showCopy\")){\n                    $L(this.childComp).removeClass('lyteModalHidden')\n                    if(window._lyteUiUtils.getRTL()){\n                      if(!this.getData('ltPropIgnoreInlineDirection')){\n                        if(this.getData('ltPropTransition').animation == \"slideFromLeft\"){\n                            this.getData('ltPropTransition').animation = \"slideFromRight\";\n                        }\n                        else if(this.getData('ltPropTransition').animation == \"slideFromRight\"){\n                            this.getData('ltPropTransition').animation = \"slideFromLeft\";\n                        }\n                        var offset = this.getData('ltPropOffset'),\n                            newOffset = {};\n                        for(window.key in offset){\n                            if(window.key == \"left\" && offset[window.key] != \"center\"){\n                                newOffset.right = offset[window.key];\n                            }\n                            else if(window.key == \"right\"){\n                                newOffset.left = offset[window.key];\n                            }\n                            else{\n                                newOffset[window.key] = offset[window.key];\n                            }\n                        }\n                        this.setData('ltPropOffset',newOffset);\n                      }\n                    }\n                    if(window.LytePopup.components.indexOf(this) != -1){\n                        window.LytePopup.closePopup(this);\n                        this.setData(\"first\",true);\n                        this.setData('initializedPosition',false);\n                    }\n                    this.$node.ltProp(\"bindToBody\",true);\n                    window._lyteUiUtils.dispatchEvent('lyteModalBeforeOpen' , this.actualModalDiv)\n                    this.setData('ltPropShowWormhole' , true)\n\n                    if(this.getData('ltPropPadding') !== ''){\n                        var modalYield = $L(this.childComp).find('.lyteModalYield').eq(0)\n                        modalYield.addClass('lyteModalYieldWithPadding')\n                        modalYield[0].style.padding = this.getData('ltPropPadding')\n                    }\n\n                    var self = this;\n                    this.beforeShowId = setTimeout(function(){\n                        delete self.beforeShowId;\n                        self.onBeforeShowHandling();\n                    },0);\n\n                }\n                else{\n                    this.setData('ltPropShowWormhole' , false)\n                    if(this.transitionEndTimeout){\n                        clearTimeout(this.transitionEndTimeout);\n                        delete this.transitionEndTimeout;\n                    }\n                    this.clearFastdomBatch();\n                    if(this.$node.ltProp(\"showCopy\")){\n                        var self = this;\n                        this.beforeCloseId = setTimeout(function(){\n                            delete self.beforeCloseId;\n                            self.onBeforeCloseHandling(event);\n                        },0);\n                    }\n                    else{\n                        if(window.LytePopup.components.indexOf(this) != -1){\n                            window.LytePopup.closePopup(this);\n                            this.setData(\"first\",true);\n                            this.setData('initializedPosition',false);\n                        }\n                    }\n                }\n            }.observes(\"ltPropShow\",\"ltPropReRenderModal\").on('didConnect'),\n\n            triggerDraggable : function(){\n              this.addDragHandler();\n            }.observes(\"ltPropDraggable\"),\n\n            changeBindToBody : function(){\n                if(!this.getData('ltPropBindToBody')){\n                    if(this.getData('ltPropFreeze') && this.addedFreezeDetails){\n                        window.LytePopup.hideOrShowFreeze(\"close\",this,true);\n                        delete this.addedFreezeDetails;\n                    }\n                    window.LytePopup.closePopup(this);\n                    if(this.renderSidewise){\n                        delete this.renderSidewise;\n                        delete this.renderProps;\n                    }\n                    this.actualModalDiv = null;\n                    this.childComp = null;\n                    if(this.getData('ltPropShow') ){\n                        this.setData({'ltPropShowCopy':false,'ltPropShow':false});\n                    }\n                    else if(this.getData('ltPropShowCopy')){\n                        this.setData('ltPropShowCopy', false);\n                    }\n                    this.setData(\"first\",true);\n                    this.setData('initializedPosition',false);\n                    this.$node.classList.remove('lyteModalOpened');\n                    // if(this.$node.ltProp('freeze')){\n                    //     LytePopup.bodywrapperCount -= 1;\n                    //     if(LytePopup.bodywrapperCount == 0){\n                    //         document.body.classList.remove('bodyWrapper');\n                    //     }\n                    // }\n                    window.LytePopup.checkAndRemoveWrapper();\n                }\n            }.observes(\"ltPropBindToBody\"),\n\n            addAriaValues : function( arg ) {\n                if(this.getData('ltPropAria')){\n                    var ariaProp = this.getData('ltPropAriaAttributes') || {};\n                    $L(this.actualModalDiv).attr('aria-modal' , true)\n                    $L(this.actualModalDiv).attr('aria-expanded' , this.getData('ltPropShow'))\n                    window._lyteUiUtils.setAttribute( this.actualModalDiv, ariaProp, arg ? arg.oldValue : {} );\n                    var closeIcon = this.actualModalDiv.querySelector('.lyteModalClose');\n                    if(closeIcon){\n                        closeIcon.setAttribute('aria-label', ariaProp['close-label'] || 'Close icon at top right position');\n                    }\n                }\n            }.observes('ltPropAriaAttributes','ltPropAriaAttributes.{}','checkAria'),\n\n            scrollHandling : function(){\n                if(!this.getData('ltPropShow')){\n                    return;\n                }\n                this.updateScrollHandling();\n            }.observes(\"ltPropWidth\",\"ltPropMaxWidth\",\"ltPropHeight\",\"ltPropMaxHeight\")\n        };\n    }\n}\n\nif (document.readyState === \"complete\" || document.readyState === \"interactive\"){\n    window.addModalEvent();\n}\nelse{\n    document.addEventListener(\"DOMContentLoaded\", function(event){\n        window.addModalEvent(event);\n    });\n}\n\nif (typeof Object.assign != 'function') {\n  // Must be writable: true, enumerable: false, configurable: true\n  Object.defineProperty(Object, \"assign\", {\n    value: window.assign = function(target, varArgs) { // .length of function is 2\n      'use strict';\n      if (target == null) { // TypeError if undefined or null\n        throw new TypeError('Cannot convert undefined or null to object');\n      }\n\n      var to = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var nextSource = arguments[index];\n\n        if (nextSource != null) { // Skip over if undefined or null\n          for (var nextKey in nextSource) {\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n      return to;\n    },\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * @syntax yielded\n * <lyte-modal>\n *     <template is = \"registerYield\" yield-name = \"modal\">\n *         <lyte-modal-header> Create Profile </lyte-modal-header>\n *         <lyte-modal-content>\n *             //Some Content\n *         </lyte-modal-content>\n *         <lyte-modal-footer class = \"right\">\n *             //Some button\n *         </lyte-modal-footer>\n *     </template>\n * </lyte-modal>\n */\nexport { LyteModalComponent };\n","import { LyteTableUtilsMixin } from \"/mixins/lyte-table-utils.js\"\nimport { LyteTableSortableMixin } from \"/mixins/lyte-table-sortable.js\"\nimport { prop } from \"@slyte/core\";\nimport { Component, LyteUiComponentComponentRegistry } from \"../component.js\";\nimport $L from \"@zoho/lyte-dom\";\n\nimport \"../../plugins/lyte-scrollbar.js\";\n\n// Issues to fix\n\n// Combined width of fixed column should not exceed width of lyte-table\n\n/**\n * Lyte-table is a component used to display data in rows and columns\n * @component lyte-table\n * @dependency lyte-scrollbar\n *  /plugins/lyte-scrollbar.js\n *  /theme/compiledCSS/default/ltr/lyte-ui-scrollbar.css\n * @version 1.0.0\n */\n\nclass LyteTableComponent extends Component {\n    constructor() {\n        super();\n    }\n\n    init() {\n        var uA = window.navigator.userAgent,\n        cb = \"beforeRender\",\n        __this = this,\n        $node = __this.$node,\n        __window = window,\n        add = \"addEventListener\",\n        ns = '_tableResize';\n        \n        __this._dir = window._lyteUiUtils.getRTL();\n        __this.isIE11Lyte = /rv:11/ig.test( uA );\n        __this.isEdgeLyte = /Edge/ig.test( uA );\n        __this._browser = __this.isIE11Lyte || __this.isEdgeLyte || uA.match( 'Safari' );\n\n        /**\n         * @method beforeRender\n         * @version 1.0.1\n         */\n\n        __this.getMethods( cb ) && __this.executeMethod( cb, $node );\n\n        /**\n         * @utility scrollTable\n         * @version 1.0.4\n         */\n\n        $node.scrollTable = function( x, y ){\n            var scrollElem = ( __this.scrollDiv = __this.scrollDiv || $node.querySelector( 'div.lyteTableScroll' ) ),\n            undef = void 0,\n            evt = new Event( 'scroll', { bubbles: true } );\n\n            if( x != undef ){\n                scrollElem.scrollLeft = x;\n            }\n\n            if( y != undef ){\n                scrollElem.scrollTop = y;\n            }\n\n            evt._byFunc = true;\n            scrollElem.dispatchEvent( evt );\n\n            if( !__this.__from_collapse ){\n                __this.update_collapse( true );\n            }\n        }\n        /**\n         * @utility updateCollapse\n         * @version 3.92.0\n         */\n        $node.updateCollapse = __this.update_collapse.bind( __this );\n\n        if( !__window[ ns ] ){\n            __window[ ns ] = true;\n\n            var fn = window.resizeTable;\n\n            __window[ add ]( 'resize', fn, true );\n            __window[ add ]( 'orientationchange', fn, true );\n        }\n\n        /**\n         * @utility toggleRows\n         * @version 1.0.3\n         */\n\n         $node.toggleRows = function( val ){\n            var name = val ? 'remove' : \"add\",\n            __tags = this.ltProp('tags');\n\n            Array.from( this.querySelectorAll( __tags.tbody + ' ' + __tags.tr + '.lytePreventInfiniteScroll' ) ).forEach( function( item ){\n                item.classList[ name ]( 'lyteHidden' );\n            });\n         }\n\n    }\n\n    rtlfunc(lft, bcr, ww) {\n        if( this._dir && lft != 'top' && lft != 'clientY' ){\n            if( bcr ){\n                if( lft == 'right' ){\n                    return ww - bcr.left;\n                } else if( lft == 'clientX' ){\n                    return ww - bcr[ lft ];\n                }\n                return ww - bcr.right;\n            } else if( lft == 'left' ){\n                return 'right';\n            } else if( lft == \"right\" ){\n                return \"left\";\n            }\n        }\n        return bcr ? bcr[ lft ] : lft;\n    }\n\n    didDestroy() {\n        var __this = this,\n        __data = __this.data,\n        scrolldiv = __this.scrollDiv,\n        $node = __this.$node,\n        _window = window,\n        iso = __this._intersectionObs;\n\n        if( _window._tableResize && document.body.getElementsByTagName( 'lyte-table' ).length == 0 ){\n            var rel = \"removeEventListener\";\n\n            _window[ rel ]( 'resize', window.resizeTable, true );\n            _window[ rel ]( 'orientationchange', window.resizeTable, true );\n\n            delete _window._tableResize;\n        }\n\n        if( __data.ltPropNavigation ){\n           window._lyteUiUtils.tableNavigation( $node.getElementsByTagName( __data.ltPropTags.table )[ 0 ], 'unbind' );\n        }\n\n        $L.fastdom.clear( this.__collpse_fdom );\n        delete this.__collpse_fdom;\n\n        if( iso ){\n            __this._setmeasure && $L.fastdom.clear( __this._setmeasure );\n            iso.disconnect();\n\n            delete __this.reset;\n            delete __this._intersectionObs;\n            delete __this._intersections;\n        }\n\n        !__data.ltPropPreventScrollbar && scrolldiv && $L( scrolldiv ).removeScroll();\n\n        delete __this.scrollDiv; delete __this._dummy; delete __this._dummy1; delete __this.resizeComponent; delete __this.targetElem; delete __this._dummyTr;\n        delete $node.setValue; delete $node.scrollTable;\n    }\n\n    didConnect() {\n        var __data = this.data,\n        ltPropInfiniteScroll = __data.ltPropInfiniteScroll, \n        secData = __data.secondaryData,\n        // ltPropResize = __data.ltPropResize,\n        $node = this.$node,\n        __tags = __data.ltPropTags;\n\n        // if( __data.ltPropYield && (ltPropResize.vertical || ltPropResize.horizontal)) {\n        //     this.resizeComponentAppend();\n        // }\n        try {\n            var scrollDiv = $node.querySelector('div.lyteTableScroll');\n            // scrollDiv._overlay = scrollDiv.getElementsByTagName( 'lyte-overlaydiv' )[ 0 ];\n            this.scrollDiv = scrollDiv;\n            scrollDiv.comp = this;\n            scrollDiv._infiniteScroll = ltPropInfiniteScroll;\n            if ( !__data.ltPropPreventScrollbar && $L.prototype.scroll ) {\n                $L(scrollDiv).scroll( __data.ltPropScrollbarOption);\n                var scrollbar = $node.querySelector('.lyteScrollContainer.lyteScrollContainerY');\n                var header = $node.getElementsByTagName( __tags.th )[ 0 ], hgt;\n                $L.fastdom.measure(function () {\n                    var fg = this._dir;\n                    // while applying scroll plugin vertical scrollbar needs some offset for enabling the virtual of only body part is scrolling. If it is zero we have to set height of the header as offset\n                    if (header && scrollbar && scrollbar.offsetTop == 0) {\n                        hgt = header.getBoundingClientRect().height;\n                        $L.fastdom.mutate(function () {\n                            scrollbar.style.top = hgt + 'px';\n                            if (fg) {\n                                $node.classList.add('lyteRTL')\n                            }\n                        }.bind(this))\n                    }\n                    $L.fastdom.mutate(function () {\n                        __data.ltPropDualResize && $node.classList.add('lyteDualResize')\n                        if (this.getMethods('afterRender')) {\n                            this.executeMethod('afterRender', this.$node);\n                        }\n                    }.bind(this))\n                }.bind(this))\n            } else {\n                if (this.getMethods('afterRender')) {\n                    /**\n                     * @method afterRender\n                     * @version 1.0.1\n                     */\n                    this.executeMethod('afterRender', this.$node);\n                }\n            }\n        } catch (err) {\n        }\n        if (ltPropInfiniteScroll) {\n            $node.classList.add('infinitescroll')\n            /**\n             * @utility setValue\n             * @version 1.0.2\n             */\n            $node.setValue = function (ret) {\n                if (this._stopScroll) {\n                    this.appendAddData1.call(this, ret)\n                }\n            }.bind(this)\n\n            /**\n             * @utility removeRow\n             * @version 2.2.17\n             */\n\n            $node.removeRow = function (row) {\n                this.removeRow(row);\n            }.bind(this);\n\n            /**\n             * @utility scrollToRecord\n             * @version 2.2.19\n             */\n\n            $node.scrollToRecord = this.scrollToRecord.bind(this);\n\n            /**\n             * @utility insertRow\n             * @version 2.2.19\n             */\n\n            $node.insertRow = this.insertRow.bind(this);\n        }\n\n        if( __data.ltPropNavigation ){\n            window._lyteUiUtils.tableNavigation( $node.getElementsByTagName( __tags.table )[ 0 ] );\n        }\n    }\n\n    // width calculation for positioning\n    columnWidth(fixedColumn, i, j) {\n\n        var width = 0;\n        j = j || 0;\n\n        for( ; j < i; j++ ){\n            width += fixedColumn[ j ].property.width;\n        }\n\n        return width;\n    }\n\n    heightCalc(rows, upper, hgtLimit) {\n        var hgt = 0, j = upper;\n        for( ; j > 0; j-- ){\n            hgt += rows[ j ];\n            if( hgtLimit < hgt ){\n                break;\n            }\n        }\n        return [ hgt, j ];\n    }\n\n    topElem(elem) {\n        var __final;\n\n        if( this.isIE11Lyte || this.isEdgeLyte ){\n            __final = elem.getElementsByTagName( this.data.ltPropTags.td )[ 0 ];\n        } else {\n            __final = elem;\n        }\n        return __final ? __final.getBoundingClientRect() : {};\n    }\n\n    cellSet(elem, value) {\n        var __elem;\n        if( this.isIE11Lyte || this.isEdgeLyte ){\n            __elem = Array.from( elem.getElementsByTagName( this.data.ltPropTags.td ) );\n        } else {\n           __elem = [ elem ];\n        }\n\n        if( value ){\n            __elem.forEach( function( item ){\n                item.style.transform = value;\n            });\n        }\n        return __elem[ 0 ].style.transform;\n    }\n\n    scrollTable(event, obj) {\n        // fastdom has been removed here due to delay causes error in calculation of data in ie edge safari\n        var b = event.yScroll, \n        __tags = this.data.ltPropTags,\n        ltPropData = this.getData('ltPropData'), \n        ltPropContent = this.getData('ltPropContent'), \n        scrollDiv = this.scrollDiv, \n        divClientRect = obj.tbodyClient, \n        tableClient = obj.$nodeClient, \n        table = this.$node.querySelector( __tags.table ),\n        head = this.$node.getElementsByTagName( __tags.th )[ 0 ], \n        neglected = obj.neglected, \n        compNeg = obj.compNeg;\n        head = head ? (head.property ? head.property.height : head.getBoundingClientRect().height) : 0;\n        var topElem = obj.topElem, \n        top1 = obj.topElemClient;\n\n        if (table.style.height.indexOf('px') == -1) {\n            table.style.height = divClientRect.height + 'px';\n            this._rowHgt = parseInt(top1.height * 10) / 10;\n            this._step = parseInt((divClientRect.height - this._rowHgt * neglected.length) * 10) / 10;\n        }\n        if( !this._dummy ){\n            this.createDummy( obj.tbody );\n        }\n        if (b == undefined && !scrollDiv.classList.contains('eventBinded')) {\n            var prevScroll = parseFloat(this._dummy.style.transform.match(/[\\d|.]+/ig)[0]),\n                currScroll = scrollDiv.scrollTop\n            if (currScroll > prevScroll) {\n                b = 1\n            } else {\n                b = -1\n            }\n        }\n\n        var __boundary = this._boundary,\n        __dummy = this._dummy.style,\n        __dummy1 = ( this._dummy1 || {} ).style,\n        __rowHgt = this._rowHgt;\n\n        if (b > 0) {\n            if (parseFloat(tableClient.top + head) >= parseFloat(top1.bottom)) {\n                if( __boundary.bottom <= ltPropContent.length - 2 ) {\n                    var diff = Math.max(parseInt((tableClient.top + head - top1.bottom) / __rowHgt ), 1);\n                    if( __boundary.bottom + diff > ltPropContent.length - 1) {\n                        diff = ltPropContent.length - 1 - __boundary.bottom\n                    }\n                    for (var i = 0; i < diff; i++) {\n                        __boundary.bottom += 1;\n                        if (i >= diff - ltPropData.length) {\n                            set(ltPropData[this._top], { body: ltPropContent[__boundary.bottom], index: __boundary.bottom })\n                            topElem.dataOrder = __boundary.bottom;\n                        }\n                        __boundary.top = __boundary.bottom - ltPropData.length + 1;\n                        if (this.cellSet(topElem)) {\n                            this.regex(topElem)\n                        } else {\n                            this.cellSet(topElem, \"translateY(\" + (this._step) + 'px)')\n                        }\n                        __dummy.transform = 'translateY(' + (parseFloat( __dummy.transform.match(/[\\d|.]+/ig)[0]) + __rowHgt ) + 'px)'\n                        __dummy.height = Math.max(parseFloat( __dummy.height) - __rowHgt, 0) + 'px';\n                        if (this._browser) {\n                            __dummy1.transform = 'translateY(' + (parseFloat( __dummy1.transform.match(/[\\d|.]+/ig)[0]) + __rowHgt ) + 'px)'\n                        }\n                        this._bottom = this._top;\n                        this._top = (this._top + 1) % ltPropData.length;\n                        if ( __boundary.bottom >= ltPropContent.length) {\n                            __boundary.bottom = ltPropContent.length - 1;\n                            this._top = (this._top + 1) % ltPropData.length;\n                            break\n                        }\n                        topElem = this.nthoftype.call(this, obj.tbody, this._top + compNeg.length, true)\n                    }\n                } else {\n                    this.scrollEndMethod1();\n                }\n            }\n\n        } else if (b < 0) {\n            var bottmElem = obj.bottmElem, bottom = obj.bottmElemClient;\n            if (tableClient.bottom <= bottom.top) {\n                var mat = this.cellSet(bottmElem).match(/[\\d|.]+/ig);\n                if (!mat || (mat && mat[0] == '0')) {\n                    return\n                }\n                var diff = parseInt(Math.max(parseFloat((bottom.top - tableClient.bottom) / __rowHgt ), 0)),\n                    minDiff = Math.max(diff - 1 - this._boundary.top, 0)\n                for (var i = diff - 1; i >= 0 && diff != 0; i--) {\n                    if ( __boundary.top == 0) {\n                        break;\n                    }\n                    __boundary.top -= 1;\n                    if (i <= ltPropData.length - 1 + minDiff) {\n                        set(ltPropData[this._bottom], { body: ltPropContent[ __boundary.top], index: __boundary.top })\n                        bottmElem.dataOrder = __boundary.top;\n                    }\n                    __boundary.bottom = __boundary.top + ltPropData.length - 1;\n                    if (this.cellSet(bottmElem)) {\n                        this.regex(bottmElem, true)\n                    }\n                    __dummy.height = (parseFloat( __dummy.height) + __rowHgt ) + 'px';\n                    __dummy.transform = 'translateY(' + (parseFloat( __dummy.transform.match(/[\\d|.]+/ig)[0]) - __rowHgt ) + 'px)'\n                    if (this._browser) {\n                        __dummy1.transform = 'translateY(' + (parseFloat( __dummy1.transform.match(/[\\d|.]+/ig)[0]) - __rowHgt ) + 'px)'\n                    }\n                    this._top = this._bottom;\n                    this._bottom = (ltPropData.length + this._bottom - 1) % ltPropData.length;\n                    if (__boundary.top == -1) {\n                        __boundary.top = 0;\n                        __boundary.bottom = __boundary.top + ltPropData.length - 1;\n                        break\n                    }\n                    bottmElem = this.nthoftype.call(this, obj.tbody, this._bottom + compNeg.length, true)\n                }\n            }\n        }\n    }\n\n    createDummy(tbody) {\n        var dummy = document.createElement( this.data.ltPropTags.tr );\n        dummy.classList.add('dummy');\n        tbody.appendChild(dummy)\n        dummy.setAttribute('style', 'transform:translateY(0px);height:0px')\n        this._dummy = dummy;\n        if (this._browser) {\n            var dummy1 = document.createElement('div');\n            dummy1.classList.add('dummy');\n            this.scrollDiv.appendChild(dummy1)\n            dummy1.setAttribute('style', 'transform:translateY(0px);height:5px')\n            this._dummy1 = dummy1;\n        }\n    }\n\n    regex(elem, flag) {\n        if( this.isIE11Lyte || this.isEdgeLyte ){\n            var cells = elem.getElementsByTagName( this.data.ltPropTags.td ),\n            __length = cells.length;\n\n            for( var i = 0; i < __length; i++ ){\n                this.regex1( cells[ i ], flag );\n            }\n        } else {\n            this.regex1( elem, flag );\n        }\n    }\n\n    regex1(elem, flag) {\n        var __style = elem.style,\n        __transform = __style.transform,\n        rgx = /[\\d|.]+/ig,\n        __step = this._step;\n\n        if( flag ) {\n            __style.transform = __transform.replace( rgx, function( arg ) { return Math.max( parseFloat( arg ) - __step, 0 ).toFixed( 3 ) });\n        } else {\n            __style.transform = __transform.replace( rgx, function( arg ) { return ( parseFloat( arg ) + __step ).toFixed( 3 ) });\n        }\n    }\n\n    scrollEndMethod1() {\n        if( this._stopScroll ) {\n            return\n        }\n        this._stopScroll = true;\n        if (this.getMethods('scrollEnd')) {\n            /**\n             * @method scrollEnd\n             * @version 1.0.0\n             */\n            this.appendAddData1(this.executeMethod('scrollEnd'))\n        }\n    }\n\n    appendAddData1(ret) {\n        if (ret) {\n            if (ret.then) {\n                Promise.resolve(ret).then(function (arg) {\n                    if (arg) {\n                        this.apd1.call(this, arg);\n                    }\n                }.bind(this), function () {\n                    console.log( 'error at scroll end promise' );\n                }.bind(this));\n            } else {\n                this.apd1.call(this, ret)\n            }\n        }\n    }\n\n    apd1(ret) {\n        var __data = this.data,\n        ltPropContent = __data.ltPropContent, \n        ltPropData = __data.ltPropData,\n        La = this.$addon.arrayUtils;\n\n        this._prevent = true\n        if( ret.constructor == Array ){\n            La( ltPropContent, 'concat', ret );\n        } else if( ret.constructor == Object ) {\n            La( ltPropContent, 'push', ret );\n        }\n        delete this._prevent;\n        delete this._stopScroll;\n    }\n\n    nthoftype(tbody, index, fg) {\n        var arr = [],\n        rows = tbody.getElementsByTagName( this.data.ltPropTags.tr );\n\n        if( fg ){\n            return rows[ index ];\n        }\n\n        var __length = rows.length;\n\n        for( var i = 0; i < __length; i++ ) {\n            var __cur = rows[ i ];\n            if( !__cur.classList.contains('dummy')) {\n                arr.push( this.get_children( __cur )[ index ] );\n            }\n        }\n        return arr;\n    }\n\n    scroll(event) {\n\n        // cant use fastdom because of jerk in ie edge safari browser\n        var component = this.comp,\n            // headerList =component.$node.querySelectorAll( 'lyte-th' ),\n            // scrollleft and top are required for process like fixing columns and infinite scroll. If scroll is dispatched by plugin event object contains these properties or it is calculated\n        obj = this._wheelObj || { bcr: {} };\n\n        if( component.__ignore_scroll && component.__allow_scroll !== true ){\n            return;\n        }\n\n        this._scrollLeft = obj.scrollLeft != undefined ? obj.scrollLeft : this.scrollLeft;\n        this._scrollTop = obj.scrollTop != undefined ? obj.scrollTop : this.scrollTop;\n        \n        var direction = this._direction,\n        __is_not_sticky = !component.data.ltPropStickyTable;\n\n        __is_not_sticky && component.scrollCheck.call(this, event, obj);\n\n        if (this._scrollLeft == 0 && direction != 'rtl' && component.getData('ltPropInfiniteScroll')) {\n            var ary = component.getData('columns');\n            component.$addon.arrayUtils(ary, 'remove', 0, ary.length);\n            \n            if( __is_not_sticky ){\n                var fixedd = this.getElementsByClassName( 'lyteTableFixed' ),\n                __length = fixedd.length;\n\n                for( var i = 0; i < __length; i++ ) {\n                    var __cur = fixedd[ i ];\n\n                    __cur.style.left = '0px';\n                    __cur.classList.remove('lyteTableFixed');\n                }\n            }\n        }\n        if (component.data.ltPropInfiniteScroll) {\n            component.scrollTable.call(component, event, obj)\n        }\n        delete this._scrollLeft; delete this._scrollTop;\n    }\n\n    // fixed column checks and removals\n    scrollCheck(event, obj) {\n        var component = this.parentElement.component,\n        __tags = component.data.ltPropTags,\n        table = this.getElementsByTagName( __tags.table )[0], scrollDiv = this,\n            scrollTop = this._scrollTop, scrollLeft = this._scrollLeft,\n            scrollDir = component.getData('ltPropScroll'),\n            direction = this._direction,\n            tbody = table.getElementsByTagName( __tags.tbody )[0],\n            thead = this.getElementsByTagName( __tags.thead )[0],\n            ths = [],\n            headerList = [],\n            fixedColumn = [];\n\n        if (thead) {\n            ths = thead.getElementsByTagName( __tags.th );\n        }\n\n        if ((scrollTop != this.prevScollTop || event._byFunc) && scrollDir.vertical) {\n            var colsNos = ths;\n            if (colsNos.length) {\n                for (var i = 0; i < colsNos.length; i++) {\n                    colsNos[i].classList.add('tableRowFixed')\n                    // colsNos[i].style.top = (scrollTop) + 'px';\n                    component.transform(true, colsNos[i], scrollTop)\n                }\n                if (!scrollTop) {\n                    for (var i = 0; i < colsNos.length; i++) {\n                        colsNos[i].classList.remove('tableRowFixed');\n                    }\n                }\n            }\n        }\n        // for horizontal scroll    \n        if ((scrollLeft != this.prevScollLeft || event._byFunc) && scrollDir.horizontal) {\n            var columns = component.data.columns, head = [];\n            if (thead) {\n                var headRows = Array.apply(Array, thead.getElementsByTagName( __tags.tr )),\n                    headRowCopy = Array.apply(Array, thead.getElementsByClassName('lyteRowCopy'));\n                head = headRows.concat(headRowCopy);\n            }\n\n            var ltPropFixedColumnClass = component.data.ltPropFixedColumnClass || '';\n            if (head.length) {\n                headerList = head[0].getElementsByTagName( __tags.th );\n                for (var n = 0; n < headerList.length; n++) {\n                    headerList[n].classList.contains('lyteFixedColumn') && fixedColumn.push(headerList[n]);\n                }\n            }\n            // fastdom removed due to jerk in ie edge chrome browser\n            for (var i = columns.length; i < fixedColumn.length; i++) {\n                if (((fixedColumn[i].property.right + component.columnWidth.call(component, fixedColumn, i) > (obj.scrollDivClient.right)) && direction == 'rtl') || ((fixedColumn[i].property.left < (obj.scrollDivClient.left + component.columnWidth.call(component, fixedColumn, i))) && direction != 'rtl')) {\n                    var width = fixedColumn[i].property.width\n                    var order = fixedColumn[i].order\n                    if (order + 1 < headerList.length) {\n                        !fixedColumn[i].classList.contains('lyteTableFixed') && fixedColumn[i].classList.add('lyteTableFixed')\n                        columns.push(fixedColumn[i])\n                        for (var zz = 1; zz < head.length; zz++) {\n                            var colex = head[zz].getElementsByTagName( __tags.th )[order];\n                            colex && !colex.classList.contains('lyteTableFixed') && colex.classList.add('lyteTableFixed')\n                        }\n                        var colls = /*component.isIE11Lyte ? */component.nthoftype.call(component, tbody, order) /*: this.querySelectorAll( 'lyte-tbody lyte-td:nth-of-type(' + (order + 1) + ')' )*/\n                        for (var k = 0; k < colls.length; k++) {\n                            !colls[k].classList.contains('lyteTableFixed') && colls[k].classList.add('lyteTableFixed')\n                            if (ltPropFixedColumnClass) {\n                                colls[k].classList.add(ltPropFixedColumnClass)\n                            }\n                        }\n                    }\n                }\n            }\n            for (var n = columns.length - 1; n >= 0; n--) {\n                var j = columns.length - 1;\n                if ((scrollLeft == 0 && !(window.chrome && direction == 'rtl')) || ((((parseFloat((headerList[columns[j].order + 1].property.right + columns[j].property.width + component.columnWidth.call(component, columns, columns.length - 1)).toFixed(2)) <= parseFloat(obj.scrollDivClient.right.toFixed(2))) || (headerList[columns[j].order + 1].property.right + 2 < columns[j].property.left)) && direction == 'rtl') || ((headerList[columns[j].order + 1].property.left >= (obj.scrollDivClient.left + columns[j].property.width + component.columnWidth.call(component, columns, columns.length - 1))) && (columns[j].property.left >= (obj.scrollDivClient.left + component.columnWidth.call(component, fixedColumn, columns.length - 1))) && direction != 'rtl'))) {\n                    // var innerElem = headerList[columns[j].order].querySelector( 'lyte-th-data' );\n                    headerList[columns[j].order].classList.contains('lyteTableFixed') && headerList[columns[j].order].classList.remove('lyteTableFixed');\n                    if (ltPropFixedColumnClass) {\n                        headerList[columns[j].order].classList.remove(ltPropFixedColumnClass)\n                    }\n                    // columns[j].style.removeProperty('left');\n                    component.transform(false, columns[j], 0)\n                    for (var zz = 0; zz < head.length; zz++) {\n                        var colex = head[zz].getElementsByTagName( __tags.th )[columns[j].order];\n                        if (colex) {\n                            colex.classList.contains('lyteTableFixed') && colex.classList.remove('lyteTableFixed');\n                            // colex.style.removeProperty('left');\n                            component.transform(false, colex, 0)\n\n                        }\n                    }\n                    var currCols = /*component.isIE11Lyte ?*/ component.nthoftype.call(component, tbody, columns[j].order) /*: this.querySelectorAll( 'lyte-tbody lyte-td:nth-of-type(' + (columns[j].order + 1) + ')' )*/;\n                    for (var z = 0; z < currCols.length; z++) {\n                        // currCols[z].style.removeProperty('left');\n                        component.transform(false, currCols[z], 0)\n                        currCols[z].classList.contains('lyteTableFixed') && currCols[z].classList.remove('lyteTableFixed')\n                        if (ltPropFixedColumnClass) {\n                            currCols[z].classList.remove(ltPropFixedColumnClass)\n                        }\n                    }\n                    component.$addon.arrayUtils(columns, 'removeAt', j)\n                }\n                else {\n                    break;\n                }\n            }\n            for (var j = 0; j < columns.length; j++) {\n                //positioning on scroll\n                var left, cells = /*component.isIE11Lyte ? */component.nthoftype.call(component, tbody, columns[j].order) /*: this.querySelectorAll( 'lyte-tbody lyte-td:nth-of-type(' + (columns[j].order + 1) + ')' )*/,\n                    uA = window.navigator.userAgent.toLowerCase();\n                if (j == 0) {\n                    if (direction == 'rtl') {\n                        if (uA.indexOf('firefox') != -1 || (uA.indexOf('safari') != -1 && (window._lyteUiUtils.isNegativeScroll() || (!(uA.indexOf('chrome') != -1) && !(uA.indexOf('chromium') != -1))))) {\n                            left = scrollLeft + (component.columnWidth.call(component, headerList, columns[j].order, 0))\n                        }\n                        else if (uA.indexOf('edge') != -1 || uA.indexOf('trident') != -1 || uA.indexOf('msie') != -1) {\n                            left = -scrollLeft + (component.columnWidth.call(component, headerList, columns[j].order, 0))\n                        }\n                        else {\n                            left = scrollLeft - 1 - (obj.scrollWidth) + obj.scrollDivClient.width + (component.columnWidth.call(component, headerList, columns[j].order, 0))\n                        }\n                    }\n                    else {\n                        left = scrollLeft - (component.columnWidth.call(component, headerList, columns[j].order, 0))\n                    }\n                }\n                else {\n                    if (direction == 'rtl') {\n                        if (uA.indexOf('firefox') != -1 || (uA.indexOf('safari') != -1 && (window._lyteUiUtils.isNegativeScroll() || (!(uA.indexOf('chrome') != -1) && !(uA.indexOf('chromium') != -1))))) {\n                            left = /*parseInt(columns[j - 1].style.left)*/ component.transform(!1, columns[j - 1]) + component.columnWidth.call(component, headerList, columns[j].order, columns[j - 1].order + 1)\n                        }\n                        else {\n                            left = /*parseInt(columns[j - 1].style.left)*/ component.transform(!1, columns[j - 1]) + component.columnWidth.call(component, headerList, columns[j].order, columns[j - 1].order + 1);\n                        }\n                    }\n                    else {\n                        left = component.transform(!1, columns[j - 1]) /*parseInt(columns[j - 1].style.left)*/ - component.columnWidth.call(component, headerList, columns[j].order, columns[j - 1].order + 1)\n                    }\n                }\n                for (var x = 0; x < cells.length; x++) {\n                    !cells[x].classList.contains('lyteTableFixed') && cells[x].classList.add('lyteTableFixed');\n                    //cells[x].style.left = left + 'px';\n                    component.transform(false, cells[x], left)\n                }\n                // columns[j].style.left = left + 'px';\n                component.transform(false, columns[j], left)\n                for (var zz = 0; zz < head.length; zz++) {\n                    var colex = head[zz].getElementsByTagName( __tags.th )[columns[j].order];\n                    if (colex) {\n                        !colex.classList.contains('lyteTableFixed') && colex.classList.add('lyteTableFixed');\n                        // colex.style.left = left + 'px';\n                        component.transform(false, colex, left)\n                    }\n                }\n            }\n        }\n        this.prevScollLeft = scrollLeft;\n        this.prevScollTop = scrollTop;\n    }\n\n    transform(flag, elem, value) {\n        var transform = (elem.style.transform || 'translateX(0px) translateY(0px)'),\n            transX = parseFloat(/translateX\\((.+)/.exec(transform)[1]),\n            transY = parseFloat(/translateY\\((.+)/.exec(transform)[1]);\n\n        if (value != undefined) {\n            if (!flag) {\n                elem.style.transform = \"translateY(\" + transY + 'px) ' + 'translateX(' + value + 'px)';\n            } else {\n                elem.style.transform = \"translateY(\" + value + 'px) ' + 'translateX(' + transX + 'px)';\n            }\n        } else {\n            return parseFloat(flag ? transY : transX);\n        }\n    }\n\n    borderChange() {\n        if (this.data.ltPropBorder) {\n            this.$node.classList.add('border');\n        }\n        else {\n            this.$node.classList.remove('border');\n        }\n    }\n\n    widthObs() {\n        this.$node.querySelector( this.data.ltPropTags.table ).style.width = this.data.ltPropWidth;\n    }\n\n    heightObs() {\n        this.$node.querySelector( this.data.ltPropTags.table ).style.height = this.data.ltPropHeight;\n    }\n\n    sortable() {\n        var row = this.$node.getElementsByTagName( this.data.ltPropTags.thead )[ 0 ];\n        if( row ){\n            var ns = \"remove\";\n\n            if( this.data.ltPropColumnSortable ){\n                this.colSort = this.sortableColumns.bind( this );\n                ns = \"add\";\n            }\n\n            if( ns ){\n                var rel = ns + \"EventListener\",\n                fn = this.colSort;\n\n                row[ rel ]( \"mousedown\", fn );\n                row[ rel ]( \"touchstart\", fn );\n                row.parentNode.classList[ ns ]( 'sortableTable' );\n            }\n        }\n    }\n\n    composePath(event) {\n        var arr = [], \n        __target = event.target,\n        node = __target.correspondingElement || __target;\n        while( node && node.tagName != 'HTML' ){\n            arr.push( node );\n            node = node.parentNode;\n        }\n        return arr;\n    }\n\n    sortableColumns(event) {\n        var __tags = this.data.ltPropTags,\n        target = this.closestFind.call(this, event.path ? event.path : this.composePath.call(this, event), __tags.th + ':not(.lyteTableFixed)');\n        if (target && this.$node.contains(target)) {\n            var ret, isTch = event.type == \"touchstart\";\n            if (this.getMethods('onBeforeSelect')) {\n                /**\n                 * @method onBeforeSelect\n                 * @version 1.0.3\n                 */\n                ret = this.executeMethod('onBeforeSelect', target, event, this.$node)\n            }\n            if (ret != false) {\n                var evt = isTch ? event.touches[0] : event\n                this._ww = window.innerWidth;\n                this.mousemove = this.sortableMouseMove.bind(this);\n                this.offLeft = this.rtlfunc.call(this, 'clientX', evt, this._ww) - this.rtlfunc.call(this, 'left', target.getBoundingClientRect(), this._ww);\n                this.colHead = target;\n                this._thisBccr = this.$node.getBoundingClientRect()\n                target.classList.add('lyteStickyTableColumnSortSelect')\n                document.documentElement.addEventListener(isTch ? \"touchmove\" : 'mousemove', this.mousemove);\n                this.mouseup = this.sortableMouseup.bind(this);\n                document.documentElement.addEventListener(isTch ? \"touchend\" : 'mouseup', this.mouseup);\n                this.flag = true;\n                event.preventDefault();\n                if (this.getMethods('onSelect')) {\n                    /**\n                     * @method onSelect\n                     * @version 1.0.3\n                     */\n                    this.executeMethod('onSelect', target, event, this.$node)\n                }\n            }\n        }\n    }\n\n    horiScroll(dummyDiv, ww) {\n        var lt = this.rtlfunc.call(this, 'left'), IE = this.isIE11Lyte || this.isEdgeLyte,\n            isEvt, check1, check2;\n        if (/mousemove|touchmove/i.test(dummyDiv.type)) {\n            isEvt = true;\n        }\n        if (isEvt) {\n            if (this._reqId) {\n                return;\n            }\n\n            var __bcr = this.__bcr;\n\n            check1 = this.rtlfunc( 'clientX', dummyDiv, ww ) > Math.min( this.rtlfunc( 'right', __bcr, ww), ww - 2 );\n            check2 = this.rtlfunc( 'clientX', dummyDiv, ww ) <= Math.max( 0, this.rtlfunc('left', __bcr, window.innerWidth ) );\n        } else {\n            check1 = (parseFloat(dummyDiv.style[lt]) - this._xxoff + parseFloat(dummyDiv.style.width)) >= this.rtlfunc('right', this._thisBccr, ww) - 1;\n            check2 = (parseFloat(dummyDiv.style[lt]) - this._xxoff + parseFloat(dummyDiv.style.width)) >= this.rtlfunc('right', this._thisBccr, ww) - 1;\n        }\n\n        if (check1) {\n            this.scrollDiv.scrollLeft += 2 * (this._dir ? (-1 * (IE ? -1 : 1)) : 1)\n            if (isEvt) {\n                var __value = 2 * ( this._dir ? -1 : 1 );\n                this.__clientX -= __value;\n\n                if( this.data.ltPropFixResizeCursor ){\n                    this.__trans_value += __value\n                }\n            }\n            this._reqId = window.requestAnimationFrame(function () {\n                delete this._reqId;\n                this.horiScroll(dummyDiv, ww)\n            }.bind(this))\n        } else if (check2) {\n            if (isEvt) {\n                var __value =  2 * ( this._dir ? -1 : 1 );\n                this.__clientX += __value;\n                \n                if( this.data.ltPropFixResizeCursor ){\n                    this.__trans_value -= __value\n                }\n            }\n            this.scrollDiv.scrollLeft -= 2 * (this._dir ? (-1 * (IE ? -1 : 1)) : 1)\n            this._reqId = window.requestAnimationFrame(function () {\n                delete this._reqId;\n                this.horiScroll(dummyDiv, ww);\n            }.bind(this))\n        } else {\n            window.cancelAnimationFrame(this._reqId);\n            delete this._prevent;\n        }\n    }\n\n    sortableMouseMove(event) {\n        var isTch = event.type == \"touchmove\", evt = event;\n        if (isTch && evt.touches.length != 1) {\n            return\n        } else if (isTch) {\n            evt = evt.touches[0]\n        }\n        if (this.flag && this._timeout == undefined) {\n            var target = this.colHead, xscroll;\n            var clientRect = target.getBoundingClientRect();\n            var div = document.createElement('div');\n            div.classList.add('lyteTableSortHelper');\n            div.innerText = this.colHead.innerText;\n            this._xxoff = xscroll = (window.pageXOffset || document.documentElement.scrollLeft) * (this._dir ? -1 : 1);\n            var yscroll = window.pageYOffset || document.documentElement.scrollTop\n            div.style.height = clientRect.height + 'px';\n            div.style.width = clientRect.width + 'px';\n            div.style[this.rtlfunc.call(this, 'left')] = (xscroll + this.rtlfunc.call(this, 'left', clientRect, this._ww)) + 'px';\n            div.style.top = (yscroll + clientRect.top) + 'px';\n            this._timeout = setTimeout(function () {\n                window._lyteUiUtils.appendChild( document.body, div );\n                this.flag = false;\n            }.bind(this), 100)\n        }\n        var dummyDiv = document.querySelector('div.lyteTableSortHelper')\n        if (dummyDiv) {\n            var lft = this._dir ? \"right\" : \"left\", ww = window.innerWidth;\n            var newLeft = Math.max(Math.min((this.rtlfunc.call(this, 'clientX', evt, this._ww) - this.offLeft), this.rtlfunc.call(this, 'right', this._thisBccr, this._ww) - parseFloat(dummyDiv.style.width)), this.rtlfunc.call(this, 'left', this._thisBccr, this._ww));\n            // if( ( newLeft > parseFloat( dummyDiv.style[ lft ] - this._xxoff ) ) || ( newLeft < parseFloat( dummyDiv.style[ lft ] ) - this._xxoff ) ){\n            if ((parseFloat(newLeft) > this.rtlfunc('left', this._thisBccr, ww)) && ((parseFloat(newLeft) + parseFloat(dummyDiv.style.width)) < this.rtlfunc('right', this._thisBccr, ww))) {\n                window.cancelAnimationFrame(this._reqId);\n                delete this._prevent; delete this._scrollDir\n            }\n            if (this._prevent) {\n                return\n            }\n            dummyDiv.style[lft] = (newLeft + this._xxoff) + 'px';\n            this._prevent = true\n            this.horiScroll(dummyDiv, ww)\n            if (this.getMethods('onDrag')) {\n                /**\n                 * @method onDrag\n                 * @version 1.0.3\n                 */\n                this.executeMethod('onDrag', this.colHead, dummyDiv, event, this.$node)\n            }\n        }\n        event.preventDefault();\n        event.stopPropagation();\n    }\n\n    sortableMouseup(event) {\n        if (!this.flag) {\n            var __tags = this.data.ltPropTags,\n            isTch = event.type == \"touchend\", dummyDiv = document.getElementsByClassName('lyteTableSortHelper')[0], clientRect = dummyDiv.getBoundingClientRect(), x = clientRect.left + clientRect.width / 2 + 2, y = clientRect.top + clientRect.height / 2,\n                adjCol = this.closestFind.call(this, document.elementsFromPoint ? document.elementsFromPoint(x, y) : this.elementsFromPointCal.call(this, x, y), __tags.th + ':not(.lyteTableFixed)'),\n                tbody = this.$node.getElementsByTagName( __tags.tbody )[0];\n            if (adjCol != this.colHead && adjCol) {\n                var Heads = this.colHead.parentElement.getElementsByTagName( __tags.th ),\n                    colOrder = Array.prototype.indexOf.call(Heads, this.colHead),\n                    adjOrder = Array.prototype.indexOf.call(Heads, adjCol),\n                    ltPropHeader = this.data.ltPropHeader, ret;\n                if (this.getMethods('onBeforeDrop')) {\n                    /**\n                     * @method onBeforeDrop\n                     * @version 1.0.3\n                     */\n                    ret = this.executeMethod('onBeforeDrop', this.colHead, adjCol, colOrder, adjOrder, ltPropHeader, event, this.$node)\n                }\n                if (ret != false) {\n                    if (!ltPropHeader.length) {\n                        window._lyteUiUtils.insertBefore(adjOrder > colOrder ? adjCol.nextElementSibling : adjCol, this.colHead);\n                        var colGrp = /*this.isIE11Lyte ? */this.nthoftype.call(this, tbody, colOrder) /*: this.$node.querySelectorAll( 'lyte-tbody lyte-td:nth-of-type(' + ( colOrder + 1) +')' )*/;\n                        var AdjColGrp = /*this.isIE11Lyte ?*/ this.nthoftype.call(this, tbody, adjOrder) /*: this.$node.querySelectorAll( 'lyte-tbody lyte-td:nth-of-type(' + ( adjOrder + 1) +')' )*/;\n                        for (var i = 0; i < colGrp.length; i++) {\n                            window._lyteUiUtils.insertBefore(adjOrder > colOrder ? AdjColGrp[i].nextElementSibling : AdjColGrp[i], colGrp[i]);\n                        }\n                    }\n                    else {\n                        var flag = adjOrder > colOrder ? true : false;\n                        var temp = this.$addon.arrayUtils(ltPropHeader, 'removeAt', colOrder), newOrder = Array.prototype.indexOf.call(adjCol.parentElement.getElementsByTagName( __tags.th ), adjCol);\n                        this.$addon.arrayUtils(ltPropHeader, 'insertAt', colOrder < adjOrder ? (newOrder + 1) : newOrder, temp);\n                        var newCol = adjCol.parentElement.getElementsByTagName( __tags.th, adjCol.parentElement)[colOrder < adjOrder ? (newOrder + 1) : newOrder];\n                        if (adjCol.classList.contains('tableRowFixed')) {\n                            newCol.classList.add('tableRowFixed');\n                            newCol.style.top = adjCol.style.top;\n                        }\n                    }\n                    if (this.getMethods('onDrop')) {\n                        /**\n                         * @method onDrop\n                         * @version 1.0.3\n                         */\n                        this.executeMethod('onDrop', this.colHead, adjCol, colOrder, adjOrder, ltPropHeader, event, this.$node)\n                    }\n                }\n            } else {\n                this.getMethods( 'onRelease' ) && this.executeMethod( 'onRelease', this.colHead, event, this.$node );\n            }\n            document.body.removeChild(dummyDiv);\n        } else {\n            clearTimeout(this._timeout)\n        }\n        document.documentElement.removeEventListener(isTch ? \"touchend\" : 'mouseup', this.mouseup);\n        document.documentElement.removeEventListener(isTch ? \"touchmove\" : 'mousemove', this.mousemove);\n        this.colHead.classList.remove('lyteStickyTableColumnSortSelect')\n        window.cancelAnimationFrame(this._reqId)\n        delete this.mouseup; delete this._xxoff;\n        delete this.mousemove;\n        delete this.offLeft;\n        delete this.colHead;\n        delete this.flag;\n        delete this._timeout;\n        delete this._thisBccr; delete this._ww;\n        delete this._reqId; delete this._prevent; delete this._scrollDir\n        event.preventDefault();\n        event.stopPropagation();\n        event.stopImmediatePropagation();\n    }\n\n    elementsFromPointCal(x, y) {\n        var arr = [], element = document.elementFromPoint(x, y);\n        while (element != document && element != document.documentElement && element != document.body && element != this.$node) {\n            element.style.pointerEvents = 'none';\n            arr.push(element);\n            element = document.elementFromPoint(x, y);\n        }\n        for (var i = 0; i < arr.length; i++) {\n            arr[i].style.pointerEvents = 'initial';\n        }\n        return arr;\n    }\n\n    // resizeComponentAppendObs: function () {\n    //     if (this.data.ltPropYield) {\n    //         this.resizeComponentAppend.call(this);\n    //     }\n    // }.observes('ltPropResize', 'ltPropResize.{}'),\n\n    // resizeComponentAppend: function () {\n    //     var ltPropResize = this.data.ltPropResize, scrdiv = this.$node.getElementsByTagName('lyte-table-structure')[0],\n    //         tRz = scrdiv.getElementsByTagName('lyte-table-resize')[0], vrz = scrdiv.getElementsByTagName('lyte-table-vertical-resize')[0],\n    //         hrz = scrdiv.getElementsByTagName('lyte-table-horizontal-resize')[0];\n    //     if (ltPropResize.vertical || ltPropResize.horizontal) {\n    //         if (!tRz) {\n    //             var comp = document.createElement('lyte-table-resize')\n    //             scrdiv.appendChild(comp)\n    //             comp.addEventListener('mousedown', this.actions.tableResize.bind(this));\n    //             comp.addEventListener('touchstart', this.actions.tableResize.bind(this));\n    //         }\n    //     } else if (tRz) {\n    //         scrdiv.removeChild(tRz)\n    //     }\n    //     if (ltPropResize.vertical) {\n    //         if (!vrz) {\n    //             var comp = document.createElement('lyte-table-vertical-resize')\n    //             scrdiv.appendChild(comp)\n    //             comp.addEventListener('mousedown', this.actions.tableResize.bind(this))\n    //             comp.addEventListener('touchstart', this.actions.tableResize.bind(this));\n    //         }\n    //     }\n    //     else if (vrz) {\n    //         scrdiv.removeChild(vrz)\n    //     }\n    //     if (ltPropResize.horizontal) {\n    //         if (!hrz) {\n    //             var comp = document.createElement('lyte-table-horizontal-resize')\n    //             scrdiv.appendChild(comp)\n    //             comp.addEventListener('mousedown', this.actions.tableResize.bind(this))\n    //             comp.addEventListener('touchstart', this.actions.tableResize.bind(this));\n    //         }\n    //     }\n    //     else if (hrz) {\n    //         scrdiv.removeChild(hrz)\n    //     }\n    // },\n\n    data() {\n        \n        var default_values = window._lyteUiUtils.getDefault( 'lyte-table' );\n\n        return {\n            //user data\n            /**\n             * @componentProperty {object[]} ltPropContent\n             * @version 1.0.0\n             * @default []\n             */\n            ltPropContent: prop(\"array\", { \"default\": [] }),\n            /**\n             * @componentProperty {object[]} ltPropHeader\n             * @version 1.0.0\n             * @default []\n             */\n            ltPropHeader: prop(\"array\", { \"default\": [] }),\n            /**\n             * @componentProperty {string} ltPropId=''\n             * @version 1.0.0\n             */\n            ltPropId: prop(\"string\", { \"default\": '' }),\n            /**\n             * @componentProperty {string} ltPropClass=''\n             * @version 1.0.0\n             */\n            ltPropClass: prop(\"string\", { \"default\": default_values.class || '' }),\n            /**\n             * @componentProperty {boolean} ltPropBorder=false\n             * @version 1.0.0\n             */\n            ltPropBorder: prop(\"boolean\", { \"default\": default_values.border || false }),\n            /**\n             * @componentProperty {string} ltPropHeaderLabelKey=''\n             * @version 1.0.0\n             */\n            ltPropHeaderLabelKey: prop(\"string\", { \"default\": '' }),\n            /**\n             * @componentProperty {string} ltPropBodyLabelKey=''\n             * @version 1.0.0\n             */\n            ltPropBodyLabelKey: prop(\"string\", { \"default\": '' }),\n            /**\n             * @componentProperty {string} ltPropWidth=100%\n             * @version 1.0.0\n             */\n            ltPropWidth: prop('string', { 'default': default_values.width || '100%' }),\n            /**\n             * @componentProperty {string} ltPropHeight=100%\n             * @version 1.0.0\n             */\n            ltPropHeight: prop('string', { 'default': default_values.height || '100%' }),\n            /**\n             * @typedef {object} tableResize\n             * @property {boolean} horizontal\n             * @property {boolean} vertical\n             */\n\n            /**\n             * @componentProperty {tableResize} ltPropResize\n             * @version 1.0.0\n             * @default {}\n             */\n            ltPropResize: prop('object', { 'default': default_values.resize || {} }),\n            /**\n             * @componentProperty {string} ltPropFixedColumnClass=''\n             * @version 1.0.0\n             */\n            ltPropFixedColumnClass: prop('string', { 'default': default_values.fixedColumnClass || '' }),\n            /**\n             * @componentProperty {boolean} ltPropYield=false\n             * @version 1.0.0\n             */\n            ltPropYield: prop('boolean', { 'default': default_values.yield || false }),\n            /**\n             * @typedef {object} tableScroll\n             * @property {boolean} horizontal=true\n             * @property {boolean} vertical=true\n             */\n            /**\n             * @componentProperty {tableScroll} ltPropScroll\n             * @default {\"horizontal\":true,\"vertical\":true}\n             */\n            ltPropScroll: prop('object', { 'default': default_values.scroll || { horizontal: true, vertical: true } }),\n            /**\n             * @componentProperty {boolean} ltPropColumnSortable=false\n             * @version 1.0.0\n             */\n            ltPropColumnSortable: prop('boolean', { 'default': default_values.columnSortable || false }),\n            /**\n             * @typedef {object} tableScrollbar\n             * @property {left | right} verticalPosition=left\n             * @property {top | bottom} horizontalPosition=bottom\n             * @property {string} containerClass\n             * @property {string} handlerClass\n             * @property {string} horizontalContainerClass\n             * @property {string} horizontalHandlerClass\n             * @property {string} verticalContainerClass\n             * @property {string} verticalHandlerClass\n             * @property {boolean} preventVertical\n             * @property {boolean} preventHorizontal\n             * @property {number} keyStep=30\n             * @property {hover | always | scroll} showOn=scroll\n             * @property {number} wheelSpeed=1\n             * @property {boolean} preventOnEnd=true\n             * @property {object} offset={\"x\":0,\"y\":0}\n             * @property {boolean} nested\n             * @property {number} max=Infinity\n             * @property {number} min=-Infinity\n             */\n            /**\n             * @componentProperty {tableScrollbar} ltPropScrollbarOption\n             * @version 1.0.0\n             * @default {}\n             */\n            ltPropScrollbarOption: prop('object', { 'default': default_values.scrollbarOption || {} }),\n            /**\n             * @componentProperty {boolean} ltPropDualResize=false\n             * @version 1.0.5\n             */\n            ltPropDualResize: prop('boolean', { default: default_values.dualResize || false }),\n\n            // scroll table test data\n            /**\n             * @experimental ltPropData\n             */\n            ltPropData: prop(\"array\", { \"default\": [] }),\n            /**\n             * @componentProperty {boolean} ltPropInfiniteScroll=false\n             * @version 1.0.0\n             */\n            ltPropInfiniteScroll: prop('boolean', { 'default': default_values.infiniteScroll || false }),\n            /**\n             * @componentProperty {string} ltPropCellHeight=20px\n             * @version 1.0.2\n             */\n            ltPropCellHeight: prop('string', { default: default_values.cellHeight || '20px' }),\n            /**\n             * @componentProperty {number} ltPropContentLength\n             * @version 1.0.2\n             */\n            ltPropContentLength: prop('number', { default_values : default_values.contentLength || void 0 }),\n            /**\n             * @componentProperty {boolean} ltPropPreventScrollbar=false\n             * @version 1.0.0\n             */\n            ltPropPreventScrollbar: prop('boolean', { default: default_values.preventScrollbar || false }),\n\n            /**\n             * @componentProperty {string} ltPropRole=\"\"\n             * @version 3.45.0\n             */\n\n            ltPropRole : prop( 'string', { default : default_values.role || \"\" } ),\n\n            // sticky table props\n            /**\n             * @componentProperty {boolean} ltPropStickyTable=false\n             * @version 3.53.0\n             */\n            ltPropStickyTable : prop( 'boolean', { default : default_values.stickyTable || false } ),\n            /**\n             * @componentProperty {number} ltPropScrollStep=2\n             * @version 3.53.0\n             */\n            ltPropScrollStep : prop( 'number', { default : default_values.scrollStep || 2 } ),\n            /**\n             * @componentProperty {boolean} ltPropPreventTableModify=true\n             * @version 3.53.0\n             */\n            ltPropPreventTableModify : prop( 'boolean', { default : default_values.preventTableModify == false ? false : true } ),\n            /**\n             * @componentProperty {string} ltPropSortDummyColumClass=\"\"\n             * @version 3.53.0\n             */\n            ltPropSortDummyColumClass : prop( 'string', { default : default_values.sortDummyColumnClass || \"\" } ),\n\n            /**\n             * @componentProperty {boolean} ltPropNavigation=false\n             * @version 3.51.2\n             */\n            ltPropNavigation : prop( 'boolean', { default : default_values.navigation || false } ),\n\n            /**\n             * @componentProperty {boolean} ltPropReset=false\n             * @version 3.53.0\n             */\n\n            ltPropReset : prop( 'boolean', { default : false } ),\n            /**\n             * @typedef {object} tableTags\n             * @property {string} table=\"lyte-table-structure\"\n             * @property {string} thead=\"lyte-thead\"\n             * @property {string} tbody=\"lyte-tbody\"\n             * @property {string} tr=\"lyte-tr\"\n             * @property {string} td=\"lyte-td\"\n             * @property {string} th=\"lyte-th\"\n             */\n\n            /**\n             * @componentProperty {tableTags} ltPropTags\n             * @version 3.91.0 \n             */\n\n            ltPropTags : prop( 'object', { default : default_values.tags || { table : \"lyte-table-structure\", thead : \"lyte-thead\", tbody : \"lyte-tbody\", td : \"lyte-td\", th : \"lyte-th\", tr : \"lyte-tr\" } } ),\n\n            ltPropSortable : prop( 'boolean' , { default : default_values.sortable || false }),\n\n            ltPropContainment : prop('string' , { default : default_values.containment || '' }),\n\n            lyteUnbound: prop('boolean', { default: false }),\n\n            ltPropFromListview : prop('boolean' , {default : false} ),\n\n            /**\n             * @componentProperty {boolean} ltPropFixResizeCursor=false\n             * @version 3.95.0\n             */\n\n            ltPropFixResizeCursor : prop( 'boolean', { default : default_values.fixResizeCursor || false } ),\n\n            // system data\n            columns: prop('array', { 'default': [] }),\n            nonFixedColumn: prop('array', { 'default': [] }),\n            minWidth1: prop('string', { 'default': '' }),\n            minWidth2: prop('string', { 'default': '' }),\n            secondaryData: prop('array', { 'default': [] }),\n            boundary: prop('object', { 'default': {} }),\n            rowHeights: prop('array', { 'default': [] }),\n            fromListView : prop( 'boolean', { default : false } )\n        };\n    }\n\n    resize_fun(evt) {\n        var isTch = evt.type == \"touchstart\",\n        __evt = evt,\n        touches = evt.touches;\n\n        if( isTch ){\n            if( touches.length > 1 ){\n                return;\n            }\n            __evt = touches[ 0 ];\n        }\n\n        evt.preventDefault();\n\n        var __this = this,\n        __bcr = __this.__bcr,\n        __elem = __this.__elem,\n        x_inc = ( __this.__clientX - ( __this.__clientX = __evt.clientX ) ) * ( __this._dir ? -1 : 1 ),\n        y_inc = __this.__clientY - ( __this.__clientY = __evt.clientY ),\n        original_x_inc = x_inc,\n        __min1 = __this.__min1,\n        __min2 = __this.__min2,\n        __max1 = __this.__max1,\n        __max2 = __this.__max2,\n        __width = parseFloat( __elem.style.width ),\n        new_width = __width - x_inc,\n        new_height,\n        __next = __elem.nextElementSibling,\n        new_width2,\n        cb = \"onResizeMove\",\n        table = __this.__table,\n        __resize = __this.data.ltPropResize,\n        __dir = __this.__dir,\n        is_hgt_modify = /vert|both/i.test( __dir || '' ),\n        $node = $L( __this.$node );\n\n        if( __dir ){\n            if( !__resize.horizontal ){\n                x_inc = 0;\n            }\n\n            if( !__resize.vertical ){\n                y_inc = 0;\n            }\n        }\n\n        if( __max1 && new_width > __max1 ){\n            x_inc = __max1 - __width;\n        } else if( __min1 && new_width < __min1 ){\n            x_inc = __width - __min1;\n        }\n\n        if( !is_hgt_modify && __min2 != void 0 ){\n            var __width2 = parseFloat( __next.style.width ),\n\n            new_width2 = __width2 + x_inc;\n\n            if( __max2 && new_width2 > __max2 ){\n                x_inc = __width2 - __max2;\n            } else if( __min2 && new_width2 < __min2 ){\n                x_inc = __min2 - __width2;\n            }\n\n            new_width2 = __width2 + x_inc;\n        } else {\n            __next = void 0;\n        }\n\n        if( is_hgt_modify ){\n            var __height = parseFloat( __elem.style.height );\n            new_height = __height - y_inc;\n\n            if( __max2 && new_height > __max2 ){\n                y_inc = __max1 - __height;\n            } else if( __min2 && new_height < __min2 ){\n                y_inc = __height - __min2;\n            }\n\n            new_height = __height - y_inc;\n        }\n\n        if( original_x_inc && __this.data.ltPropFixResizeCursor && /lyte-th/i.test( __elem.tagName ) ){\n            var __diff = original_x_inc - x_inc,\n            trans_value = __this.__trans_value;\n\n            if( __diff ){\n                __this.__trans_value += __diff;\n            } else if( trans_value ) {\n                if( ( trans_value > 0 && x_inc < 0 ) || ( trans_value < 0 &&  x_inc > 0 ) ){\n                    if( __next ){\n                        new_width2 -= x_inc;\n                    }\n\n                    if( Math.abs( trans_value ) < Math.abs( x_inc ) ){\n                        x_inc += trans_value;\n                        __this.__trans_value = 0;\n                    } else {\n                        __this.__trans_value += x_inc;\n                        x_inc = 0;\n                    }\n                }\n            }\n        }\n\n        new_width = __width - x_inc;\n\n        if( table ){\n           $L( table ).css( 'width', ( parseFloat( table.style.width ) - x_inc ) + 'px' );\n\n        } \n\n        $L( __elem ).css( 'width', new_width + 'px' );\n        __next && $L( __next ).css( 'width', new_width2 + 'px' );\n\n        if( __dir ){\n            var ret = $node.css( 'maxWidth', new_width + 'px' );\n            if( new_height ){\n                ret.css( 'maxHeight', new_height + 'px' );\n                $L( __elem ).css( 'height', new_height + 'px' );\n            }\n        }\n\n        window.cancelAnimationFrame( __this._reqId );\n        delete __this._reqId;\n\n        __this.horiScroll( evt, __this.__ww );\n\n        __this.data.ltPropStickyTable && __this._setLeftForInterSection();\n\n        __this.getMethods( cb ) && __this.executeMethod( cb, __elem, evt, __this.$node );\n    }\n\n    resize_up(evt) {\n        var isTch = evt.touches,\n        __doc = document,\n        __fn = 'removeEventListener',\n        cb = 'onResizeEnd',\n        __elem = this.__elem;\n\n        __doc[ __fn ]( isTch ? 'touchmove' : 'mousemove', this.__mmove, true );\n        __doc[ __fn ]( isTch ? 'touchend' : 'mouseup', this.__mup, true );\n\n        [ '__dir', '__ww', '__min2', '__min1', '__max1', '__max2', '__clientX', '__clientY', '__elem', '__bcr', '__table' ].forEach( function( item ){\n            delete this[ item ];\n        }.bind( this ) );\n\n        $L( this.$node ).removeClass( 'resizing lyteTableResizing' );\n        $L( __elem ).removeClass( 'resizeSelect lyteTableResizeSelect' );\n\n        this.clearfdm();\n\n        /**\n         * @method onResizeEnd\n         * @version 1.0.3\n         */\n\n        this.getMethods( cb ) && this.executeMethod( cb, __elem, this.$node, evt );\n    }\n\n    static actions() {\n        return {\n\n            tableResize : function( evt, from ){\n                var isTch = evt.type == \"touchstart\",\n                __evt = evt,\n                touches = evt.touches;\n\n                if( isTch ){\n                    if( touches.length > 1 ){\n                        return\n                    }\n                    __evt = touches[ 0 ];\n                }\n\n                var  __this = this,\n                __data = __this.data,\n                __tags = __data.ltPropTags,\n                table = __this.$node.getElementsByTagName( __tags.table )[ 0 ],\n                __elem = from ? table : evt.target.parentNode,\n                cb = \"onBeforeResizeSelect\";\n\n                if( __this.getMethods( cb ) && __this.executeMethod( cb, __elem, evt, __this.$node ) == false ){\n                    return;\n                }\n\n                var tag = __elem.tagName,\n                is_dual = __data.ltPropDualResize,\n                fastdom = $L.fastdom,\n                __maxwidth = table.style.maxWidth,\n                __minWidth = table.style.minWidth,\n                __maxheight = table.style.maxHeight,\n                __layout = table.style.tableLayout,\n                $table = $L( table ),\n                __width = __elem.offsetWidth,\n                is_cell = tag.toLowerCase() == __tags.th,\n                nextelem = is_cell ? __elem.nextElementSibling : void 0,\n                __next_width = nextelem ? nextelem.offsetWidth : 0,\n                table_width = table.offsetWidth,\n                scroll_elem = __this.scrollDiv,\n                sL = scroll_elem.scrollLeft,\n                is_vert = /vert|both/i.test( from || '' ),\n                table_height = is_vert ? ( table.offsetHeight + 'px' ): table.style.height,\n                $$node = $L( __this.$node ),\n                table_style = window.getComputedStyle( table ),\n                is_fixed = table_style.tableLayout == \"fixed\",\n                read_value = table_style.getPropertyValue( 'max-width' ),\n                max_width_read = is_cell || (  /px/i.test( read_value ) ? parseFloat( read_value ) : Infinity );\n\n                __this.__ignore_scroll = true;\n\n                __this.__bcr = __this.$node.getBoundingClientRect();\n                __this.__ww = window.innerWidth;\n                __this.__dir = from;\n\n                __this.__trans_value = 0;\n\n                if( is_cell && /%|px/i.test( table_style.minWidth ) ){\n                    var __arr = [];\n\n                    Array.from( __this.get_children( __elem.parentNode ) ).forEach( function( item ){\n                        __arr.push({\n                            node : item,\n                            width : item.style.width || ( item.offsetWidth + 'px' )\n                        });\n                    });\n\n                    __arr.forEach( function( item ){\n                        item.node.style.width = item.width;\n                    });\n                }\n\n                $table.css( {\n                    maxWidth :  '0px',\n                    tableLayout : \"auto\",\n                    minWidth : \"auto\"\n                });\n\n                if( is_vert ){\n                    $table.css( 'maxHeight', '0px' );\n                }\n\n                $$node.addClass( 'lyteTableInitialResize' );\n\n                __this.__fd1 = fastdom.measure( function(){\n                    var __style = window.getComputedStyle( __elem ),\n                    actual_min = parseFloat( __style.getPropertyValue( 'min-width' ) ),\n                    minWidth1 = Math.min( __width, Math.max( __elem.offsetWidth, actual_min ) ),\n                    maxWidth1 = is_cell ? parseFloat( __style.getPropertyValue( 'max-width' ) ) : max_width_read,\n                    minWidth2,\n                    maxWidth2;\n\n                    if( minWidth1 == 0 ){\n                        minWidth1 = 50;\n                    }\n\n                    if( is_cell && is_fixed ){\n                        minWidth1 = Math.min( minWidth1, actual_min );\n                    }\n\n                    if( maxWidth1 < minWidth1 ){\n                        maxWidth1 = minWidth1;\n                    }\n\n                    if( is_cell ){\n                        if( !is_dual ){\n                            if( nextelem ){\n                                var next_style = window.getComputedStyle( nextelem ),\n                                actual_min_next = parseFloat( next_style.getPropertyValue( 'min-width' ) );\n\n                                minWidth2 = Math.min( __next_width, Math.max( nextelem.offsetWidth, actual_min_next ) );\n                                maxWidth2 = parseFloat( next_style.getPropertyValue( 'max-width' ) );\n\n                                if( minWidth2 == 0 ){\n                                    minWidth2 = 50;\n                                }\n\n                                if( is_fixed ){\n                                    minWidth2 = Math.min( minWidth2, actual_min_next );\n                                }\n\n                                if( maxWidth2 < minWidth2 ){\n                                    maxWidth2 = minWidth2;\n                                }\n                            }\n                        } else {\n                            __this.__table = table;\n                        }\n                    } else if( is_vert ){\n                        maxWidth2 = parseFloat( __style.getPropertyValue( 'max-height' ) );\n                        minWidth2 = parseFloat( __style.getPropertyValue( 'min-height' ) );\n                    }\n\n                    __this.__fd2 = fastdom.mutate( function(){\n                        __this.__min1 = minWidth1;\n                        __this.__min2 = minWidth2;\n                        __this.__max1 = maxWidth1;\n                        __this.__max2 = maxWidth2;\n\n                        __this.__clientX = __evt.clientX;\n                        __this.__clientY = __evt.clientY;\n\n                        __this.__elem = __elem;\n\n                        $table.css( {\n                            maxWidth : __maxwidth,\n                            width : table_width + 'px',\n                            maxHeight : __maxheight,\n                            height : table_height,\n                            tableLayout : __layout,\n                            minWidth : __minWidth\n                        });\n\n                        $L( __elem ).addClass( 'resizeSelect lyteTableResizeSelect' ).css( 'width', __width + 'px' );\n                        nextelem && $L( nextelem ).css( 'width', __next_width + 'px' );\n\n                        delete __this.__ignore_scroll;\n                        scroll_elem.scrollLeft = sL;\n\n                        var __doc = document,\n                        __fn = \"addEventListener\";\n\n                        __doc[ __fn ]( isTch ? 'touchmove' : \"mousemove\", __this.__mmove = __this.resize_fun.bind( __this ), true );\n                        __doc[ __fn ]( isTch ? 'touchend' : \"mouseup\", __this.__mup = __this.resize_up.bind( __this ), true );\n\n                        $$node.addClass( 'resizing lyteTableResizing' ).removeClass( 'lyteTableInitialResize' );\n\n                        __this.getMethods( cb = \"onResizeSelect\" ) && __this.executeMethod( cb, __elem, evt, __this.$node );\n                    });\n                });\n\n\n                evt.preventDefault();\n                evt.stopPropagation();\n                evt.stopImmediatePropagation();\n            },\n\n            rowMouseDown : function( evt ){\n                if( this.data.ltPropSortable && (evt.button == 0 || (evt.touches && evt.touches.length==1) ) ){      \n                        this.rowMouseDown( evt );\n                }\n            }\n            \n        };\n    }\n\n    clearfdm() {\n        var __fastdom = $L.fastdom;\n\n        [ '__fd1', '__fd2' ].forEach( function( item ){\n            var __cur = this[ item ];\n\n            if( __cur ){\n                __fastdom.clear( __cur );\n                delete this[ item ];\n            }\n        }.bind( this ) );\n    }\n\n    arrayFrom(nodeList) {\n        if (Array.from) {\n            return Array.from(nodeList)\n        }\n        return Array.apply(Array, nodeList);\n    }\n\n    closestFind(path, query) {\n        var elements = this.arrayFrom.call(this, document.querySelectorAll(query));\n        for (var i = 0; i < path.length; i++) {\n            if (Array.prototype.indexOf.call(elements, path[i]) != -1) {\n                return path[i];\n            }\n        }\n        return null;\n    }\n\n    findDomIndex(order) {\n        var data = this.data.ltPropData;\n        for (var i = 0; i < data.length; i++) {\n            if (data[i].index == order) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    insertRow(index, insertData) {\n        var boundary = this._boundary,\n            top = boundary.top,\n            bottom = boundary.bottom,\n            content = this.data.ltPropContent,\n            data = this.data.ltPropData,\n            _contentLength = this.data.ltPropContentLength;\n\n        this._prevent = true;\n\n        this.$addon.arrayUtils(content, 'insertAt', index, insertData);\n\n        if (index <= bottom) {\n            var start = Math.max(top, index);\n\n            for (var i = start; i <= bottom; i++) {\n                var domIndex = this.findDomIndex(i);\n                this.$component.set(data[domIndex], { index: data[domIndex].index, body: content[i] });\n            }\n        }\n\n        if( this.data.ltPropContentLength > content.length || this.data.ltPropContentLength > data.length ) {\n            var _length = data.length;\n\n            this.$addon.arrayUtils( data, 'push', {\n                index : _length,\n                body : content[ _length ],\n                checked : false\n            });\n\n            boundary.bottom++;\n            this._bottom++;\n\n            if( this._rowHgt ){\n                this._step = this._rowHgt * data.length;\n            }\n        }\n\n        delete this._prevent;\n    }\n\n    removeRow(dataIndex) {\n        var tags = this.data.ltPropTags,\n        rows = this.arrayFrom($L( tags.tbody + ' ' + tags.tr + ':not(.dummy)', this.$node));\n\n        if (dataIndex.constructor != Number) {\n            dataIndex = dataIndex.dataOrder || rows.indexOf(dataIndex);\n        }\n\n        var domIndex = this.findDomIndex(dataIndex),\n            boundary = this._boundary,\n            top = boundary.top,\n            bottom = boundary.bottom,\n            content = this.data.ltPropContent,\n            data = this.data.ltPropData,\n            removed = false;\n\n        this._prevent = true;\n\n        if (domIndex != -1) {\n            if (bottom == content.length - 1) {\n                for (var i = dataIndex; i <= bottom; i++) {\n                    var cIndex = (domIndex + (i - dataIndex) + data.length) % data.length;\n                    if (i + 1 == content.length) {\n                        this.regex(rows[cIndex], true);\n\n                        if ( this._dummy ) {\n                            var _style = this._dummy.style;\n                            _style.transform = 'translateY(' + ( parseFloat( _style.transform.match( /[\\d|.]+/ig)[ 0 ] ) - this._rowHgt ) + 'px)';\n                            \n                            if ( this._dummy1 ) {\n                                var _style1 = this._dummy1.style;\n                                _style1.transform = 'translateY(' + ( parseFloat( _style1.transform.match( /[\\d|.]+/ig)[ 0 ] ) - this._rowHgt ) + 'px)';\n                            }\n                        }\n                        if( content[ top - 1 ] ){\n                            set(data[cIndex], { index: data[cIndex].index, body: content[top - 1] });\n                            rows[ cIndex ].dataOrder = top - 1;\n                        }\n                    } else {\n                        set(data[cIndex], { index: data[cIndex].index, body: content[i + 1] });\n                        rows[cIndex].dataOrder--;\n                    }\n                }\n                if( content.length - 1 == data.length - 1 ){\n                    this.$addon.arrayUtils( data , 'pop' );\n                    removed = true;\n                }else if( boundary.top >= dataIndex){\n                    boundary.top--;\n                } \n                if(this._top != 0){\n                    this._top = (this._top -1 + data.length) % data.length;\n                }\n                this._bottom = (this._bottom - 1 + data.length) % data.length;\n                boundary.bottom--;\n                boundary.top!=0 && boundary.top--;\n \n            } else {\n                for (var i = dataIndex; i <= bottom; i++) {\n                    var cIndex = (domIndex + (i - dataIndex) + data.length) % data.length;\n                    set(data[cIndex], { index: data[cIndex].index, body: content[i + 1] });\n                }\n                if (this._dummy) {\n                    var _style = this._dummy.style;\n                    _style.height = Math.max( 0, parseFloat( _style.height ) - this._rowHgt ) + 'px';\n                }\n            }\n            this.$addon.arrayUtils(content, 'removeAt', dataIndex);\n        } else {\n            this.$addon.arrayUtils(content, 'removeAt', dataIndex);\n            if (dataIndex < top) {\n\n                for (var i = top; i <= bottom; i++) {\n                    var cIndex = (this._top + i - top + rows.length) % rows.length;\n                    set(data[cIndex], { index: data[cIndex].index, body: content[i == content.length ? (top - 1) : i] });\n                    if (i == bottom) {\n                        this.regex(rows[cIndex], true);\n                        this._bottom = (this._bottom - 1 + data.length) % data.length;\n                        this._top = (this._top - 1 + data.length) % data.length;\n                    }\n                }\n\n                boundary.bottom--;\n                boundary.top--;\n\n                var _style = this._dummy.style;\n                _style.transform = 'translateY(' + Math.max( 0, ( parseFloat( _style.transform.match(/[\\d|.]+/ig)[ 0 ] ) - this._rowHgt ) ) + 'px)';\n                if (this._dummy1) {\n\n                    var _style1 = this._dummy1.style;\n                    _style1.transform = 'translateY(' + Math.max( 0, ( parseFloat( _style1.transform.match( /[\\d|.]+/ig )[ 0 ] ) - this._rowHgt ) ) + 'px)';\n                }\n\n            } else if (dataIndex > bottom) {\n                if (this._dummy) {\n                    this._dummy.style.height = Math.max(0, parseFloat(this._dummy.style.height) - this._rowHgt) + 'px';\n                }\n            }\n\n            if( content.length < this.data.ltPropContentLength && !removed ){\n                    Lyte.arrayUtils( data, 'pop' );\n            }\n        }\n\n        delete this._prevent;\n    }\n\n    scrollToRecord(rowIndex, isImmediate, scrollTop) {\n        var content = this.data.ltPropContent,\n            contentLength = content.length;\n\n        if (rowIndex == undefined || rowIndex < 0 || rowIndex >= contentLength) {\n            return;\n        }\n\n        if (!this._rowHgt) {\n            this.$node.scrollTable();\n        }\n\n        $L.fastdom.clear(this._scrollToRecord);\n\n        isImmediate ? this.processScrollToRecord( rowIndex , scrollTop ) : this._scrollToRecord = $L.fastdom.measure(this.processScrollToRecord.bind(this, rowIndex));\n\n        // this.processScrollToRecord( rowIndex );\n    }\n\n    processScrollToRecord(rowIndex, _scrollTop) {\n        var boundary = this._boundary,\n        top = boundary.top,\n        bottom = boundary.bottom,\n        content = this.data.ltPropContent,\n        data = this.data.ltPropData,\n        contentLength = data.length,\n        __length = content.length,\n        step = this._step,\n        rowHeight = this._rowHgt,\n        scrollDiv = this.scrollDiv,\n        offsetHeight = scrollDiv.offsetHeight,\n        scrollHeight = scrollDiv.scrollHeight,\n        scrollTop = scrollDiv.scrollTop,\n        possible_per_view = Math.floor( offsetHeight / rowHeight ),\n        scrollPosition = Math.max(0, Math.min(rowIndex, __length - Math.min( contentLength, possible_per_view ) ) ),\n        newScrollTop = scrollPosition * rowHeight,\n        scrollToSet,\n        __tags = this.data.ltPropTags;\n\n        if( content.length <= contentLength ){\n            scrollToSet = Math.max( 0, Math.min( scrollHeight - offsetHeight, rowIndex * rowHeight ) );\n        } else if( bottom - possible_per_view >= rowIndex ) {\n            scrollToSet = newScrollTop;\n        } else {\n            if (scrollPosition != rowIndex) {\n                newScrollTop += (step - offsetHeight);\n                var thead = $L( __tags.thead, this.$node).get(0);\n                if (thead) {\n                    newScrollTop += thead.offsetHeight;\n                }\n            }\n\n            var scrollHeight = scrollDiv.scrollHeight,\n            maxScrollTop = scrollHeight - offsetHeight,\n            diff = step - offsetHeight,\n            rows = this.arrayFrom($L( __tags.tbody + ' ' + __tags.tr + ':not(.dummy)', this.$node)),\n            fact = Math.floor(scrollPosition / contentLength),\n            newscrollPosition = scrollPosition % contentLength;\n\n            for (var i = 0; i < contentLength; i++) {\n                var cIndex = scrollPosition + i,\n                domIndex = cIndex % contentLength,\n                dom = rows[ domIndex ],\n                iteration = fact /*+ (i < newscrollPosition ? 1 : 0)*/;\n\n                if( cIndex >= __length ){\n                    if( scrollPosition % contentLength < domIndex ){\n                        iteration--;\n                    }\n                    cIndex -= contentLength;\n                } else {\n                    if( scrollPosition % contentLength > domIndex ){\n                        iteration++;\n                    }\n                }\n\n                set(data[domIndex], { index: cIndex, body: content[cIndex] });\n\n                this.cellSet(dom, \"translateY(0px)\")\n                for (var j = 0; j < iteration; j++) {\n                    this.regex(dom);\n                }\n            }\n\n            if( !this._dummy ){\n                this.createDummy( this.$node.querySelector( __tags.tbody ) );\n            }\n\n            var boundary_top = Math.min( scrollPosition, __length - contentLength );\n\n            this._dummy.style.transform = 'translateY(' + ( boundary_top * rowHeight ) + 'px)';\n            if (this._dummy1) {\n                this._dummy1.style.transform = 'translateY(' + ( boundary_top * rowHeight) + 'px)';\n            }\n            scrollToSet = newScrollTop;\n            boundary.top = boundary_top;\n            boundary.bottom = boundary_top + contentLength - 1;\n            this._top = boundary_top % contentLength;\n            this._bottom = ( boundary_top + contentLength - 1) % contentLength;\n        }\n\n        var scrollFn = function (  ) {\n            scrollDiv.querySelector( 'lyte-table-structure' ).style.height = ( contentLength * rowHeight ) + 'px';\n            scrollDiv.scrollTop = scrollToSet;\n        }\n        if( _scrollTop != void 0 ){\n            scrollToSet = _scrollTop;\n            scrollFn();\n        }else{\n            window.requestAnimationFrame( scrollFn );\n        }\n        \n    }\n\n    calculateRowHeight() {\n        let tbody = this.$node.getElementsByTagName( this.data.ltPropTags.tbody );\n        let tr = tbody[0].children[0];\n        let rowHeight = tr && tr.getBoundingClientRect().height;\n\n        return this._rowHgt = rowHeight;\n    }\n\n    update_aria(cell) {\n        var row = cell.parentNode,\n        index = this.get_children( row ).indexOf( cell ),\n        table = row.parentNode.parentNode,\n        sA = \"setAttribute\",\n        role = \"role\",\n        __tags = this.data.ltPropTags;\n\n        table[ sA ]( role, this.data.ltPropRole );\n        \n        Array.from( this.get_children( table ) ).forEach( function( item ){\n\n            if( /^div$/i.test( item.tagName || \"\" ) ){\n                return;\n            }\n\n            item[ sA ]( role, \"rowgroup\" );\n\n            var name = item.tagName.toLowerCase() == __tags.thead ? 'columnheader' : 'cell';\n\n            Array.from( this.get_children( item ) ).forEach( function( row ){\n                row[ sA ]( role, 'row' );\n\n                var __cell = this.get_children( row )[ index ];\n\n                if( __cell ){\n                    __cell[ sA ]( role, name );\n                }\n            }.bind( this ) );\n        }.bind( this ) );\n    }\n\n    get_children(__elem) {\n        var elems = __elem.length != void 0 ? Array.from( __elem ) : [ __elem ],\n        ret = [];\n\n        elems.forEach( function( item ){\n            Array.from( item.children ).forEach( function( __item ){\n                if( !/template/i.test( __item.tagName ) ){\n                    ret.push( __item );\n                }\n            });\n        });\n\n        return ret;\n    }\n\n    get_nth_cell(row, index) {\n        var children = this.get_children( row ),\n        __len = children.length,\n        __count = 0;\n\n        if( this.data.ltPropFromListview ){\n            return children[ index ];\n        }\n        for( var i = 0; i < __len; i++ ){\n            var __cell = children[ i ];\n            if( __count == index ){\n                return __cell;\n            } else if( __count > index ){\n                break;\n            }\n\n            __count += ( __cell.colSpan || 1 );\n        }\n    }\n\n    update_collapse(frm_update) {\n        if( this.__from_collapse ){\n            return;\n        }\n        var cells = Array.from( this.$node.getElementsByClassName( 'lyteHeaderCellCollapsed' ) );\n        cells.forEach( function( item ){\n            this.toggle_column( item, true, frm_update );\n        });\n    }\n\n    toggle_column(__cell, to_collapse, frm_update) {\n        var __index = Array.from( __cell.parentNode.children ).indexOf( __cell ),\n        header_cls = \"lyteHeaderCellCollapsed\",\n        body_cls = \"lyteCellCollapsed\",\n        tbody = this.$node.getElementsByTagName( this.data.ltPropTags.tbody ),\n        rows = this.get_children( tbody ),\n        __is_sticky = this.data.ltPropStickyTable;\n\n        __cell.classList[ to_collapse ? 'add' : \"remove\" ]( header_cls );\n\n        rows.forEach( function( item, index ){\n            var __elem = this.get_nth_cell( item, __index );\n\n            if( __elem ){\n                if( !index ){\n                    if( to_collapse ){\n                        __elem.rowSpan = rows.length;\n                    } else {\n                        __elem.rowSpan = 1;\n                    }\n                    __elem.classList[ to_collapse ? \"add\" : \"remove\" ]( \"lyteCollapseFirstCell\" );\n                }\n\n                __elem.classList[ to_collapse ? \"add\" : \"remove\" ]( body_cls );\n            }\n        }.bind( this ) );\n\n        if( !this.__from_collapse && !frm_update && ( __is_sticky || __cell.classList.contains( 'lyteTableFixed' ) ) ){\n            $L.fastdom.clear( this.__collpse_fdom );\n            this.__from_collapse = true;\n            this.__collpse_fdom = $L.fastdom.measure( function(){\n                delete this.__collpse_fdom;\n                this.$node[ __is_sticky ? \"reset\" : \"scrollTable\" ]();\n                delete this.__from_collapse;\n            }.bind( this ) );\n        }\n    }\n\n    collapse_column(__cell) {\n        this.toggle_column( __cell, true );\n    }\n\n    expand_column(__cell) {\n        this.toggle_column( __cell );\n    }\n\n    static observers() {\n        return {\n            initProcess1 : function( arg ){\n                var __this = this,\n                __data = __this.data,\n                is_reset = arg && arg.item == \"ltPropReset\";\n\n                if( __this._prevent ){\n                    return\n                }\n\n                if( is_reset && arg.newValue == false ){\n                    return;\n                }\n\n                if( __data.ltPropInfiniteScroll ){\n                    var table = __this.$node.getElementsByTagName( __data.ltPropTags.table )[ 0 ],\n                    content = __data.ltPropContent || [],\n                    __length = content.length,\n                    len = Math.min( __data.ltPropContentLength || __length, __length ),\n                    data = [];\n\n                    if( __length == 0 && !arg ){\n                        return;\n                    }\n\n                    if( table ){\n                        table.style.height = \"auto\";\n                    }\n\n                    for( var i = 0; i < len; i++ ){\n                        data[ i ] = {\n                            body : content[ i ],\n                            checked : false,\n                            index : i\n                        };\n                    }\n\n                    if( __data.fromListView ){\n                        var act_data = __data.ltPropData,\n                        arr_util = this.$addon.arrayUtils,\n                        obj_util = this.$addon.objectUtils;\n\n                        data.forEach( function( item, index ){\n                            var __cur = act_data[ index ];\n\n                            if( __cur ){\n                                obj_util( __cur, 'add', 'body', item.body );\n                                obj_util( __cur, 'add', 'index', item.index );\n                                obj_util( __cur, 'add', 'checked', item.checked );\n                            }else {\n                                arr_util( act_data, 'insertAt', item.index, item );\n                            }\n                        });\n\n                        arr_util( act_data, 'splice', data.length, act_data.length - data.length );\n\n                    } else {\n                        this.setData( 'ltPropData', data );\n                    }\n\n                    var __dummy = __this._dummy,\n                    __dummy1 = __this._dummy1,\n                    __scrolldiv = __this.scrollDiv,\n                    __translate = \"translateY(0px)\";\n\n                    delete __this._stopScroll;\n\n                    if( arg ){\n                        __dummy && $L( __dummy ).css({\n                            height : 0,\n                            transform : __translate\n                        });\n\n                        __dummy1 && $L( __dummy1 ).css( 'transform', __translate );\n\n                        __scrolldiv.scrollTop = 0;\n                        __scrolldiv.scrollLeft = 0;\n                    }\n\n                    __this._boundary = {\n                        top : __this._top = 0,\n                        bottom : __this._bottom = Math.max( len - 1, 0 )\n                    };\n                }\n\n                if( is_reset ){\n                    this.setData( arg.item, false );\n                }\n            }.observes( 'ltPropContent.[]', 'ltPropReset' ).on( 'init' ),\n\n            // border \n\n            borderChangeObs: function () {\n                this.borderChange.call(this);\n            }.observes('ltPropBorder').on('didConnect'),\n\n            widthObsObs: function () {\n                this.widthObs.call(this);\n            }.observes('ltPropWidth').on('didConnect'),\n\n            heightObsObs: function () {\n                this.heightObs.call(this);\n            }.observes('ltPropHeight').on('didConnect'),\n\n            sortableObs: function () {\n                !this.data.ltPropStickyTable && this.sortable();\n            }.observes('ltPropColumnSortable').on('didConnect')\n        };\n    }\n\n    includes() {\n        return [LyteTableUtilsMixin, LyteTableSortableMixin];\n    }\n}\n\nif (!window._lyteUiUtils.registeredCustomElements['lyte-th']) {\n    window._lyteUiUtils.registeredCustomElements['lyte-th'] = true;\n\n    /**\n     * @customElement lyte-th,lyte-td\n     */\n    class LyteThCustomElements extends LyteUiComponentComponentRegistry.CustomElements {\n        static options = {clone : {allCallbacks : false}};\n\n        lookups() {\n            return [{\n                component: LyteUiComponentComponentRegistry\n            }];\n        }\n\n        constructor() {\n            super();\n        }\n\n        static get observedAttributes() {\n            return [ 'fixed', 'resize', 'icon', 'sticky-position', \"collapse\" ];\n        }\n\n        getTable() {\n            var lyteNode = this.$node;\n            var query = \"lyte-table\";\n            return (lyteNode.__table || (lyteNode.__table = lyteNode.closest ? lyteNode.closest( query ) : $L( lyteNode ).closest( query ).get( 0 )));\n        }\n\n        getSticky() {\n            var lyteNode = this;\n            var __sticky = lyteNode.__is_sticky;\n            return __sticky == void 0 ? ( lyteNode.__is_sticky = lyteNode.getTable().ltProp( 'stickyTable' ) ) : __sticky;\n        }\n\n        connectedCallback() {\n            var lyteNode = this;\n            var table = lyteNode.getTable(),\n            $node = lyteNode.$node;\n\n            if( table && table.ltProp( 'role' ) && table.ltProp( 'yield' ) ){\n                table.component.update_aria( $node );\n            }\n\n            if( $node.parentNode.previousElementSibling ){\n                lyteNode.$node.classList.add( \"lyteTableSecondaryHeader\" );\n            }\n        }\n\n        attributeChangedCallback(attr, oldVal, newVal) {\n            var lyteNode = this.$node;\n\n            var $node = $L( lyteNode );\n\n            switch (attr) {\n                case 'fixed': {\n                    var is_enable = newVal == \"enable\";\n\n                    $node[ ( is_enable ? 'add' : \"remove\" ) + 'Class' ]( 'lyteFixedColumn' );\n                    if( this.getSticky() ){\n                        lyteNode.__table.component.checkIntersection.call( lyteNode, is_enable );\n                    }\n                }\n                    break;\n                case 'resize': {\n                    var ns = 'lyte-tablehead-resize';\n                    if( newVal == \"enable\" ){\n                        var thead = document.createElement( ns ),\n                        __add = \"addEventListener\",\n                        fn = this.resize;\n\n                        thead[__add]('mousedown', fn);\n                        thead[__add]('touchstart', fn);\n\n                        lyteNode.appendChild( thead );\n                    } else {\n                        var thead = lyteNode.getElementsByTagName( ns )[ 0 ];\n                        if( thead ){\n                            lyteNode.removeChild( thead );\n                        }\n                    }\n                }\n                break;\n                case 'icon' : {\n                    $node[ ( newVal == \"disable\" ? 'add' : \"remove\" ) + 'Class' ]( 'lytePreventIcon' );\n                }\n                break;\n                case 'sticky-position' : {\n                    if( $node.attr( 'fixed' ) == \"enable\" && this.getSticky() ){\n                        var is_enable = newVal == \"right\",\n                        __table = lyteNode.__table.component,\n                        fn = is_enable ? 'add' : \"remove\",\n                        __class = 'lyteTableRightFixed';\n\n                        if( !is_enable && !$node.hasClass( __class ) ){\n                            return;\n                        }   \n\n                        __table.stickyFunction( lyteNode, false, fn + 'Class', __class );\n                        __table.checkIntersection.call( lyteNode, is_enable, true );\n                    }\n                }\n                break;\n                case 'collapse' : {\n                    var __table = this.getTable();\n\n                    if( __table ){\n                        if( newVal == \"true\" ){\n                            __table.component.collapse_column( lyteNode );\n                        } else if( oldVal == \"true\" ){\n                            __table.component.expand_column( lyteNode );\n                        }\n                    }\n                }\n                break;\n            }\n        }\n\n        resize(event) {\n            var lyteNode = this;\n            if (lyteNode.parentNode.classList.contains('lyteTableFixed')) {\n                return;\n            }\n            var table = $L(event.target).closest('lyte-table')[0];\n            table.component.getActions(\"tableResize\").call(table.component, event);\n        }\n\n        disconnectedCallback() {\n            var lyteNode = this.$node;\n            if( lyteNode.__is_sticky ){\n                lyteNode.__table.component.disconnectedCallback.call( lyteNode );\n            }\n            delete lyteNode.__table;\n        }\n    }\n\n    LyteThCustomElements.register(\"lyte-th\");\n\n    window.resizeTable = function(evt) {\n        if (evt && evt.type == 'resize' && _lyteUiUtils.isMobile) {\n            return;\n        }\n\n        var fn = function( item ){\n            var __elem = item.component.scrollDiv,\n            $elem = $L( __elem );\n            __elem && $elem.resetScrollbar && $elem.resetScrollbar();\n        },\n        is_orient = evt && evt.type == \"orientationchange\";\n\n        Array.from(document.body.getElementsByTagName('lyte-table')).forEach(function (item) {\n            if (is_orient) {\n                setTimeout(fn.bind(this, item), 500);\n            } else {\n                fn(item);\n            }\n        });\n    };\n}\n\n\n/**\n * @syntax nonYielded\n *   <lyte-table  lt-prop-content='[{\"cityName\" : \"Agra\",\"serialNo\" : \"1\"},{\"cityName\" : \"Mysore\", \"serialNo\" : \"2\"}]' lt-prop-header='[{\"data\" : \"From\", \"bodyData\" : \"cityName\"},{\"data\" : \"No\", \"bodyData\" : \"serialNo\"}]' lt-prop-header-label-key='data' lt-prop-body-label-key='bodyData' >\n *   </lyte-table>\n */\n\n/**\n * @syntax yielded\n * <lyte-table lt-prop-yield=\"true\">\n *      <template is=\"registerYield\" yield-name=\"yield\">\n *          <lyte-table-structure>\n *             <lyte-thead>\n *                <lyte-tr>\n *                   <lyte-th>From</lyte-th>\n *                   <lyte-th>No</lyte-th>\n *                   <lyte-th>Name</lyte-th>\n *                </lyte-tr>\n *             </lyte-thead>\n *             <lyte-tbody>\n *                <lyte-tr>\n *                   <lyte-td>Agra</lyte-td>\n *                   <lyte-td>1</lyte-td>\n *                   <lyte-td>Tajmahal</lyte-td>\n *                </lyte-tr>\n *                <lyte-tr>\n *                   <lyte-td>Mysore</lyte-td>\n *                   <lyte-td>2</lyte-td>\n *                   <lyte-td>Mysorepalace</lyte-td>\n *                </lyte-tr>\n *             </lyte-tbody>\n *          </lyte-table-structure>\n *      </template>\n *  </lyte-table>\n */\n\n/**\n * @syntax Infinite scroll\n * @attribute ltPropYield=true\n * @attribute ltPropInfiniteScroll=true\n *  <lyte-table style = 'height: 350px;' lt-prop-infinite-scroll = true lt-prop-yield = true lt-prop-content = {{contentJSON}} scroll-end = {{method('someMethod')}}>\n *   <template is = 'registerYield' yield-name = 'yield'>\n *       <lyte-table-structure>\n *           <lyte-thead>\n *               <lyte-tr>\n*                  <lyte-th> From </lyte-th>\n*                  <lyte-th> No </lyte-th>\n*                  <lyte-th> Name </lyte-th>\n *              </lyte-tr>\n *           </lyte-thead>\n *           <lyte-tbody>\n *             <lyte-tr>\n *               <lyte-td> Agra </lyte-td>\n *               <lyte-td> 1 </lyte-td>\n *               <lyte-td> Taj Mahal </lyte-td>\n *             </lyte-tr>\n *              <lyte-tr>\n *               <lyte-td> Mysore </lyte-td>\n *               <lyte-td> 2 </lyte-td>\n *               <lyte-td> Mysore palace </lyte-td>\n *             </lyte-tr>\n *           </lyte-tbody>\n *       </lyte-table-structure>\n *   </template>\n *  </lyte-table>\n */\nexport { LyteTableComponent };\n \n","import { prop } from \"@slyte/core\";\nimport { Component } from \"../component.js\";\nimport $L from \"@zoho/lyte-dom\";\n\n/**\n * Tooltip is a component used to show information related to an element\n * @component lyte-tooltip\n * @version 1.0.0\n */\n\n/*\n  todo =>  // If the tooltip is invoked when the trigger element receives focus, then it is dismissed when it no longer has focus (onBlur). If the tooltip is invoked with mouseIn, then it is dismissed with on mouseOut.\n\n  tooltip animation support\n\n  , re using created tooltip span\n*/\n\nclass LyteTooltipComponent extends Component {\n  constructor() {\n    super();\n  }\n\n  init() {\n\n    if( this.getMethods( 'beforeRender' ) ){\n            /**\n             * @method beforeRender\n             * @version 1.0.1\n             */\n            this.executeMethod( 'beforeRender', this.$node );\n        }\n  }\n\n  rtlfunc(lft, bcr, ww) {\n    if( this._dir && lft != 'top' && lft != 'clientY' ) {\n      if( bcr ) {\n        if( lft == 'right' ) {\n          return ww - bcr.left;\n        } else if( lft == 'clientX' ) {\n          return ww - bcr.clientX;\n        }\n        return ww - bcr.right;\n      } else if( lft == 'left' ) {\n        return 'right';\n      } else if( lft == 'right' ) {\n        return 'left';\n      }\n    }\n    return bcr ? bcr[ lft ] : lft;\n  }\n\n  data() {\n\n    var default_values = window._lyteUiUtils.getDefault( 'lyte-tooltip' );\n\n    return {\n      //user data\n      /**\n       * @componentProperty {string} ltPropId=''\n       * @version 1.0.0\n       */\n      ltPropId : prop('string', {default : default_values.id || '' }),\n      /**\n       * @componentProperty {string} ltPropClass=''\n       * @version 1.0.0\n       */\n      ltPropClass : prop('string', {default : default_values.class || '' }),\n      /**\n       * @componentProperty {boolean} ltPropKeepAlive=false\n       * @version 1.0.0\n       */\n      ltPropKeepAlive : prop('boolean', {default : default_values.keepAlive || false }),\n      ltPropKeepAlive : prop(\"boolean\", {default : default_values.keepAlive || false }),\n\n      /**\n       * @typedef {object} tooltipConfig\n       * @property {left | right | top | bottom | topright | bottomright | topleft | bottomleft | followcursor} position\n       * @property {box | callout} appearance=callout\n       * @property {number} margin=0\n       * @maxValue 20\n       * @property {number} showdelay=0\n       * @property {number} hidedelay=0\n       * @property {number} maxdisplaytime=5000\n       * @property {boolean} keeptooltip=false\n       * @property {boolean} hideOnClick=true\n       */\n\n      /**\n       * @componentProperty {tooltipConfig} ltPropTooltipConfig\n       * @default {}\n       * @version 2.2.20\n       */\n      ltPropTooltipConfig : prop( 'object', { default : default_values.tooltipConfig || {} } ),\n\n      /**\n       * @componentProperty {string} ltPropIgnoreClass=\"lyteTooltipIgnore\"\n       * @version 3.28.2\n       **/\n\n      ltPropIgnoreClass : prop( 'string', { default : default_values.ignoreClass || \"lyteTooltipIgnore\" } ),\n\n      /**\n       * @componentProperty {boolean} ltPropAria=false\n       * @version 3.45.0\n       **/\n\n       ltPropAria : prop( 'boolean', { default : default_values.aria || false } ),\n\n      // system data\n\n      tooltips : prop( 'object', { default : {} } )\n    };\n  }\n\n  focusev(evt) {\n\n    var fastdom = $L.fastdom;\n\n    fastdom.mutate( function(){\n        this.$node.trigger( evt.type == \"focus\" ? evt.target : document.body );\n    }.bind( this ) );\n  }\n\n  didConnect() {\n\n      this._dir = window._lyteUiUtils.getRTL();\n\n      var tooltips = Array.from( document.body.getElementsByTagName( 'lyte-tooltip' ) );\n\n      tooltips.forEach( function( item ){\n        if( item != this.$node ){\n           document.body.removeChild( item );\n        }\n      }.bind( this ) );\n\n      this._mousemove = this.mousemove.bind( this );  \n      this._mousedown = this.mousedown.bind( this );\n      this._mouseup = this.mouseup.bind( this );\n      this._keydown = this.keydown.bind( this );\n      this._toolscroll = this.tooltipScroll.bind( this );\n\n      document.addEventListener( 'mousemove', this._mousemove, true ); \n      window.addEventListener('scroll', this._toolscroll , true); \n      document.addEventListener( 'keydown', this._keydown, true);\n      document.addEventListener( 'mousedown', this._mousedown, true );\n      document.addEventListener( 'touchstart', this._mousedown );\n\n      if( this.data.ltPropAria ){\n         this.bind_aria();\n      }\n\n      if( this.getMethods( 'afterRender' ) ) {\n            /**\n             * @method afterRender\n             * @version 1.0.1\n             */\n          this.executeMethod('afterRender', this.$node);\n      }\n      /**\n       * @utility trigger\n       * @version 3.2.0\n       */\n      this.$node.trigger = function( node ){\n        this.mousemove( { target : node || document.body } );\n      }.bind( this )\n\n  }\n\n  bind_aria() {\n         this._focusev = this.focusev.bind( this );\n\n         [ 'focus', 'blur' ].forEach( function( item ){\n            document.addEventListener( item, this._focusev, true );\n         }.bind( this ) );\n  }\n\n  remove_aria() {\n      [ 'focus', 'blur' ].forEach( function( item ){\n         document.removeEventListener( item, this._focusev, true );\n      }.bind( this ) );\n  }\n\n  tooltipScroll(event) {\n    var vis =  this.data.tooltips;\n\n     for( var i in vis ){\n        vis[ i ].classList.add( 'lyteTooltipHidden' );\n     }\n  }\n\n  mousedown(evt) {\n      this._mousedownFlag = true;\n      var target = evt.target.correspondingElement || evt.target,\n      $target = $L( target ),\n      isTch = /touch/i.test( evt.type );\n\n      if( ( isTch && evt.touches.length > 1 ) ){\n          return;\n      }\n\n      if( $target.hasClass( 'lyteSliderHandler' ) ){\n         delete this.prevTooltipNode;\n         this._slider = true;   \n      } \n\n      if( $target.hasClass( 'lyteTooltip' ) ){\n         var act_node = target.nodeName1;\n         this.hover_process( act_node );\n         this.closeAllTooltip( act_node, true );\n      } else {\n         this.closeAllTooltip( void 0, true );\n      }\n\n      if( target.closest( '[draggable=\"\"],[draggable=\"true\"]' ) ){\n         delete this._mousedownFlag;\n         this.__dragging = true;\n      } else {\n        delete this.__dragging;\n         document.addEventListener( isTch ? 'touchend' : 'mouseup', this._mouseup, true );\n      }\n  }\n\n  mouseup(evt) {\n      delete this._mousedownFlag;\n      document.removeEventListener( evt.type, this._mouseup, true );\n\n      if( this._slider ){\n         delete this._slider;\n         var target = evt.target.correspondingElement || evt.target;\n\n         if( $L( target ).hasClass( 'lyteSliderHandler' ) ){\n            this.mousemove( { target : target } );\n         }\n      }\n  }\n\n  keydown(evt) {\n     delete  this.prevTooltipNode;\n     this.closeAllTooltip();\n  }\n\n  tooltipOpenCallback(arg1, arg2) {\n      if( arg1.onTooltipShow ) {\n          arg1.onTooltipShow.apply(this, arguments)     \n      }\n      if(this.getMethods( 'onTooltipShow' ) ) {\n          /**\n           * @method onTooltipShow\n           * @version 1.0.2\n           */\n          this.executeMethod( 'onTooltipShow', arg1, arg2, arg1.tooltip );\n      }\n  }\n\n  tooltipCloseCallback(arg1) {\n      if( arg1.onTooltipHide ) {\n          arg1.onTooltipHide.apply(this, arguments)     \n      }\n     if(this.getMethods( 'onTooltipHide' ) ) {\n          /**\n           * @method onTooltipHide\n           * @version 1.0.2\n           */\n          this.executeMethod( 'onTooltipHide', arg1 );\n      }\n  }\n\n  didDestroy() {\n\n        var rel = \"removeEventListener\",\n        doc = document;\n\n        window[ rel ]('scroll', this._toolscroll , true);\n        doc[ rel ]('mousemove', this._mousemove, true);\n        doc[ rel ]('mousedown', this._mousedown, true);\n        doc[ rel ]('touchstart', this._mousedown);\n        doc[ rel ]( 'keydown', this._keydown, true );\n\n        if( this.data.ltPropAria ){\n           this.remove_aria();\n        }\n        \n        var exsttools = this.data.tooltips;\n\n        for( var i in exsttools ){\n          var current = exsttools[ i ];\n\n           delete current.nodeName1.tooltipSpan;\n           delete current.nodeName1.tooltip;\n           if( current.parentNode ){\n            doc.body.removeChild( current );\n          }\n        }\n        delete this.$node.trigger; \n\n        [ '_toolscroll', '_mousedown', '_keydown', '_mousemove', '_focusev', '__reuse' ].forEach( function( item ){\n           delete this[ item ];\n        }.bind( this ) );\n\n        this.data.tooltips = []; \n        this.data.tooltips = {};\n  }\n\n  propertySetting(nodeName1) {\n      var config = nodeName1.getAttribute( 'lt-prop-tooltip-config' ) || '{}',\n      __config = nodeName1.tooltip.config;\n\n      // if( config ){\n          var config = JSON.parse( config );\n          for( var key in config ){\n              __config[ key ] = config[ key ];\n          }\n      // }\n  }\n\n  createTooltip(event, span, flag) {\n      if( flag ){\n         this.followcursor( event, span );\n      } else {\n         this.nonFollowcursor( event, span );\n      }\n      if( !this.getData( 'ltPropKeepAlive' ) ){\n        var tooltip = span.nodeName1.tooltip;\n        if( ( tooltip.config.keeptooltip != true && tooltip.config.keeptooltip != 'true' ) ) {\n            tooltip.maxdisp = setTimeout( this.removeTooltip.bind( this, span ) , tooltip.config.maxdisplaytime );\n        }\n      }\n  }\n\n  followcursor(event, span) {\n    // here tooltip changes its position on every mousemov. so fastdom can't  be used here\n      if( document.body.contains( span ) ){\n            // span.innerText = span.nodeName1.tooltip.title; \n            if( !span._callbackHandled ) {\n                this.tooltipOpenCallback( span.nodeName1, span );\n                span._callbackHandled = true;\n            }     \n            if( span.classList.contains( 'lyteTooltipHidden' ) ){\n              span.classList.remove( 'lyteTooltipHidden' );\n              $L.fastdom.measure( this._followcursor.bind( this, event,span ) );\n            } else {\n              this._followcursor( event, span );\n            }\n        }\n  }\n\n  _followcursor(evt, span) {\n      if( !this.data.tooltips[ span._random ] ){\n        return;\n      }\n      var bcr = span.getBoundingClientRect(),\n      nodeBcr = span.nodeName1.getBoundingClientRect(),\n      scrollLeft = ( window.pageXOffset || document.documentElement.scrollLeft ) * ( this._dir ? -1 : 1 ),\n      scrollTop = window.pageYOffset || document.documentElement.scrollTop,\n      iW = window.innerWidth,\n      iH = window.innerHeight,\n      margin = Math.min( 20, parseInt( span.nodeName1.tooltip.config.margin ) ),\n      leftToSet = this.rtlfunc.call( this, 'clientX', evt, iW ),\n      topToSet = ( evt.clientY + scrollTop + 5 + margin ),\n      topCheck;\n\n      if( leftToSet + bcr.width > iW ){\n        if( leftToSet - bcr.width > 0 ){\n           leftToSet = leftToSet - bcr.width;\n        } else {\n          var midFrmRgt = iW - ( this.rtlfunc( 'left', nodeBcr, iW ) + nodeBcr.width / 2 ),\n          midFrmLeft = iW - midFrmRgt;\n\n          if( midFrmRgt > bcr.width / 2 && midFrmLeft > bcr.width / 2 ){\n              leftToSet = midFrmLeft - bcr.width * 0.5;\n          } else {\n             leftToSet = Math.max( 0, iW - bcr.width );\n          }\n          topCheck = true;\n        }\n      }\n\n      span.style[ this.rtlfunc.call( this, 'left' ) ] = ( leftToSet + scrollLeft ) +'px';\n      span.style.top = topToSet + 'px';\n      if( topCheck ){\n         $L.fastdom.measure( function(){\n            if( !this.data.tooltips[ span._random ] ){\n              return;\n            }\n            bcr = span.getBoundingClientRect();\n            if( bcr.bottom > iH ){\n               if( evt.clientY > (  iH - evt.clientY ) ){\n                  span.style.top = ( evt.clientY - bcr.height - margin - 5 + scrollTop ) + 'px'\n               }\n            }\n         }.bind( this ) )\n      }\n  }\n\n  createsupp(span) {\n     var inn = document.createElement( 'span' );\n     inn.classList.add( 'lyteTooltipInnerSpan' );\n     span.classList.add( 'lyteInnerToolAdded' );\n     return span.appendChild( inn );\n  }\n\n  rightalign(\n    innWidth,\n    xscroll,\n    newLeft,\n    spanClientRect,\n    span,\n    prevent,\n    event,\n    lt,\n    cls1,\n    cls2,\n    ddct,\n    divWidth,\n    appearance\n  ) {\n      if( ( innWidth + xscroll ) < ( newLeft + spanClientRect.width ) )\n             {\n               span.classList.remove( cls1 );\n               if( !prevent ){\n                  this.nonFollowcursor( event, span, cls2 , true );\n                }\n               return true\n            }\n        else{\n            if( newLeft < xscroll ){\n               if( appearance ){\n                  var inn = this.createsupp( span );\n                  inn.style[ lt ] = divWidth * .75 - ( ddct ) + 'px';\n               }\n               span.style[ lt ] = 0;\n            } else{\n              span.style[ lt ] = newLeft + 'px';\n            }\n        }\n  }\n\n  refresh(evt, span) {\n    var tooltip = span.nodeName1.tooltip,\n    config = tooltip.config;\n\n    span.textContent = tooltip.title = span.nodeName1.getAttribute( 'lt-prop-title' );\n\n    this.clear_time( tooltip );\n\n    this.createTooltip( evt, span );\n  }\n\n  clear_time(tooltip, arr) {\n    ( arr || [ 'maxdisp', 'settime', 'bodyTimeout' ] ).forEach( function( item ){\n         clearTimeout( tooltip[ item ] );\n         delete tooltip[ item ];\n    });\n  }\n\n  nonFollowcursor(event, span, position, prevent) {\n        var appearance = span.nodeName1.tooltip.config.appearance == \"callout\", dum;\n        span.classList.remove( 'lyteTooltipHidden' );\n        position = position || span.nodeName1.tooltip.config.position || ( /focus/i.test( ( event.type || 'focus' ) ) ? 'bottom' : \"\" );\n        dum = position || \"bottom\";\n        if( appearance ){\n          span.classList.add( \"lyte\" + dum[ 0 ].toUpperCase() + dum.slice( 1 ) )\n        }\n        if( !span._callbackHandled ) {\n                this.tooltipOpenCallback( span.nodeName1, span );\n                span._callbackHandled = true;\n            } \n         $L.fastdom.measure(function(){\n              // calculating page off set \n            if(  !( span.nodeName1 || {} ).tooltip ){\n              return;\n            }\n            var xscroll = ( window.pageXOffset || document.documentElement.scrollLeft ) * ( this._dir ? -1 : 1 );\n            var yscroll = window.pageYOffset || document.documentElement.scrollTop, innWidth = window.innerWidth,  innHeight= window.innerHeight;  \n            var spanClientRect = span.getBoundingClientRect();\n            var nodeClientRect = span.nodeName1.getBoundingClientRect();\n            var left = this.rtlfunc( 'left', nodeClientRect, innWidth ) + xscroll;\n            var topPos = nodeClientRect.top + yscroll;\n            var __config = span.nodeName1.tooltip.config,\n            margin = Math.min( parseInt( __config.margin ), 20 );\n            var toolwid = span.offsetWidth,\n            tool_hgt = span.offsetHeight;\n            var divWidth = nodeClientRect.width;\n            var wid = nodeClientRect.height;\n            var lt = this.rtlfunc( 'left' ),\n            sty = window.getComputedStyle( span ),\n            isContentBox = /content-box/.test( sty.boxSizing ),\n            padLeft = isContentBox ? parseFloat( sty.paddingLeft ) : 0,\n            padRight = isContentBox ? parseFloat( sty.paddingRight ) : 0,\n            padTop = isContentBox ? parseFloat( sty.paddingTop ) : 0,\n            padBottom = isContentBox ? parseFloat( sty.paddingBottom ) : 0,\n            ddct, calloutstyle,\n            $span = $L( span );\n            if( appearance ) {\n                calloutstyle = window.getComputedStyle( span, ':before' );\n                ddct = parseFloat( calloutstyle.getPropertyValue( 'width' ) ) / 2 * 1.414;\n                if( isNaN( ddct ) || !ddct ) {\n                    ddct = parseFloat( window.getComputedStyle( span, position == \"left\" ? \":before\" : \":after\" ).getPropertyValue( 'border-left-width' ) )\n                }\n            } else {\n                ddct = 0;\n            }\n            switch(position.toLowerCase())\n              {\n                case 'right' :\n                 {\n                    left += ddct;\n                    var newLeft = left + divWidth + margin;\n                    span.style.top=( topPos + wid / 2 - tool_hgt / 2 )+'px';\n                    if( ( innWidth + xscroll ) < ( newLeft + spanClientRect.width ))\n                      {\n                         if( !prevent ){\n                            if( innWidth - ( left + divWidth - xscroll - ddct ) < ( left - ddct - xscroll ) ){\n                                span.classList.remove('lyteRight');\n                                this.nonFollowcursor.call( this, event, span,'left', true );\n                                break;\n                            }\n                        }\n                        span.style[ lt ] = newLeft + 'px';\n                        span.style.width = ( innWidth - newLeft - padLeft - padRight ) + 'px';\n                        // span.style.top = this.calculateHeight( spanClientRect, textWid, span, padTop, padBottom ) + 'px';\n                        $L.fastdom.mutate( function(){\n                          $L.fastdom.measure( function(){\n                              span.style.top = ( topPos + wid / 2 - span.offsetHeight / 2 ) + 'px';\n                          })\n                        })\n                      }\n                    else{\n                      span.style[ lt ] = newLeft + 'px';\n                    }\n                    break; \n                 }\n                 case 'left' :\n                   {\n                      left -= ddct;\n                      var newLeft = left - margin - toolwid;\n                      span.style.top=( topPos + wid / 2 - tool_hgt / 2 ) + 'px';\n                      if( newLeft < xscroll )\n                        {\n                           if( !prevent ){\n                               if( left + ddct - xscroll < innWidth - ( left + ddct - xscroll + divWidth ) ){\n                                 span.classList.remove('lyteLeft');\n                                 this.nonFollowcursor.call(this,event, span,'right', true);\n                                 break;\n                               }\n                            }\n                            span.style[ lt ] = 0 + 'px';\n                            span.style.width = ( left - xscroll - padLeft - padRight ) + 'px';\n                            // span.style.top = this.calculateHeight( spanClientRect, textWid, span, padTop, padBottom ) + 'px';\n                             $L.fastdom.mutate( function(){\n                                $L.fastdom.measure( function(){\n                                    span.style.top = ( topPos + wid / 2 - span.offsetHeight / 2 ) + 'px';\n                                })\n                              })\n                        }\n                      else{\n                           span.style[ lt ] = newLeft + 'px';\n                      }  \n                      break;  \n                   }\n                case 'bottom' :\n                  {\n                    topPos += ddct;\n                    var newTop = ( topPos + wid + margin ), newLeft = left + divWidth / 2 - toolwid / 2;\n                    if( ( yscroll + innHeight ) < ( newTop + tool_hgt ) ) {\n                        span.classList.remove('lyteBottom');\n                         if( !prevent ){\n                            this.nonFollowcursor.call(this,event, span,'top', true);\n                            break;\n                          }\n                    }\n                    newLeft = this.horicheck( newLeft, xscroll, innWidth, spanClientRect, span, nodeClientRect, lt, ddct, appearance );\n                    span.style[ lt ] = newLeft + 'px';\n                    span.style.top = newTop + 'px';     \n                    break;  \n                  }     \n                case 'top' :\n                  {\n                    topPos -= ddct;\n                    var newTop = topPos - margin - tool_hgt, newLeft = left + divWidth / 2 - toolwid / 2;\n                    if( newTop < yscroll ) {\n                       span.classList.remove('lyteTop');\n                        if( !prevent ){\n                          this.nonFollowcursor.call(this,event, span,'bottom', true);\n                          break;\n                        }\n                    } \n                    newLeft = this.horicheck( newLeft, xscroll, innWidth, spanClientRect, span, nodeClientRect, lt, ddct, appearance );\n                    span.style[ lt ] = newLeft + 'px';\n                    // span.style.top = newTop + 'px';   \n                    $L.fastdom.mutate( function(){\n                          $L.fastdom.measure( function(){\n                              span.style.top = ( topPos - margin - span.offsetHeight ) + 'px';\n                          })\n                        })\n                    break;     \n                  }\n                 case 'bottomright' :\n                  {\n                    topPos += ddct;\n                    var newLeft = left + divWidth * .75 - ( appearance ? parseFloat( calloutstyle[ lt ] ) + ddct : 0.2 * toolwid ),\n                    newTop = topPos + wid + margin;\n                    if( this.rightalign( innWidth, xscroll, newLeft, spanClientRect, span, prevent, event, lt, 'lyteBottomright', 'bottomleft', ddct, divWidth, appearance ) ){\n                       $span.removeClass('lyteBottomright');\n                       break;\n                    }     \n                   if( ( innHeight + yscroll ) < ( newTop + spanClientRect.height ) ) \n                       {\n                         $span.removeClass('lyteBottomright');\n                         if( prevent ){\n                            $span.addClass( 'lyteTopright' ).css( 'top', ( topPos - ddct - tool_hgt - margin ) );\n                         } else {\n                            this.nonFollowcursor( event, span,'topright', true );\n                         }\n                         break\n                       }\n                     else{\n                        span.style.top = newTop + 'px';\n                     }  \n                    break; \n                  }\n                case 'topright' :\n                  {\n                    topPos -= ddct;\n                    var newLeft = left + divWidth * .75 - ( appearance ? parseFloat( calloutstyle[ lt ] ) + ddct : 0.2 * toolwid ),\n                    newTop = topPos - tool_hgt - margin;\n                    \n                    if( this.rightalign( innWidth, xscroll, newLeft, spanClientRect, span, prevent, event, lt, 'lyteTopright', 'topleft', ddct, divWidth, appearance ) ){\n                       $span.removeClass( 'lyteTopright' );\n                       break;\n                    } \n\n                    if( newTop < yscroll ){\n                       $span.removeClass( 'lyteTopright' );\n                       if( prevent ){\n                          $span.addClass( 'lyteBottomright' ).css( 'top', topPos + ( 2 * ddct ) + wid + margin );\n                       } else {\n                          this.nonFollowcursor( event, span, 'bottomright', true );\n                       }\n                    } else {\n                       $span.css( 'top', newTop );\n                    }\n                    break;     \n                 }\n                case 'bottomleft' :\n                   {\n                     topPos += ddct;\n                     var newLeft = left + divWidth *.25 - ( appearance ? parseFloat( calloutstyle[ lt ] ) : 0.8 * toolwid ) + 'px',\n                     newTop =(topPos+wid+margin)+'px';\n                     if(parseInt(newLeft) < xscroll)\n                        {\n                            span.classList.remove('lyteBottomleft');\n                            if( !prevent ){\n                                this.nonFollowcursor.call(this,event, span,'bottomright', true);\n                            }\n                            break;\n                        }\n                    else{\n                        span.style[ lt ] = newLeft;\n                    } \n                    if(( innHeight + yscroll ) < ( parseInt( newTop ) + tool_hgt ) )\n                        {\n                            $span.removeClass( 'lyteBottomleft' );\n                            if( prevent ){\n                               $span.addClass( 'lyteTopleft' ).css( 'top', ( topPos - ddct - tool_hgt - margin ) );\n                            } else {\n                              this.nonFollowcursor( event, span, 'topleft', true );\n                            }\n                            break\n                       }\n                     else{\n                        span.style.top = newTop;\n                     } \n                     break; \n                    }\n                 case 'topleft' :\n                    {\n                        topPos -= ddct;\n                        var newLeft = left + divWidth *.25 - ( appearance ? parseFloat( calloutstyle[ lt ] ) : 0.8 * toolwid ) + 'px',\n                        newTop = ( topPos - tool_hgt - margin )+'px';\n                        \n                        if(parseInt(newLeft)< xscroll) {\n                            $span.removeClass('lyteTopleft');\n                            if( prevent ){\n                               $span.addClass('lyteTopright').css( lt, left + divWidth * .75 - ( appearance ? parseFloat( calloutstyle[ lt ] ) + ddct : 0.2 * toolwid ) );\n                            } else {\n                               this.nonFollowcursor( event, span,'topright', true);\n                            }\n                            break;\n                        } else {\n                          span.style[ lt ] = newLeft;\n                        } \n                        \n                        if( parseInt( newTop ) < yscroll ) {   \n                            $span.removeClass( 'lyteTopleft' );\n                            \n                            if( prevent ){\n                                $span.addClass( 'lyteBottomleft' ).css( 'top', topPos + wid + margin + 2 * ddct );\n                            } else {\n                                this.nonFollowcursor( event, span, 'bottomleft', true );\n                            }\n                            break;\n                         } else {\n                            $span.css( 'top', newTop );\n                         }\n                        break;    \n                       }\n                default:\n                   {\n                      var tooltop = ddct;\n                      var newLeft = this.rtlfunc.call( this, 'clientX', event, innWidth ) - toolwid / 2 + xscroll;\n                      var newTop = topPos + tooltop + wid + margin;\n                      if( ( innHeight + yscroll ) < ( newTop + tool_hgt ) ) {\n                          span.classList.remove('lyteBottom');\n                          if( !prevent ){\n                            this.nonFollowcursor.call(this,event, span,'top', true);\n                            break;\n                          }\n                       }\n                      newLeft = this.horicheck( newLeft, xscroll, innWidth, spanClientRect, span, nodeClientRect, lt, ddct, appearance );\n                      span.style[ lt ] = newLeft + 'px';\n                      span.style.top = newTop + 'px';   \n                   }\n                }\n               span.style[ this.rtlfunc( 'right' ) ] = 'auto'; \n\n               var __startclass = __config.startClass,\n               __endClass = __config.endClass,\n               __animationClass = __config.animationClass;\n\n               if( __startclass ){\n                  var $span = $L( span ).addClass( __startclass );\n\n                  window.requestAnimationFrame( function(){\n                    $span.addClass( __animationClass );\n                    window.requestAnimationFrame( function(){\n                      window.requestAnimationFrame( function(){\n                        $span.addClass( __endClass );\n                      });\n                    });\n                  });\n               }\n          }.bind(this))\n    // }.bind(this))\n  }\n\n  horicheck(\n    newLeft,\n    xscroll,\n    innWidth,\n    spanClientRect,\n    span,\n    nodeClientRect,\n    lt,\n    ddct,\n    appearance\n  ) {\n      var flag, flag2\n      if( newLeft < xscroll ){\n         newLeft = xscroll;\n         flag = true\n      }else if( innWidth + xscroll < newLeft + spanClientRect.width ) {\n          newLeft = innWidth - spanClientRect.width + xscroll;\n          flag2 = true;\n      }\n\n       if( ( flag || flag2 ) && appearance ){\n         var inn = this.createsupp( span ), nodeleft = this.rtlfunc( 'left', nodeClientRect, innWidth ),\n         leftVal;\n         if( flag ){\n            var lft = this.rtlfunc( 'left', nodeClientRect, innWidth );\n            inn.style[ lt ] =  ( Math.min( spanClientRect.width, nodeClientRect.width ) + Math.min( lft , 0 ) )/ 2 + Math.max( 0, lft ) + 'px';\n         } else {\n            var rgt = innWidth - this.rtlfunc( 'right', nodeClientRect, innWidth );\n            inn.style[ lt ] = spanClientRect.width - ( Math.max( 0 , rgt ) + ( Math.min( spanClientRect.width, nodeClientRect.width ) + Math.min( rgt, 0 ) ) / 2 ) + 'px';\n         }\n      }\n      return newLeft\n  }\n\n  closeAllTooltip(current, frm_down) {\n\n    var tooltips = this.data.tooltips;\n\n    for( var key in tooltips ){\n      var item = tooltips[ key ];\n      if( item.nodeName1 != current ){\n          var tooltip = item.nodeName1.tooltip;\n\n          if( !tooltip ){\n             this.removeTooltip( item );\n             continue;\n          }\n\n          if( frm_down && !tooltip.config.hideOnClick ){\n             continue;\n          }\n\n          if( tooltip.bodyTimeout == void 0 ){\n            tooltip.bodyTimeout = setTimeout( this.removeTooltip.bind( this ), tooltip.config.hidedelay, item );\n          }\n      }\n    }\n  }\n\n  removeTooltip(span) {\n        if( span.parentNode == document.body ){\n            var node = span.nodeName1;\n              \n            if( !node ){\n               return;\n            }\n\n            var tooltip = node.tooltip || {},\n            config = tooltip.config || {},\n            __endClass = config.endClass || \"\",\n            __reuse = config.reuse,\n            fn = function(){\n                if( __reuse ){\n                  var span_style = span.style;\n\n                  span_style.opacity = \"0\";\n                  span_style.pointerEvents = \"none\";\n                } else {\n                  document.body.removeChild( span );\n                }\n                clearTimeout( span.__animetime );\n\n                $L( span ).off( 'transitionend' );\n            };\n\n            this.clear_time( tooltip );\n\n            if( this.prevTooltipNode == node ){\n               delete this.prevTooltipNode;\n            }\n\n            delete node.tooltipSpan;\n            delete node.tooltip;\n            delete span.nodeName1;\n\n            node.setAttribute( 'aria-expanded', \"false\" );\n\n             if( __endClass ){\n                $L( span ).removeClass( __endClass ).on( 'transitionend', fn );\n                span.__animetime = setTimeout( fn, config.maxAnimationLimit );\n             } else {\n                fn();\n             }\n\n            this.tooltipCloseCallback( node );\n            delete this.data.tooltips[ span._random ];\n        }\n  }\n\n  hover_process(node) {\n    var tooltip = ( node || {} ).tooltip;\n    if( tooltip ){\n        this.clear_time( tooltip );\n    }\n  }\n\n  mousemove(event) {\n        if( this._mousedownFlag ) {\n          return\n        }\n\n        if( this.__dragging ){\n            if( event.buttons ){\n              return;\n            }\n            delete this.__dragging;\n        }\n\n        var nodeName1 = event.target.correspondingElement || event.target;\n\n        while(nodeName1 && nodeName1.tagName != 'BODY' && nodeName1 != document && nodeName1.tagName != 'HTML' ){\n            \n            var title = nodeName1.getAttribute ? nodeName1.getAttribute( 'lt-prop-title' ) : \"\",\n            Jnode = $L( nodeName1 );\n\n            if( Jnode.hasClass( 'lyteTooltip' ) ){\n              var target_node = nodeName1.nodeName1 || {};\n              if( ( ( target_node.tooltip || {} ).config || {} ).hidedelay ){\n                this.hover_process( target_node );\n                return this.closeAllTooltip( target_node );\n              }\n            }\n\n            if( Jnode.hasClass( this.data.ltPropIgnoreClass ) ){\n                delete this.prevTooltipNode;\n                nodeName1 = document.body;\n                break;\n            }\n\n            if( title ){\n\n                  if( nodeName1.getAttribute( 'title' ) ){\n                      nodeName1.removeAttribute( 'title' );\n                  }\n\n                  nodeName1.tooltip = nodeName1.tooltip || {};\n\n                  nodeName1.tooltip.config = $L.extend( { reuse : false, position : '', appearance : 'callout', margin : 0, showdelay : 0, hidedelay : 0, maxdisplaytime : 5000, keeptooltip : false, aria : false, hideOnClick : true, startClass : \"\", endClass : \"\", animationClass : \"\", maxAnimationLimit : 2000 }, this.data.ltPropTooltipConfig || {} );\n                  nodeName1.tooltip.title = title;\n\n                  this.propertySetting( nodeName1 );\n\n                  var tooltip = nodeName1.tooltip,\n                  __config = tooltip.config,\n                  is_reuse = __config.reuse;\n\n                  if( this.prevTooltipNode != nodeName1 && ( !tooltip.tooltipSpan || is_reuse ) ){\n                      this.prevTooltipNode = nodeName1;\n                      var is_exist = this.__reuse,\n                      is_really_exist = is_reuse && is_exist,\n                      span = is_really_exist ? is_exist : document.createElement( 'span' ),\n                      Jobj = $L( span ),\n                      toolclass = Jnode.attr( 'lt-prop-tooltip-class' ),\n                      ltPropId = __config.id || this.getData( 'ltPropId' ), \n                      ltPropClass = this.getData( 'ltPropClass' ),\n                      randomId = Date.now() + 'lytetooltip';\n\n                      if( is_exist ){\n                          this.removeTooltip( span );\n                      }\n\n                      this.data.tooltips[ randomId ] = span;\n                      span._random = randomId;\n\n                      if( !is_exist ){\n                        if( is_reuse ){\n                           this.__reuse =  span;\n                        }\n                      } else {\n                        Jobj.attr( 'class', 'lyteTooltip' );\n                      }\n\n                      if( ltPropId ) {\n                         Jobj.attr( 'id', ltPropId );\n                      }\n                      if( ltPropClass ) {\n                         Jobj.addClass( ltPropClass );\n                      }  \n\n                      !is_really_exist && Jobj.addClass( 'lyteTooltip lyteTooltipHidden' );\n                      if( this._dir ) {\n                         Jobj.addClass( 'lyteRTL' );\n                      }\n\n                      Jobj.attr( 'style', Jnode.attr( 'lt-prop-tooltip-style' ) || '' );\n\n                      if( !span.style.borderColor ){ \n                          span.style.borderColor = span.style.backgroundColor;\n                      }\n\n                      if( tooltip.config.appearance == 'callout' && tooltip.config.position != \"followcursor\" ) {\n                        Jobj.addClass( 'lyteTooltipCallout' );\n                        if( !tooltip.config.hideOnClick ){\n                          tooltip.refresh = this.refresh.bind( this );\n                        }\n                      }\n\n                      tooltip.tooltipSpan = span;\n                      span.nodeName1 = nodeName1;\n                      \n                      Jobj.addClass( toolclass || '' );\n\n                      if( tooltip.config.aria ){\n                        var __obj = {\n                          role : \"tooltip\",\n                          \"aria-hidden\" : \"false\"\n                        };\n                        Jobj.attr( __obj );\n\n                        nodeName1.setAttribute( 'aria-expanded', 'true' );\n                      }\n\n                      tooltip.settime = setTimeout( this.createTooltip.bind( this ), tooltip.config.showdelay, event, span, tooltip.config.position == 'followcursor' );\n                      span.textContent = tooltip.title; \n\n                      !is_really_exist && window._lyteUiUtils.appendChild( document.body, span );\n                  } else if( tooltip.config.position == 'followcursor' && this.prevTooltipNode == nodeName1 && tooltip.tooltipSpan ){\n                      var span = tooltip.tooltipSpan;\n\n                      $L( span ).css({\n                         opacity : \"\",\n                         pointerEvents : \"\"\n                      });\n\n                      this.clear_time( tooltip, [ 'maxdisp', 'settime' ] );\n\n                      if( !span._callbackHandled ){\n                        tooltip.settime = setTimeout( this.createTooltip.bind( this ), tooltip.config.showdelay, event, span, true );\n                      } else {\n                        this.followcursor( event, span );\n                      }\n                  } else if( tooltip.tooltipSpan && tooltip.tooltipSpan.style.display == 'none' ) {\n                      \n                      $L( tooltip.tooltipSpan ).css({\n                         display : \"\",\n                         opacity : \"\",\n                         pointerEvents : \"\"\n                      });\n\n                      this.clear_time( tooltip );\n                      \n                      tooltip.settime = setTimeout( this.createTooltip.bind( this ),  tooltip.config.showdelay,event,  tooltip.tooltipSpan,  tooltip.config.position == 'followcursor' );\n                  } else {\n                      this.prevTooltipNode = nodeName1;\n                  } \n                  this.closeAllTooltip( nodeName1 );    \n                  break;       \n                }\n              else {\n                nodeName1 = nodeName1.parentNode;\n              }  \n        }\n      if(nodeName1 && ( [ 'BODY', 'HTML' ].indexOf( nodeName1.tagName ) != -1 ) && this.prevTooltipNode != nodeName1 ){\n          delete this.prevTooltipNode;\n          this.closeAllTooltip();\n      } \n  }\n\n  static observers() {\n    return {\n      aria_obs : function( arg ){\n          if( arg.newValue ){\n             this.bind_aria();\n          } else {\n             this.remove_aria();\n          }\n      }.observes( 'ltPropAria' )\n    };\n  }\n}\n\n( function(){\n   var doc = document,\n   __fn = function(){\n      var name = 'lyte-tooltip';\n\n      if( !doc.querySelector( name ) ){\n          window._lyteUiUtils.appendChild( doc.body, doc.createElement( name ) );\n      }\n   };\n\n   if( /complete|interactive/i.test( doc.readyState ) ){\n      __fn();\n   } else {\n      doc.addEventListener( 'DOMContentLoaded', __fn );\n   }\n\n})();\n\n\n/**\n * @syntax nonYielded\n * <lyte-tooltip></lyte-tooltip>\n */\nexport { LyteTooltipComponent };\n","import { prop } from \"@slyte/core\";\nimport { Component } from \"../component.js\";\n\n/**\n * This component is used to append a dom anywhere in the document\n * @component lyte-wormhole\n * @version 2.2.6\n * @methods onBeforeAppend,onAppend\n */\n\n\nclass LyteWormholeComponent extends Component {\n    constructor() {\n        super();\n    }\n\n    data() {\n\t\treturn {\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropQuery\n\t\t\t * @version 2.2.6\n\t\t\t */\n\t\t\t'ltPropQuery' : prop( 'string' ),\n\n\t\t\t'ltPropAppendOnCreation': prop( 'boolean', { 'default': true } ),\n\n\t\t\t'ltPropAppend': prop( 'boolean', { 'default': false } ),\n\n\t\t\t'ltPropShow' : prop('boolean' , {\t'default' : false }),\n\n\t\t\t'ltPropFocusOnClose':  prop('boolean' , {\t'default' : false }),\n\n\t\t\t'stackMap': prop('object',{ default: {\n\t\t\t\t'LYTE-MODAL': 'modalStack',\n\t\t\t\t'LYTE-BETA-MODAL': 'betaModalStack',\n\t\t\t\t'LYTE-BETA-POPOVER': 'betaPopoverStack',\n\t\t\t\t'LYTE-POPOVER': 'popoverStack',\n\t\t\t\t'LYTE-MESSAGEBOX': 'messageboxStack',\n\t\t\t\t'LYTE-ALERT': 'alertStack',\n\t\t\t\t'LYTE-COLORBOX': 'colorboxStack'\n\t\t\t}})\n\t\t};\n\t}\n\n    didDestroy() {\n\t\tvar utilObj = this.createUtilObj(this);\n\t\tthis.handleRemovalFromStack( utilObj );\n\n\t\tthis.parent = null;\n\t\tif( window._lyteUiUtils && \n\t\t\t\twindow._lyteUiUtils.popupStack && \n\t\t\t\t\twindow._lyteUiUtils.popupStack.globalStack && \n\t\t\t\t\t\twindow._lyteUiUtils.popupStack.globalStack.length <= 0 ){\n\t\t\t\t\t\t\n\t\t\twindow._lyteUiUtils.popupStack=null;\n\t\t}\n\t}\n\n    appendContent() {\n\t\tvar ret, \n\t\toutlet = this.data.ltPropQuery ? document.querySelector( this.data.ltPropQuery ) : document.body;\n\n\t\tif( !outlet ) {\n\t\t\tconsole.error( 'Provide valid outlet to append' );\n\t\t\treturn;\n\t\t}\n\n\t\tif( this.getMethods( 'onBeforeAppend' ) && this.executeMethod( 'onBeforeAppend', this.$node, outlet ) == false ) {\n\t\t\treturn;\n\t\t}\n\t\tthis.parent = this.$node.parentElement;\n\t\twindow._lyteUiUtils.appendChild( outlet, this.$node );\n\t\tthis.appended = true;\n\n\t\tif( this.getMethods( 'onAppend' ) ) {\n\t\t\tthis.executeMethod( 'onAppend', this.$node, outlet )\n\t\t}\n\t}\n\n    bringContentBack() {\n\t\twindow._lyteUiUtils.appendChild( this.parent, this.$node );\n\t}\n\n    createUtilObj(wormhole) {\n\t\tvar utilObj={};\n\n\t\tif(wormhole.parent){\n\t\t\tutilObj.parentElement=wormhole.parent;\n\t\t} else {\n\t\t\tutilObj.parentElement=wormhole.$node.parentElement;\n\t\t}\n\t\tutilObj.focusedElement=document.activeElement;\n\t\tutilObj.childElement = wormhole.$node;\n\n\t\treturn utilObj;\n\t}\n\n    popUtilObj(utilObj, stackName, wormhole) {\n        var lyteSelf = this;\n        if( !utilObj || !window._lyteUiUtils || !window._lyteUiUtils.popupStack || !window._lyteUiUtils.popupStack[stackName]){\n\t\t\treturn;\n\t\t}\n\n        if( window._lyteUiUtils.popupStack[stackName].length>=1){\n\t\t\twindow._lyteUiUtils.popupStack[stackName].forEach(function(ele,ind){\n\t\t\t\t\tif(ele.parentElement==utilObj.parentElement){\n\t\t\t\t\t\tlyteSelf.$addon.arrayUtils( window._lyteUiUtils.popupStack[stackName], 'removeAt' , ind , 1 );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t}.bind(wormhole));\n\t\t}\n    }\n\n    handleInsertionIntoStack(utilObj) {\n\n\t\t\tif( !utilObj || !utilObj.parentElement || !utilObj.parentElement.tagName ){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar tagName = utilObj.parentElement.tagName;\n\t\t\tvar stackName = this.getData('stackMap')[tagName];\n\n\t\t\tthis.$addon.arrayUtils( window._lyteUiUtils.popupStack.globalStack, 'push', utilObj);\n\n\t\t\tif( stackName ){\n\t\t\t\tthis.$addon.arrayUtils( window._lyteUiUtils.popupStack[stackName], 'push', utilObj);\n\t\t\t}\n\t}\n\n    handleRemovalFromStack(utilObj) {\n        var lyteSelf = this;\n\n        if( !window._lyteUiUtils || !window._lyteUiUtils.popupStack || !window._lyteUiUtils.popupStack.globalStack ){\n\t\t\treturn;\n\t\t}\n        if( !utilObj || !utilObj.parentElement || !utilObj.parentElement.tagName ){\n\t\t\treturn;\n\t\t}\n\n        var tagName = utilObj.parentElement.tagName;\n        var stackName = this.getData('stackMap')[tagName];\n        var lastActiveElement;\n\n        if(window._lyteUiUtils.popupStack.globalStack.length >= 1){\n\n\t\t\tif( stackName ){\n\t\t\t\tthis.popUtilObj( utilObj, stackName, this );\n\t\t\t}\n\n\t\t\tvar focusElement, changeFocus=true;\n\t\t\twindow._lyteUiUtils.popupStack.globalStack.forEach(function(ele,ind){\n\t\t\t\tif(ele.parentElement==utilObj.parentElement){\n\t\t\t\t\tif(ind<window._lyteUiUtils.popupStack.globalStack.length-1){\n\t\t\t\t\t\tchangeFocus=false;\n\t\t\t\t\t\twindow._lyteUiUtils.popupStack.globalStack[ind+1].focusedElement =\t_lyteUiUtils.popupStack.globalStack[ind].focusedElement;\n\t\t\t\t\t}\n\t\t\t\t\tfocusElement = lyteSelf.$addon.arrayUtils( window._lyteUiUtils.popupStack.globalStack , 'removeAt' , ind , 1 );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}.bind(this));\n\n\t\t\tif(focusElement && focusElement[0]){\n\t\t\t\tlastActiveElement= focusElement[0].focusedElement;\n\t\t\t}\n\t\t\tif(changeFocus && lastActiveElement && this.getData('ltPropFocusOnClose')){\n\t\t\t\t\tlastActiveElement.focus();\t\n\t\t\t}\n\t\t}\n    }\n\n    static observers() {\n        return {\n            initFunc: function() {\n\n                if(!window._lyteUiUtils.popupStack){\n                    window._lyteUiUtils.popupStack = {\n                        globalStack:[],\n                        modalStack:[],\n                        betaModalStack:[],\n                        betaPopoverStack:[],\n                        popoverStack:[],\n                        alertStack:[],\n                        messageboxStack:[],\n                        colorboxStack:[]\n                    };\n                }\n\n                var utilObj = this.createUtilObj(this);\n\n                if(this.$node.getData('ltPropShow')){\n                    this.handleInsertionIntoStack( utilObj );\n                }\n                else {\n                    this.handleRemovalFromStack( utilObj );\n                }\n\n            }.observes( 'ltPropQuery','ltPropShow' ).on('init'),\n\n            didConnectFunc :function(){\n                var appendOnCreation = this.getData( 'ltPropAppendOnCreation' );\n\n                if( !appendOnCreation ) {\n                    return ;\n                }\n\n                // this.appendContent();\n                this.$node.ltProp( 'append', true );\n            }.observes( 'ltPropQuery' ).on( 'didConnect' ),\n\n            appendObserver: function() {\n                var append = this.getData( 'ltPropAppend' );\n\n                if( append ) {\n                    this.appendContent();\n                }\n                else {\n                    this.bringContentBack();\n                }\n            }.observes( 'ltPropAppend' )\n        };\n    }\n}\n\n/**\n * @syntax yielded\n * <lyte-wormhole>\n * \t  <template is = \"registerYield\" yield-name = \"lyte-content\">\n * \t\t Some wormhole content\n *\t  </template>\n * </lyte-wormhole>\n */\n\nexport { LyteWormholeComponent };","import { Mixin } from \"@slyte/core\";\nimport $L from \"@zoho/lyte-dom\";\n\nclass LyteTableSortableMixin extends Mixin {\n     rowMouseDown(evt) {\n                  \n            var _this = this ,\n                tags = _this.data.ltPropTags,\n                tr = evt.target.closest(tags.tr) , \n                tbody = tr.closest(tags.tbody);\n            if( tbody != void 0 ){\n                var table = tbody.closest('lyte-table'),\n                    index = Array.from( tr.parentElement.children ).indexOf( tr ),\n                    actual_index = index ,\n                    cur_index = actual_index  ,\n                    data = _this.data.ltPropData , \n                    isFirst = true , \n                    trTransform = tr.style.transform ,\n                    content = _this.data.ltPropContent ,\n                    boundary = _this._boundary , \n                    isTouch = Boolean(evt.touches),\n                    hasContainment = Boolean(_this.data.ltPropContainment) ,\n                    containElem = hasContainment ? $L(_this.$node).find(_this.data.ltPropContainment)[0] : undefined,\n                    containElemClient = containElem != void 0 ? containElem.getBoundingClientRect() : undefined , \n                    placeholder = $L(this.$node).find( '.lyteTableSortablePlaceholder' ).get(0),\n                    outOfBound = false, yRelatedToElement , reachedTop , reachedEnd , diff = void 0;\n\n                if(tr.parentElement.tagName.toLowerCase() == _this.data.ltPropTags.tbody){\n                    if( this.getMethods( 'onRowSelect' ) ){\n                        let ret = this.executeMethod( 'onRowSelect' , evt  , data[actual_index].index  , actual_index , _this.$node );\n                        if( ret === false ){\n                            return;\n                        }\n                    } \n\n                    evt.preventDefault();\n\n                    placeholder.classList.remove( 'lyteTableSortablePlaceholderHidden' );\n                \n                    var findElement = function ( isPrev , isMouseUp ){\n                        if( isMouseUp ){\n                            let arr = Array.from(tbody.children);\n                            for( let i = 0 ; i < arr.length ; i++ ){\n                                let cur = arr[i];\n                                if( cur.classList.contains('lyteTableRowSorting') ){\n                                    return i;\n                                }\n                            }\n                        }else{\n                            let curIndex =_this.data.ltPropData[cur_index].index ,\n                                findIndex = isPrev ? getIndex(  curIndex == 0 ? data.length-1 : curIndex - 1 ) :\n                                                     curIndex == data.length-1 ? curIndex == content.length-1 ? undefined : 0 : getIndex(curIndex + 1 ),\n                                arr = Array.from( tbody.children );\n                            if(findIndex == undefined){\n                                return;\n                            }\n                            for( let i = 0, j = 0 ; i < arr.length ; i ++ ){\n                                let cur = arr[i];\n                                if( !(cur.classList.contains('dummy')) ){\n                                    if( j == findIndex ){\n                                        return arr[i];\n                                    }\n                                    j++\n                                }\n                            }\n                        }\n                    },\n                    makeElementDraggable = function(){\n                        var width = []\n                        Array.from( tr.children ).forEach( function(td){\n                            width.push( window.getComputedStyle(td).width );\n                        }); \n                        tr.classList.add('lyteTableRowSorting'); \n                    },\n                    getIndex = function( index ){\n                        var find = function(obj){\n                            return obj.index === index;\n                        }\n                        return _this.data.ltPropData.findIndex(  find );\n                    },\n                    checkLimit = function (num){\n                        return 0 <= num && num < _this.data.ltPropData.length ;\n                    },\n                    changePlaceHolder = function( _tr ){\n                        placeholder.style.transform = \"\";\n                        if( _tr.style.transform ){\n                            placeholder.style.transform = _tr.style.transform;\n                        }\n                        placeholder.style.top = _tr.offsetTop + \"px\";\n                        placeholder.style.left = _tr.offsetLeft + \"px\";\n                        placeholder.style.width = _tr.offsetWidth + \"px\";\n                        placeholder.style.height = _tr.offsetHeight + \"px\";\n                    };\n                \n                    changePlaceHolder( tr );\n                    makeElementDraggable();\n                \n                    var initialY = isTouch ? evt.touches[0].clientY : evt.clientY;\n                         \n                    var mouseup = function(event){\n                        let currentIndex = findElement( false , true ) ,\n                        scrollTop = _this.scrollDiv.scrollTop;\n                        evt.preventDefault();\n\n                        placeholder.classList.add( 'lyteTableSortablePlaceholderHidden' );\n                    \n                            if(_this.getMethods( 'onBeforeRowDrop' )){\n                                var ret = _this.executeMethod( 'onBeforeRowDrop' , event , currentIndex , data[currentIndex].index , _this.$node  );\n                            } \n\n                            if(ret === false){\n                                let removeIndex = cur_index , \n                                    cur_data = Object.assign( {} , data[removeIndex] );\n\n                                _this.removeRow(data[removeIndex].index);\n                                _this.insertRow(data[actual_index].index , cur_data.body);\n\n                                if( _this.data.ltPropContent.length - 2 == _this._boundary.bottom ){\n                                    _this.scrollToRecord( data[removeIndex].index , true , scrollTop );\n                                }\n                            }\n                            tr.style.transform = trTransform;\n                            tr.classList.remove('lyteTableRowSorting')\n\n                            _this.getMethods( 'onRowDrop' ) && _this.executeMethod( 'onRowDrop' , event , currentIndex , data[currentIndex].index , _this.$node );\n                        \n                            let elem = tbody.children[getIndex(actual_index)];\n                            if(elem){\n                                elem.style.top = \"\"; elem.style.right = \"\";\n                            }\n                        \n                        \n                        document.removeEventListener( isTouch ? 'touchmove' : 'mousemove', mousemove)\n                        document.removeEventListener( isTouch ? 'touchend' : 'mouseup', mouseup);\n                    },\n\n                    parseNum = function (number){\n                        let match = number.match(/-?\\d+(\\.\\d+)?/);\n                        return match ? parseFloat(match[0]) : 0\n                    },\n                    isInRange = function( tr , y , isUp){\n                        let client = tr.getBoundingClientRect() ,\n                            topCheck = containElemClient.top < client.top ,\n                            bottomCheck = ( client.top + client.height ) < (containElemClient.top + containElemClient.height );\n\n                        if( isUp == void 0 ){ return topCheck && bottomCheck }\n\n                        reachedTop = false; reachedEnd = false;\n\n                        if( !topCheck ) { \n                             reachedTop = true; }\n                        else if( !bottomCheck ) { reachedEnd = true; }\n\n                        if( reachedTop ){ \n                            topCheck = !isUp && ( ( containElemClient.top < y ) && ( y < containElemClient.top + containElemClient.height-diff ) ) && diff >= 0;\n                        }else if( reachedEnd ){\n                            bottomCheck = isUp && ( containElemClient.top < y && y < (containElemClient.top + containElemClient.height ) ) && diff <= 0\n                        }\n                         return topCheck && bottomCheck \n\n                    },\n                    fixTop = function ( isUp , returnBoundElem , getDiff){\n                        var trClient = tr.getBoundingClientRect(),\n                            _diff , transformY ,\n                            top = _this._top , bottom = _this._bottom , \n                            contentLength = data.length;\n\n                    \n                        _diff = isUp ? containElemClient.top - trClient.top : \n                                     (containElemClient.top + containElemClient.height) - (trClient.top + trClient.height);\n                        if( getDiff === true ){ \n                            diff = -_diff;\n                            return;\n                        };\n                        transformY = parseNum( tr.style.transform );\n                        tr.style.transform = \"\"; _this.transform( true , tr , transformY + _diff );\n                        trClient = tr.getBoundingClientRect();\n\n\n                        if( !returnBoundElem ) { return; }\n\n                        let reachedEnd = false;\n\n                        for (let i = isUp ? top : bottom ; isUp ? i < (top+contentLength) : (reachedEnd ? i > bottom + 1 : i >= 0) ; isUp ? i++ : i--) {\n                            i = isUp ? i%contentLength : i;\n                            const element = tbody.children[i] ,\n                                  elemClient = element.getBoundingClientRect();\n\n                            if(isUp ? ( elemClient.top >= ( containElemClient.top ) ) : (elemClient.top < (containElemClient.top+containElemClient.height))){\n                                if( isUp ? trClient.top <= elemClient.top : trClient.top >= elemClient.top ){\n                                    if(cur_index != i){\n                                        return i;\n                                    }\n                                    return;\n                                 }\n                            }\n\n\n                            if( !isUp && i == 0 ){\n                                reachedEnd = true;\n                                i = contentLength;\n                            }\n                        }\n                    \n                    }\n                \n                    var mousemove = function( event ){\n                        isTouch ? null : event.preventDefault();\n                        var y = isTouch ? event.touches[0].clientY : event.clientY ;\n\n                        y = (y < 0) ? 0 : y;\n\n                        var isUp = ( initialY > y) , isDown = ( initialY < y ),\n                            isRange , targetIndex , \n                            neighbour = isDown ? findElement( false ) : isUp ? (cur_index == 0 && boundary.top == 0) ? undefined : findElement( true ) : undefined ,\n                            check = false;\n                        \n                        \n                        \n                        if(isUp || isDown) {\n\n                            let _transform = tr.style.transform;\n                            tr.style.transform = \"translateY(\" + (parseNum(tr.style.transform || \"\") + ( diff != void 0 ? diff : 0 )- (initialY - y)) + \"px)\";\n\n                            if(hasContainment){\n                                diff = diff != void 0 ? diff - (initialY - y) : void 0;\n                                isRange = isInRange( tr , y , isUp );\n                                if(!isRange && !outOfBound){\n                                    fixTop( isUp , false , true );\n                                    check = true ;\n                                }\n                            }\n\n                            tr.style.transform = _transform;\n\n\n                           if( isFirst && _this.getMethods('onRowDragStart') ){\n                               _this.executeMethod( 'onRowDragStart' , event , data[cur_index].index , cur_index , _this.$node );\n                           }\n\n\n                       \n                           if( hasContainment && isRange){\n                               if(  outOfBound ){\n                                   tr.style.transform = \"translateY(\" + (parseNum(tr.style.transform || \"\") + ( diff )) + \"px)\";\n                                   diff = void 0;\n                                   outOfBound = false;\n                               }else{\n                                   tr.style.transform = \"translateY(\" + (parseNum(tr.style.transform || \"\") - (initialY - y)) + \"px)\";\n                                   outOfBound = false;\n                               }\n                           }else if( hasContainment && !outOfBound) {\n                               outOfBound = true ;\n                               targetIndex = fixTop( isUp , true );\n                           }else if(!hasContainment){\n                               tr.style.transform = \"translateY(\" + (parseNum(tr.style.transform || \"\") - (initialY - y)) + \"px)\";\n                           }\n\n                           isFirst = false;  \n                           var trClient = tr.getBoundingClientRect();\n\n                           if( (neighbour != void 0 && !outOfBound) || (targetIndex != void 0) ){\n                                let isExceeds = targetIndex == void 0 ? isDown ? ( neighbour.getBoundingClientRect().top < trClient.top ) :\n                                                isUp ?   ( neighbour.getBoundingClientRect().top > trClient.top ) : false : false;\n\n                                if( (neighbour != void 0 && isExceeds) || (targetIndex != void 0)){\n                                    let curData = Object.assign( {} , _this.data.ltPropData[cur_index] ) , \n                                        heightDiff = parseNum(tr.style.transform) - parseNum(trTransform) + ( (isDown ? -1 : 1 ) * tr.offsetHeight ) ,\n                                        _curIndex = data[cur_index].index, \n                                        hasTarget = targetIndex != void 0;\n\n                                    tr.style.setProperty('transform' , trTransform ) ;\n                                    let scrollTop = _this.scrollDiv.scrollTop;\n\n                                    clearTimeout(_this._ignoreTimeout)\n                                    _this.__ignore_scroll = true;\n\n                                    let insertIndex = ( targetIndex != void 0 ? data[targetIndex].index : isDown ? _curIndex+1 : _curIndex-1  ),\n                                        removeIndex = _curIndex!=void 0 ? _curIndex : cur_index;\n\n                                    _this.removeRow( removeIndex );\n                                    _this.insertRow( insertIndex , curData.body );\n\n\n                                    if( _this.data.ltPropContent.length - 2 == _this._boundary.bottom ){\n                                        if( _this._rowHgt == undefined ){\n                                            _this.__allow_scroll = true;\n                                        }\n                                        _this.scrollToRecord( _curIndex, true , scrollTop );\n                                        _this.__allow_scroll = false;\n                                    }\n\n                                    if( hasTarget ){\n                                        tr.classList.remove('lyteTableRowSorting');\n                                        tr = tbody.children[targetIndex];\n\n                                        changePlaceHolder( tr );\n\n                                        trTransform = tr.style.transform;\n                                        tr.classList.add('lyteTableRowSorting');\n                                        fixTop(isUp);\n                                        cur_index = targetIndex;\n                                    }else{\n                                        tr = tbody.children[getIndex(removeIndex)] ; neighbour = tbody.children[getIndex(insertIndex)];\n\n                                        changePlaceHolder( neighbour );\n\n                                        tr.classList.remove('lyteTableRowSorting');\n                                        neighbour.classList.add('lyteTableRowSorting');\n                                        trTransform = neighbour.style.transform;\n                                        cur_index = isDown ? checkLimit( cur_index + 1 ) ? cur_index + 1 : 0 : checkLimit( cur_index - 1 ) ? cur_index - 1 : data.length-1;\n                                        neighbour.style.transform = \"translateY(\" + ( ( isDown ? ( cur_index == 0 ) : ( cur_index == data.length - 1 ) ) ?  (parseNum(neighbour.style.transform) + heightDiff ) : heightDiff + parseNum(trTransform) ) + \"px)\";\n                                        tr = neighbour; \n                                    }\n\n\n                                    index = isDown ? (index + 1) : (index - 1);\n\n                                    _this._ignoreTimeout = setTimeout(() => {\n                                        _this.__ignore_scroll = false;\n                                    }, 100);\n                                }\n\n                           }\n                        }                   \n                    \n                     initialY =  y;\n                    }\n                \n                    document.addEventListener( 'mousemove' , mousemove , evt );\n                    document.addEventListener( 'mouseup' , mouseup , evt);\n\n                    document.addEventListener( 'touchmove' , mousemove , false );\n                    document.addEventListener( 'touchend' , mouseup , false);\n                }   \n            }\n  \n    }\n}\n\nexport { LyteTableSortableMixin };\n\n","import { Mixin } from \"@slyte/core\";\nimport $L from \"@zoho/lyte-dom\";\n\nclass LyteTableUtilsMixin extends Mixin {\n    getScrollDiv() {\n        return this.$node.getElementsByClassName( 'lyteTableScroll' )[ 0 ];\n    }\n\n    registerInterSection(scrollDiv) {\n         this._intersectionObs = new window.IntersectionObserver( this.intersection.bind( this ), { threshold : [ 1 ], root : scrollDiv } )\n    }\n\n    detectBrowsers() {\n        var userAgent = window.navigator.userAgent\n        this._isSafari = /safari/ig.test( userAgent );\n        this._FF = /firefox/ig.test( userAgent );\n        this._chrome = /Chrome/i.test( userAgent ) && /Google Inc/i.test( window.navigator.vendor );\n    }\n\n    getHeaderWidths(headerCells) {\n        return headerCells.map( function( cell ){\n            return cell.getBoundingClientRect().width;\n        });\n    }\n\n    getTbody() {\n        return this._tbody || this.$node.getElementsByTagName( this.data.ltPropTags.tbody );\n    }\n\n    getThead() {\n        return this.$node.getElementsByTagName( this.data.ltPropTags.thead )[ 0 ];\n    }\n\n    getRows() {\n        return this.$node.getElementsByTagName( this.data.ltPropTags.tr );\n    }\n\n    makeFixedColumn(rows, index, left, value) {\n\n        rows.forEach( function( row ){\n            var _$L = $L( row );\n            if( !_$L.hasClass( 'dummy' ) ) {\n                $L( this.get_nth_cell( row, index ) ).css( left, value ).addClass( 'lyteFixedColumn' );\n            }\n        }.bind( this ) );\n    }\n\n    observe(intersection) {\n        if( !intersection._observed ){\n            this._intersectionObs.observe( intersection );\n            intersection._observed = true;\n        }\n    }\n\n    _setLeftForInterSection(reset) {\n\n        var fastdom = $L.fastdom,\n        __this = this;\n\n\n        fastdom.clear( __this._setmeasure );\n\n        __this._setmeasure = fastdom.measure( function(){\n\n            var __tags = __this.data.ltPropTags,\n            th_rows = Array.from( __this.$node.querySelectorAll( __tags.thead + ' ' + __tags.tr ) ),\n            accumulatedTop = 0;\n\n            th_rows.forEach( function( row, ___index ){\n                var headerCells = __this.get_children( row ),\n                __length = headerCells.length - 1;\n\n                if( __length + 1 ){\n                    var width = __this.getHeaderWidths( headerCells ),\n                    top_to_set = accumulatedTop,\n                    check_right = true,\n                    left = __this.rtlfunc( 'left' );\n\n                    accumulatedTop += row.getBoundingClientRect().height;\n\n                    fastdom.mutate( function(){\n                        var tbody = __this.getTbody(),\n                        rows = ___index ? [] : __this.get_children( tbody ),\n                        intersectionDivs = [],\n                        accumulatedWidth = 0,\n                        accumulatedLeft = 0,\n                        fn = function( cell, index ){\n                            var intersection = cell._horizontalIntersectionDiv,\n                            __index = check_right ? index : ( __length - index );\n\n                            if( intersection ){\n                                var _hasClass = $L( cell ).hasClass( 'lyteTableRightFixed' );\n                                if( ( check_right && _hasClass ) || ( !check_right && !_hasClass ) ){\n                                    intersection = void 0;\n                                }\n                            }\n\n                            if( intersection ){\n                                intersectionDivs.push( intersection );\n                                intersection.style[ left ] = accumulatedLeft + 'px';\n                                cell.style[ left ] = accumulatedWidth + 'px';\n\n                                __this.throwEvent( \"intersectionSet\", cell, left, accumulatedWidth );\n\n                                __this.makeFixedColumn( rows, __index, left, accumulatedWidth );\n\n                                accumulatedWidth += width[ __index ];\n\n                                __this.observe( intersection );\n\n                                if( intersection._sticked && reset ){\n                                    __this.addFixedClass( cell );\n                                }\n                            } else {\n                                accumulatedLeft +=  width[ __index ];\n                            }\n\n                            if( ___index ){\n                                cell.style.top = top_to_set + 'px';\n                            }\n                        };\n\n                        headerCells.forEach( fn );\n                        check_right = false;\n                        left = __this.rtlfunc( 'right' );\n                        accumulatedLeft = 0;\n                        accumulatedWidth = 0;\n\n                        headerCells.reverse().forEach( fn );\n\n                         ___index ? void 0 : ( __this._intersections = intersectionDivs );\n                    });\n                }\n            }); \n        });\n    }\n\n    intersection(intersections) {\n        \n        intersections.forEach( function( intersection ){\n            this.singleIntersection( intersection );\n        }.bind( this ) );\n    }\n\n    singleIntersection(intersection) {\n        var cell = intersection.target._cell,\n        __this = this,\n        ns = intersection.intersectionRatio ? 'processUnfix' : 'processFix';\n\n        __this._fixedWidth = __this._fixedWidth || 0;\n        __this._rightFixedWidth = __this._rightFixedWidth || 0;\n        __this[ ns ]( cell, intersection );\n    }\n\n    common_fn(cell, intersection, __remove) {\n        var __this = this;\n\n        __this[ __remove ? 'removeFixedClass' : 'addFixedClass' ]( cell );\n        intersection.target._sticked = !__remove;\n        __this[ __remove ? 'callUnfix' : \"callFix\" ]( cell );\n\n        if( cell.parentNode.previousElementSibling ){\n            return;\n        }\n\n        $L.fastdom.measure( function(){\n            var bcr = cell._bcr || cell.getBoundingClientRect(),\n            ns = cell.classList.contains( 'lyteTableRightFixed' ) ? '_rightFixedWidth' : \"_fixedWidth\";\n\n            if( ( __this[ ns ] += ( bcr.width * ( __remove ? -1 : 1 ) ) ) < 0 && __remove ){\n                __this[ ns ] = 0;\n            }\n        });\n    }\n\n    processUnfix(cell, intersection) {\n        this.common_fn( cell, intersection, true );\n    }\n\n    processFix(cell, intersection) {\n        this.common_fn( cell, intersection );\n    }\n\n    execute(cb) {\n        return this.getMethods( cb ) && this.executeMethod.apply( this, arguments );\n    }\n\n    callUnfix(cell) {\n        this.execute( 'onUnFix', cell, this.$node );\n    }\n\n    callFix(cell) {\n        this.execute( 'onFix', cell, this.$node );\n    }\n\n    callDrop(selectedCell, next, startIndex, endIndex, header, evt) {\n        this.execute( 'onDrop', selectedCell, next, startIndex, endIndex, header, evt, this.$node );\n    }\n\n    callRelease(evt, selectedCell) {\n       this.execute( 'onRelease', evt, selectedCell, this.$node );\n    }\n\n    callOnBeforeSelect(selectedCell, ev, index) {\n        return this.execute( 'onBeforeSelect', selectedCell, ev, this.$node, index ) == false;\n    }\n\n    callOnSelect(selectedCell, ev, index) {\n        return this.execute('onSelect', selectedCell, ev, this.$node, index ) === false;\n    }\n\n    stickyFunction(cell, isCss, property, value) {\n        var index = this.getIndex( cell ),\n        tbody = this.getTbody(),\n        rows = cell.parentNode.previousElementSibling ? [] : this.get_children( tbody ),\n        fnName = isCss ? 'css' : property,\n        fnValue = value;\n\n        if( isCss ){\n            fnValue = {};\n            fnValue[ property ] = value;\n        }\n\n        $L( cell )[ fnName ]( fnValue );\n\n        rows.forEach( row => {\n            $L( this.get_nth_cell( row, index ) )[ fnName ]( fnValue );\n        });\n    }\n\n    removeFixedClass(cell) {\n        this.stickyFunction( cell, false, 'removeClass', 'lyteTableFixed' );\n    }\n\n    addFixedClass(cell) {\n        this.stickyFunction( cell, false, 'addClass', 'lyteTableFixed' );\n    }\n\n    removeSticky(cell) {\n        var is_right = cell.classList.contains( 'lyteTableRightFixed' );\n\n        this.stickyFunction( cell, true, this.rtlfunc( is_right ? 'right' : 'left' ), '' );\n        this.stickyFunction( cell, false, 'removeClass', 'lyteFixedColumn' );\n    }\n\n    makeSticky(cell) {\n        var __left = this.rtlfunc( 'left' );\n\n        this.stickyFunction( cell, true, __left, cell.style[ __left ] );\n    }\n\n    stickyScroll(evt) {\n        var __target = evt.target;\n\n        if( __target == this.scrollDiv ){\n            var __intersections = this._intersections;\n\n            if( __intersections.length  ){\n                $L.fastdom.measure( function(){\n                    var scrollTop = __target.scrollTop;\n                    $L.fastdom.mutate( function(){\n                       __target.closest( 'lyte-table' ).style.setProperty( '--lyte-table-intersection', scrollTop + 'px' );\n                    });\n                });\n            }\n        }\n    }\n\n    sortablemousedown(ev) {\n        var evt = ev,\n        isTch,\n        __target = ev.target;\n\n        if( /lyte-tablehead-resize/i.test( __target.tagName ) || ev.button != 0 ){\n            return\n        }\n\n        if( /touch/i.test( ev.type ) ){\n            if( ev.touches.length > 1 ){\n                return;\n            }\n            isTch = true;\n            evt = ev.touches[ 0 ];\n        }\n        var target = __target,\n        selectedCell = $L( target ).closest( this.data.ltPropTags.th ).get( 0 ),\n        index = this.getIndex( selectedCell );\n\n        if( $L( selectedCell ).hasClass( 'lyteTableFixed' ) ){\n            return;\n        }\n\n        if( this.callOnBeforeSelect( selectedCell, ev, index ) ){\n            return;\n        }\n\n        this._ww = window.innerWidth;\n\n        // no need to pass this._ww inside rtlfunc. its already available inside it == > here only its available in this. In other places i am passing. So i need to pass here too. Here i am storing because of window dimension wont change during mousemove. So no need to measure that in mousemove\n        var clientX = this.rtlfunc( 'clientX', evt, this._ww ),\n        offleft = 0,\n        tbody = this.getTbody(),\n        thead = this.getThead(),\n        cells = [],\n        rows = this.get_children( tbody ),\n        scrollDiv = this.getScrollDiv(),\n        scrollTop = scrollDiv.scrollTop;\n\n        this._elem = selectedCell;\n\n        this._originalIndex = index;\n        this._sortmousemove = this.sortmousemove.bind( this );\n        this._sortmouseup = this.sortmouseup.bind( this );\n        this._currentIndex = index;\n        this._tbody = tbody;\n        this._cells = cells;\n        this._affectedIndex = [];\n\n        this._scrolldivBcr = scrollDiv.getBoundingClientRect();\n        this._scrollwidth = scrollDiv.scrollWidth;\n\n        this._prevx = clientX;\n        this._originalDiv = scrollDiv;\n        this._originalDiv._sL = scrollDiv.scrollLeft;\n\n        var headerCells = Array.from( this.get_children( selectedCell.parentNode ) ),\n        rowBcr = selectedCell.parentNode.getBoundingClientRect(),\n        __dir = this._dir;\n\n        headerCells.forEach( function( cell, index, originalArray ){\n            var previousCell = ( originalArray[ index - 1 ] || {} )._bcr,\n            cellBcr = cell.getBoundingClientRect(),\n            __width = cellBcr.width;\n\n            // Feels like this calculation might not be needed. ===> Actual position( If not sticked ) and sticked positions will be different. here i am calculating Actual position. getBounding will give sticked position\n\n            if( index == 0 ){\n                if( __dir ){\n                    var __right = rowBcr.right;\n                    cell._bcr = { left : __right - __width, right : __right, width : __width };\n                } else {\n                    var __left = rowBcr.left;\n                    cell._bcr = { left : __left, right : __left + __width, width : __width };\n                }\n            } else {\n                if( __dir ){\n                    var __left = previousCell.left;\n                    cell._bcr = { left : __left - __width, right : __left, width : __width };\n                } else {\n                    var __right = previousCell.right;\n                    cell._bcr = { left : __right, right : __right + __width, width : __width };\n                }\n            }\n        });\n\n        // don't understand this part either ==> converting event client value with respect to right( in rtl )\n        \n        this._xoffset = clientX - this.rtlfunc( 'right', selectedCell._bcr, this._ww );\n\n        if( !this.data.ltPropPreventTableModify ){\n            var height = 0;\n\n            rows.every( function( row ){\n                var cell = this.get_nth_cell( row, index ),\n                cellHeight = cell.getBoundingClientRect().height;\n                height += cellHeight;\n\n                if( height < scrollTop - rowBcr.height ){\n                    return true;\n                }\n\n                 cell._translateX = 0;\n                 cells.push( cell );\n                 // may this can be this._currentEndIndex ===> its just virtual movement. So i named this as transformed index\n                 cell._transformedindex = index;\n                 cell.classList.add( 'lyteStickyTableColumnSortSelect' );\n\n                 if( height >= this._scrolldivBcr.height + scrollTop ){\n                    return false;\n                }\n                return true;\n            }.bind( this ) );\n\n            selectedCell._translateX = offleft;\n            cells.push( selectedCell );\n            selectedCell._transformedindex = index;\n        } else {\n            selectedCell._transformedindex = index;\n        }\n\n        document.addEventListener( isTch ? 'touchmove' : 'mousemove', this._sortmousemove, true );\n        document.addEventListener( isTch ? 'touchend' : 'mouseup', this._sortmouseup, true );\n        this.$node.classList.add( 'lyteTableSortSelected' );\n        selectedCell.classList.add( 'lyteStickyTableColumnSortSelect' );\n        ev.preventDefault();\n\n        this.callOnSelect( selectedCell, ev, index );\n    }\n\n    isIncrement(increment, isRightEdge) {\n        return increment > 0 || ( increment == 0 && isRightEdge );\n    }\n\n    isDecrement(increment, isRightEdge) {\n        return increment < 0 || ( increment == 0 && isRightEdge === false );\n    }\n\n    getTd(cell, increment, isRightEdge) {\n        // what is transformedindex ==> while moving columns are interchanged. here transformed index is virtual new index\n        var transindex = cell._transformedindex,\n        __index = -1,\n        ori_index = this._originalIndex;\n\n        if( this.isIncrement( increment, isRightEdge ) ){\n            if( ori_index <= transindex ){\n                __index = transindex + 1;\n            } else{\n                __index = transindex;\n            }\n        } else if( this.isDecrement( increment, isRightEdge ) ) {\n            if( ori_index < transindex ){\n                __index = transindex;\n            } else {\n                __index = transindex - 1;\n            }\n        }\n\n        return this.get_nth_cell( cell.parentNode, __index );\n\n    }\n\n    findFromClosest(evt, cell) {\n        var __tags = this.data.ltPropTags,\n        closestCell = $L( evt.target ).closest( __tags.th + ', ' + __tags.td ).get( 0 );\n        if( this.isHeader( closestCell ) ){\n            var index = this.getIndex( closestCell );\n            closestCell = this.get_nth_cell( cell.parentNode, index );\n        }\n        return closestCell;\n    }\n\n    isHeader(cell) {\n        return cell && ( cell.tagName.toLowerCase() == this.data.ltPropTags.td );\n    }\n\n    isSortEnabled() {\n        return this._elem;\n    }\n\n    isMoved() {\n        return this._moved;\n    }\n\n    getIndex(cell) {\n        return Array.from( this.get_children( cell.parentNode ) ).indexOf( cell );\n    }\n\n    getClassForFake() {\n        return 'lyteTableSortHelper ' + this.data.ltPropSortDummyColumClass;\n    }\n\n    createFakeColum(cell) {\n        var __doc = document,\n        __element = __doc.documentElement,\n        originaldiv = __doc.createElement( 'div' ),\n        div = $L( originaldiv ),\n        cellObj = $L( cell ),\n        bcr = cell.getBoundingClientRect(),\n        xscroll = __element.scrollLeft,\n        yscroll = __element.scrollTop,\n        cb = \"onFakeColumnCreate\";\n\n        cellObj.data( 'sortElement', originaldiv );\n        originaldiv._bcr = { left : bcr.left, right : bcr.right, width : bcr.width };\n        originaldiv._translateX = bcr.left;\n        originaldiv._translateY = bcr.top;\n\n        div.attr( 'style', cellObj.attr( 'style' ) );\n        div.text( cell.textContent )\n            .addClass( this.getClassForFake() )\n            .data( 'relatedElement', cell )\n            .css({ \n                    height : bcr.height, \n                    width : bcr.width,\n                    left : xscroll * ( this._dir ? -1 : 1 ),\n                    top : yscroll,\n                    pointerEvents : \"none\",\n                    transform : 'translate(' + originaldiv._translateX + 'px,' + originaldiv._translateY + 'px)'\n                });\n\n\n        this.getMethods( cb ) && this.executeMethod( cb, originaldiv, cell, this.$node );\n\n        __doc.body.appendChild( originaldiv );\n        this._moved = true;\n    }\n\n    sortmousemove(ev, allowAtSame, isRightEdge) {\n        if( !this.isSortEnabled() ){\n            return;\n        }\n\n        var evt = ev,\n        ww = this._ww,\n        // maybe the rtlfunc needs a better name ==> its a old function can't change its name right now\n        clientX = this.rtlfunc( 'clientX', evt, ww ),\n        left = this.rtlfunc( 'left' ),\n        selectedCell = this._elem,\n        tbody = this.getTbody(),\n        cells = this._cells,\n\n        // don't understand the xoffset == > initial mouse position during mousedown. Increment calculated based on this\n        xoffset = this._xoffset,\n        preventable = this.data.ltPropPreventTableModify;\n\n        // evt = this.getProperEvent() ==> if touch length is more than one i need to stop the function. if i write this as additional function it again leads to write one more function. Right now i can't write this as a fucntion\n        if( /touch/i.test( ev.type ) ){\n            if( ev.touches.length > 1 ){\n                return;\n            }\n            evt = ev.touches[ 0 ];\n        }\n\n        if( preventable && !this.isMoved() ){\n            return this.createFakeColum( selectedCell );\n        }\n\n        if( this._prevx == evt.clientX && !allowAtSame ){\n            return;\n        }\n\n        window.$selectedCell = $L( selectedCell );\n\n        if( this.getMethods( 'onBeforeDrag' ) && this.executeMethod( 'onBeforeDrag', selectedCell, $selectedCell.data( 'sortElement' ), ev, this.$node, this._originalIndex, selectedCell._transformedindex ) === false ){\n            return;\n        }\n\n        this._prevx = evt.clientX;\n\n        var fakeCell = $selectedCell.data( 'sortElement' ),\n        // won't div._bcr be present? In one type it wont present\n        bcr = preventable ? fakeCell._bcr : selectedCell._bcr,\n        increment = ( clientX - this.rtlfunc( 'right', bcr, ww ) - xoffset ),\n        is_increment = this.isIncrement( increment, isRightEdge ),\n        is_decrement = this.isDecrement( increment, isRightEdge ),\n\n        closestCell = preventable ? this.findFromClosest( evt, selectedCell ) : this.getTd( selectedCell, increment, isRightEdge ),\n\n        closestbcr = closestCell ? closestCell._bcr : {},\n\n        newone, closestCellIndex, \n\n        scrollLeft = this._originalDiv._sL,\n\n        fact = this._dir ? -1 : 1,\n\n        interchangeprevent, \n        offLeft = 0,\n        cb = 'onBeforeInterChange',\n        __affectedIndex = this._affectedIndex;\n\n        if( selectedCell == closestCell && !fakeCell ){\n            closestCell = undefined;\n        }\n\n        if( closestCell && this.isSortEnabled() ){\n            closestCellIndex = this.getIndex( closestCell );\n\n            if( closestCellIndex != this._originalIndex || preventable ){\n                var allow = false,\n                close_index = closestCell._transformedindex,\n                transindex = !isNaN( close_index ) ? close_index : closestCellIndex,\n                __limit = this.rtlfunc( 'left', closestbcr, ww ) + closestbcr.width * 0.5,\n                __transformedindex = selectedCell._transformedindex;\n\n                if( fakeCell && selectedCell == closestCell ){\n                    transindex = closestCellIndex;\n                } \n                \n                if( is_increment ) {\n                    if( this.rtlfunc( 'right', bcr, ww ) + increment > __limit ){\n                        allow = transindex > __transformedindex;\n                    }\n                } else if( is_decrement ){\n                    if( this.rtlfunc( 'left', bcr, ww ) + increment < __limit ){\n                        allow = transindex < __transformedindex;\n                        if( allow && ( closestCell._horizontalIntersectionDiv || {} )._sticked ){\n                            allow = false;\n                        }\n                    }\n                }\n                if( allow ){\n                    if( !preventable ){\n                        newone = __affectedIndex.indexOf( closestCellIndex ) == -1;\n                        if( newone ){\n                            offLeft = 0;\n                            __affectedIndex.push( closestCellIndex );\n                        }\n                    }\n                } else {\n                    closestCell = undefined;\n                }\n            }\n        } else {\n            closestCell = undefined;\n        }\n        if( closestCell && this.getMethods( cb ) ){\n            interchangeprevent = this.executeMethod( cb, ev, selectedCell, closestCell, this.$node ) === false;\n            if( interchangeprevent && newone ){\n                this.$addon.arrayUtils( __affectedIndex, 'removeAt', __affectedIndex.indexOf( closestCellIndex ) );\n            }\n        }\n\n        if( preventable ){\n            fakeCell.style.transform = 'translate( ' + ( fakeCell._translateX += ( increment * fact ) ) + 'px,' + fakeCell._translateY + 'px)';\n            if( closestCell && !interchangeprevent ){\n                if( closestCell != selectedCell ){\n                   var __fact = 0;\n                   if( is_decrement ){\n                     __fact = -1;\n                   } else if( is_increment ){\n                     __fact = 1;\n                   }\n                   selectedCell._transformedindex += __fact;\n                }\n            }\n        } else {\n            cells.forEach( function( cell, indexVal ){\n                cell.style.transform = \"translateX(\" + ( cell._translateX += ( increment * fact ) ) + \"px)\";\n                // if( !this.isSortEnabled() ){\n                    cell.classList.add( 'lyteStickyTableColumnMoving' );\n                // }\n                if( closestCell && !interchangeprevent ){\n                    var newcell = this.get_nth_cell( cell.parentNode, closestCellIndex ),\n                    __fact = 0,\n                    ___ns = '_transformedindex';\n\n                    if( newone ){\n                        newcell.classList.add( 'lyteStickyTableColumnSortAnimate' );\n                        newcell._translateX = 0;\n                    }\n                    newcell.style.transform = \"translateX(\" + ( newcell._translateX += ( bcr.width * ( this.isIncrement( increment, isRightEdge ) ? -1 : 1 ) * fact ) ) + \"px)\";\n\n                    if( newcell[ ___ns ] == undefined ){\n                        newcell[ ___ns ] = closestCellIndex;\n                    }\n\n                    if( is_decrement ){\n                        __fact = 1;\n                    } else if( is_increment ){\n                        __fact = -1;\n                    }\n\n                    newcell[ ___ns ] += __fact;\n                    cell[ ___ns ] -= __fact\n                }\n            }.bind( this ));\n        }\n\n        if( fakeCell ){\n            var __fakecell = fakeCell._bcr;\n\n            __fakecell.left += ( increment* fact );\n            __fakecell.right += ( increment * fact );\n        } else {\n            var __selected_bcr = selectedCell._bcr;\n\n            __selected_bcr.left += ( increment * fact );\n            __selected_bcr.right += ( increment * fact );\n            if( closestCell && !interchangeprevent ){\n                var close_bcr = closestCell._bcr;\n\n                close_bcr.left += ( bcr.width * ( is_increment ? -1 : 1 ) * fact );\n                close_bcr.right += ( bcr.width * ( is_decrement ? -1 : 1 ) * fact );\n            }\n        }\n        this.clearFastdom();\n\n        this.sorthorizontalscroll( { left : bcr.left, width : bcr.width, right :  bcr.right }, scrollLeft, is_increment );\n\n        if( closestCell ){\n            this.callInterChange( ev, selectedCell, closestCell );\n        }\n        this.callDrag( selectedCell, ev );\n        this._moved = true;\n    }\n\n    callInterChange(ev, selectedCell, closestCell) {\n        this.execute( 'onInterChange', ev, selectedCell, closestCell, this.$node );\n    }\n\n    callDrag(selectedCell, ev) {\n        this.execute( 'onDrag', selectedCell, $L( selectedCell ).data( 'sortElement' ), ev, this.$node, this._originalIndex, selectedCell._transformedindex );\n    }\n\n    clearFastdom() {\n        var fastdom = $L.fastdom;\n        fastdom.clear( this._reqId );\n        fastdom.clear( this._measure );\n        delete this._measure;\n        delete this._reqId;\n    }\n\n    sorthorizontalscroll(bcr, scrollLeft, isIncrement) {\n        var left = this.rtlfunc( 'left' ),\n        ww = this._ww,\n        _scrolldivBcr = this._scrolldivBcr,\n        _scrollwidth = this._scrollwidth,\n        _thisBccr = this._thisBccr,\n        _originalDiv = this._originalDiv,\n        _FF = this._FF,\n        _dir = this._dir,\n        _chrome = this._chrome,\n        _isSafari = this._isSafari,\n        isLeft = !isIncrement && ( this.rtlfunc( 'left', bcr, ww ) < Math.max( this._fixedWidth + this.rtlfunc( 'left', _scrolldivBcr, ww ), 0 ) ),\n        isRight = isIncrement && ( ( this.rtlfunc( 'left', bcr, ww ) + bcr.width ) > Math.min( this.rtlfunc( 'right', _scrolldivBcr, ww ), ww ) ),\n        selectedCell = this._elem;\n\n        if( _FF && isRight ){\n            // is this like checking if currentEndIndex is on the last node? == > firefox behaves weirdly. If we keep moving scrollwidth gradully increases. So if it reaches its end i am returning false\n\n            if( selectedCell._transformedindex == this.get_children( selectedCell.parentNode ).length - 1 ){\n                if( _dir ){\n                     // why scrollwidth + scrollleft <= widthofscrolldiv? - Firefox rtl behaviour\n                     if( _scrollwidth + window.sL <= _thisBccr.width ){\n                        return;\n                    }\n                } if( window.sL + _thisBccr.width >= _scrollwidth ){\n                    return;\n                }\n            }\n        }\n\n        var value;\n\n        if( isLeft ){\n            value = scrollLeft - this.getCrctScrollValue();\n            if( _dir ){\n                if( _chrome ){\n                    // why does this Math.min need to be taken ==> In Rtl scrollLeft value will be lower than initial value. Setting Higher value change its scroll width value automatically in rtl\n                    value = Math.min( value, _scrollwidth - _scrolldivBcr.width );\n                } else if( _FF || _isSafari ){\n                    value = Math.min( value, 0 );\n                }\n            } else {\n                value = Math.max( value, 0 );\n            }\n        } else if( isRight ){\n            value = scrollLeft + this.getCrctScrollValue();\n            if( _dir ){\n                if( _chrome ){\n                    value = Math.max( value, 0 );\n                    isRight = value != 0;\n                } else if( _FF || _isSafari ){\n                    value = Math.max( value, _scrolldivBcr.width - _scrollwidth );\n                    isRight = value != _scrolldivBcr.width - _scrollwidth;\n                } else {\n                    value = Math.min( value, _scrollwidth - _scrolldivBcr.width ); \n                    isRight = value != _scrollwidth - _scrolldivBcr.width;\n                }\n            } else {\n                value = Math.min( value, _scrollwidth - _scrolldivBcr.width );\n            }\n        } else {\n            this.clearFastdom();\n        } \n        if( isLeft || isRight ){\n            _originalDiv.scrollLeft = value;\n            var headerCells = Array.from( this.get_children( selectedCell.parentNode ) ),\n            scrollIncrement = value - scrollLeft\n\n            if( scrollIncrement ){\n\n                // why (value - sL) === > Updating my reference value without dom measure\n                _originalDiv._sL += scrollIncrement;\n\n                headerCells.forEach( cell => {\n                    cell._bcr.left -= scrollIncrement;\n                    cell._bcr.right -= scrollIncrement;\n                });\n\n                var fastdom = $L.fastdom;\n\n                this._measure = fastdom.measure( () => {\n                    delete this._measure;\n                    this._reqId = fastdom.mutate( () => {\n                        delete this._reqId;\n                        this.sortmousemove( { clientX : this._prevx }, true, isRight );\n                    });\n                });\n            }\n         }\n    }\n\n    getCrctScrollValue() {\n        return this.data.ltPropScrollStep * ( this._dir ? -1 : 1 );\n    }\n\n    swapColumnsInData(header, startIndex, endIndex) {\n        var La = this.$addon.arrayUtils,\n        current = La( header, 'removeAt', startIndex );\n        La( header, 'insertAt', endIndex, current );\n    }\n\n    swapColumnsInDom(startIndex, endIndex) {\n        this._preventCustomdelete = true;\n\n        var rows = Array.from( this.getRows() );\n\n        rows.forEach( row => {\n            this.$component[ startIndex < endIndex ? 'insertAfter' : 'insertBefore' ]( this.get_nth_cell( row, endIndex ), this.get_nth_cell( row, startIndex ) );\n        });\n        delete this._preventCustomdelete;\n    }\n\n    removeEvents(evt) {\n        var isTch = /touch/i.test( evt.type ),\n        rel = 'removeEventListener',\n        __doc = document;\n\n        __doc[ rel ]( isTch ? 'touchmove' : 'mousemove', this._sortmousemove, true );\n        __doc[ rel ]( isTch ? 'touchend' : 'mouseup', this._sortmouseup, true );\n\n        delete this._sortmouseup; \n        delete this._sortmousemove; \n    }\n\n    clearVariables() {\n        delete this._elem; \n        delete this._xoffset; \n        delete this._originalIndex; \n        delete this._moved;\n        delete this._affectedIndex; \n        delete this._tbody;\n        delete this._cells; \n        delete this._prevx; \n        delete this._scrolldivBcr; \n        delete this._ww; \n        delete this._scrollwidth;\n        delete this._originalDiv;\n    }\n\n    sortmouseup(evt) {\n        var startIndex = this._originalIndex,\n        selectedCell = this._elem,\n        endIndex = selectedCell._transformedindex;\n\n        this.resetcells();\n        if( this.isSortEnabled() ){\n            var failed,\n            header = this.getData( 'ltPropHeader' ),\n            next = this.get_nth_cell( selectedCell.parentNode, endIndex ),\n            cb = \"onBeforeDrop\",\n            failed = this.getMethods( cb ) && this.executeMethod( cb, selectedCell, next, startIndex, endIndex, header, evt ) == false;\n\n            if( !failed && startIndex != endIndex ){\n                if( header.length ){\n                    this.swapColumnsInData( header, startIndex, endIndex );\n                } else {\n                    this.swapColumnsInDom( startIndex, endIndex );\n                }\n            }\n            this._setLeftForInterSection();\n            !failed && this.callDrop( selectedCell, next, startIndex, endIndex, header, evt )\n        } else {\n            // Is onRelease a callback which gets fired when the element has not been moved? This sounds like a very special case callback. I want to know more about the use case of this\n\n            // Generally all are adding some class to selected element in mousedown and want to remove the same in mouseup. If its not moved those classes will not be removed( or they have to write that in first mousemove ). In my case too i need to call reset cells. Thats why i here provided one extra callback\n            this.callRelease( evt, selectedCell )\n        }\n\n        this.removeEvents( evt );\n        this.clearFastdom();\n        this.clearVariables();\n\n        this.$node.classList.remove( 'lyteTableSortSelected' );\n    }\n\n    removeFakeCell(selectedCell) {\n        var $node = $L( selectedCell ),\n        ns = 'sortElement',\n        div = $node.data( ns );\n        if( div ){\n          div.remove();\n          $L( div ).data( 'relatedElement', void 0 );\n        }\n        $node.data( ns, void 0 );\n    }\n\n    resetcells(cells) {\n        var affected = this._affectedIndex,\n        cells = this._cells,\n        selectedCell = this._elem;\n\n        if( this.data.ltPropPreventTableModify ){\n            this.removeFakeCell( selectedCell );\n            this.resetSingleCell( selectedCell );\n        } else {\n            cells.forEach( function( cell ){\n                var rowChildren = this.get_children( cell.parentNode );\n                this.resetSingleCell( cell );\n                 affected.forEach( function( affIndex ){\n                    this.resetSingleCell( rowChildren[ affIndex ] );\n                }.bind( this ) );\n            }.bind( this ) );\n        }\n    }\n\n    resetSingleCell(cell) {                \n        cell.style.transform = \"\";\n        cell.classList.remove( 'lyteStickyTableColumnSortSelect', 'lyteStickyTableColumnMoving', 'lyteStickyTableColumnSortAnimate' );\n        delete cell._transformedindex;\n        delete cell._translateX;\n    }\n\n    checkIntersection(arg, ignore_removal) {\n        var table = this.__table,\n        __this = table.component;\n\n        if( table.ltProp( 'stickyTable' ) && __this.data.ltPropScroll.horizontal ){\n            var __elem = this._horizontalIntersectionDiv;\n            if( arg && !__elem ){\n                __this.createIntersection.call( this, table );\n            } else if( !arg && __elem ){\n                var intersection = __elem;\n                __this.removeIntersection.call( this, intersection, table );\n                __this.removeSticky( this );\n                __this.removeFixedClass( this );\n\n                if( ignore_removal ){\n                    __this.createIntersection.call( this, table );\n                }\n            }\n        }\n    }\n\n    createIntersection(table) {\n        var div = $L( document.createElement( 'div' ) ).addClass( 'lyteIntersectionDiv' ).get( 0 );\n        table.getElementsByTagName( table.ltProp( 'tags' ).table )[ 0 ].appendChild( div );\n        this._horizontalIntersectionDiv = div;\n        div._cell = this;\n        table.component._setLeftForInterSection();\n    }\n\n    disconnectedCallback() {\n        var intersection = this._horizontalIntersectionDiv;\n        if( intersection ){\n            var table = this.__table,\n            __this = table.component;\n\n            if( table && __this._preventCustomdelete ){\n                return;\n            }\n            delete this.__table;\n            __this.removeIntersection.call( this, intersection, table );\n        }\n    }\n\n    removeIntersection(intersection, table) {\n        if( table ){\n            var ins = table.component._intersectionObs;\n            if( ins ){\n                ins.unobserve( intersection );\n            }\n        }\n        intersection.remove();\n\n        delete intersection._cell;\n        delete this._horizontalIntersectionDiv;\n    }\n\n    static observers() {\n        return {\n            stickyTable : function(){\n                var __this = this,\n                __data = __this.data;\n\n                if( __data.ltPropStickyTable ){\n                    var $node = __this.$node,\n                    scroll = __data.ltPropScroll,\n                    scrollDiv = __this.getScrollDiv();\n\n                    __this.__mixinAdded = true;\n                    $node.classList.add( 'lyteStickyTable' );\n\n                    if( scroll.horizontal ){\n                        __this.registerInterSection( scrollDiv );\n                        scrollDiv.addEventListener( 'scroll', __this.stickyScroll.bind( __this ), true );\n                    }\n\n                   $node.reset = function(){\n                        __this._setLeftForInterSection( true );\n                        if( !__this.__from_collapse ){\n                            __this.update_collapse( true );\n                        }\n                   }.bind( __this );\n\n                    __this.detectBrowsers();\n                }\n            }.on( 'didConnect' ),\n\n            setLeftForInterSection : function(){\n                if( this.data.ltPropStickyTable ){ \n                    this.$node.reset();\n                }\n            }.observes( 'ltPropContent.[]', 'ltPropHeader.[]', 'ltPropContent', 'ltPropHeader' ).on( 'didConnect' ),\n\n            bindingEvts : function(){\n               var data = this.data;\n\n               if( !data.ltPropStickyTable ){\n                   return;\n               }\n\n               var header = this.getThead();\n               if( header ){\n                   var fn,\n                   ns = \"addEventListener\";\n                   if( data.ltPropColumnSortable ){\n                       fn = ( this._sortmousedown = this.sortablemousedown.bind( this ) );\n                   } else {\n                        if( fn = this._sortmousedown ){\n                           ns = \"removeEventListener\";\n                           delete this._sortmousedown;\n                       }\n                   }\n                   if( fn ){\n                       header[ ns ]( 'mousedown', fn, true );\n                       header[ ns ]( 'touchstart', fn, true );\n                   }\n               }\n\n           }.observes( 'ltPropColumnSortable' ).on( 'didConnect' )\n        };\n    }\n}\n\nexport { LyteTableUtilsMixin };",";( function( cb ){\n\tif( typeof define == \"function\" && define.amd ){\n\t\tdefine( [ \"@zoho/lyte-dom\" ], cb );\n\t} else {\n\t\tcb( window.$L );\n\t}\n} )( function( $L ){\n\tif( $L && $L.moment ) {\n\t\tvar proto = $L.moment.lyteMoment.prototype;\n\t\tvar standardDate = [\n\t\t\t{ val : 'YYYY-MM-DD', regex : /^(\\d{4}-\\d{2}-\\d{2})/ },\n\t\t\t{ val : 'GGGG-['+ proto.week + ']WW-E', regex : new RegExp( '\\^(\\\\d{4}-'+ proto.week + '\\\\d{2}-\\\\d)' ) },\n\t\t\t{ val : 'GGGG-['+ proto.week + ']WW', regex : new RegExp( '\\^(\\\\d{4}-'+ proto.week + '\\\\d{2})' ) },\n\t\t\t{ val : 'YYYY-DDD', regex : /^(\\d{4}-\\d{3})/ },\n\t\t\t{ val : 'YYYY-MM', regex : /^(\\d{4}-\\d{2})/ },\n\t\t\t{ val : 'YYYYMMDD', regex : /^(\\d{8})/},\n\t\t\t{ val : 'GGGG['+ proto.week + ']WWE', regex : new RegExp( '\\^(\\\\d{4}'+ proto.week + '\\\\d{2}\\\\d)' ) },\n\t\t\t{ val : 'GGGG['+ proto.week + ']WW', regex : new RegExp( '\\^(\\\\d{4}'+ proto.week + '\\\\d{2})' ) },\n\t\t\t{ val : 'YYYYDDD', regex : /^(\\d{4}\\d{3})/ }\n\t\t],\n\t\tstandardTime = [\n\t\t\t{ val : 'HH:mm:ss.SSSS', regex : /^\\d{2}:\\d{2}:\\d{2}\\.[0-9]{1,}$/ },\n\t\t\t{ val : 'HH:mm:ss,SSSS', regex : /^\\d{2}:\\d{2}:\\d{2},[0-9]{1,}$/ },\n\t\t\t{ val : 'HH:mm:ss', regex : /^\\d{2}:\\d{2}:\\d{2}$/ },\n\t\t\t{ val : 'HH:mm', regex : /^\\d{2}:\\d{2}$/ },\n\t\t\t{ val : 'HHmmss.SSSS', regex : /^\\d{6}\\.[0-9]{1,}$/ },\n\t\t\t{ val : 'HHmmss,SSSS', regex : /^\\d{6},[0-9]{1,}$/ },\n\t\t\t{ val : 'HHmmss', regex : /^\\d{6}$/ },\n\t\t\t{ val : 'HHmm', regex : /^\\d{4}$/ },\n\t\t\t{ val : 'HH', regex : /^\\d{2}$/ }\n\t\t];\n\t\tfunction constructFormatCopy( arg, isTime ) {\n\t\t\tvar cpForm = this.formats.slice(), obj = {}, dummy = arg, isWEG = new RegExp(  this.week + '|G|E' , 'i' ).test( arg );\n\t\t\tfor( var i = 0; i < cpForm.length; i++ ) {\n\t\t\t\tvar cur = cpForm[ i ];\n\t\t\t\tif( isTime != cur.time ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif( cur.regex.test( dummy ) && isWEG == !!cur.isWEG && !this.isDef( obj[ cur.type ] ) ) {\n\t\t\t\t\tif( cur.ignore && !cur.ignore.test( dummy ) ) {\n\t\t\t\t\t\tvar dd = this.dayArr[ obj.month ] || 30;\n\t\t\t\t\t\tif( parseInt( dummy.match( cur.regex )[ 0 ] ) < dd ){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( cur.str ) {\n\t\t\t\t\t\tvar matches = this.find( cur.array, dummy.replace( /(Y|G)+/, '' ) ).mon;\n\t\t\t\t\t\tif( matches ){\n\t\t\t\t\t\t\targ = this.replace( arg, matches, false, cur.val );\n\t\t\t\t\t\t\tobj[ cur.type ] = cur.array ? this.find( cur.array, matches ).index : matches;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar matches = dummy.match( cur.regex )[ 0 ];\n\t\t\t\t\t\targ = this.replace( arg, cur.regex, cur.suff, cur.val );\n\t\t\t\t\t\tobj[ cur.type ] = parseInt( matches );\n\t\t\t\t\t\tif( cur.type == 'week' ) {\n\t\t\t\t\t\t\targ = this.replace( arg, new RegExp( this.week + '(?=\\\\\\[' + this.week + ')') );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdummy = dummy.replace( matches, '' );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn arg;\n\t\t}\n\n\t\tfunction iterate( array, arg ) {\n\t\t\tfor( var i = 0; i < array.length; i++ ) {\n\t\t\t\tif( array[ i ].regex.test( arg ) ) {\n\t\t\t\t\treturn array[ i ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction get_day( month, year ){\n\t\t\tvar dayArr = this.dayArr,\n\t\t\tisLeap = this.isLeap( year );\n\n\t\t\treturn dayArr[ month ] + ( month == 1 && isLeap ? 1 : 0 );\n\t\t}\n\n\t\tfunction constructFormat( arg ) {\n\t\t\tvar dateFormat = iterate.call( this, standardDate, arg ), timeFormat;\n\t\t\tif( dateFormat ) {\n\t\t\t\ttimeFormat = iterate.call( this, standardTime, arg.replace( dateFormat.regex, '' ) );\n\t\t\t\tif( timeFormat ) {\n\t\t\t\t\targ = dateFormat.val + timeFormat.val;\n\t\t\t\t} else {\n\t\t\t\t\targ = constructFormatCopy.call( this, arg.replace( dateFormat.regex, dateFormat.val ), true );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\targ = constructFormatCopy.call( this, arg )\n\t\t\t\targ = constructFormatCopy.call( this, arg, true )\n\t\t\t}\n\t\t\treturn arg;\n\t\t}\n\n\t\tproto.additional = true;\n\n\t\t$L.extend( proto, {\n\n\t\t\t inbuiltFormats : {\n\t\t\t \tlocalDatetime: 'YYYY-MM-DDTHH:mm',            \n\t\t        localSecondDatetime: 'YYYY-MM-DDTHH:mm:ss',\n\t\t        localMillisecondDatetime: 'YYYY-MM-DDTHH:mm:ss.SSS',   \n\t\t        defaultDate: 'YYYY-MM-DD',                             \n\t\t        defaultTime: 'HH:mm',                                \n\t\t        defaultTimeSecond: 'HH:mm:ss',                 \n\t\t        defaultTimeMillisecond: 'HH:mm:ss.SSS',           \n\t\t        defaultWeek: 'GGGG-[W]WW',    \n\t\t        defaultMonth: 'YYYY-MM'\n\t\t\t },\n\n\t\t\tget : function( arg ){\n\t\t\t\tif( arg ){\n\t\t\t\t\treturn this[ arg ]();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tset : function( arg, val ) {\n\t\t\t\tif( arg ) {\n\t\t\t\t\tif( val.constructor == Object ) {\n\t\t\t\t\t\tfor( var key in val ) {\n\t\t\t\t\t\t\tthis[ key ]( val[ key ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this[ arg ]( val );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tconstructFormat : constructFormat,\n\n\t\t\ti18N : i18N\n\t\t})\n\n\t\tnew Array( { prop : 'date', array : [ proto.weekLong, proto.weekShort, proto.weekMid] }, { prop : 'day', array : [ proto.weekLong, proto.weekShort, proto.weekMid] } , { prop : 'month', array : [ proto.shortMon, proto.longMon ] }, { prop : 'year'}, { prop : 'fullYear' }, { prop : 'hours' }, { prop : 'minutes' }, { prop : 'seconds' }, { prop : 'milliseconds' },{ prop : 'UTCMilliseconds' }, { prop : 'time' } ).forEach( function( val ) {\n\t\t\t\n\t\t\tproto[ val.prop ] = function( arg ){\n\t\t\t\tif( this.validate() ) {\n\t\t\t\t\tvar dob = this.toDate();\n\t\t\t\t\tvar prop = val.prop[ 0 ].toUpperCase() + val.prop.slice( 1 );\n\t\t\t\t\tif( this.isDef( arg ) ) {\n\t\t\t\t\t\tif( arg.constructor == String ) {\n\t\t\t\t\t\t\tfor( var i = 0; i < val.array.length; i++ ) {\n\t\t\t\t\t\t\t\tvar ret = this.find( val.array[ i ], arg )\n\t\t\t\t\t\t\t\tif( ret.mon ) {\n\t\t\t\t\t\t\t\t\targ = ret.index;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if( arg.constructor == Number && Math.floor( arg ) != arg ) {\n\t\t\t\t\t\t\tif( val.prop == 'year' ) {\n\t\t\t\t\t\t\t\tval.prop = 'month';\n\t\t\t\t\t\t\t\targ = Math.round( arg * 12 );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\targ = Math.round( arg )\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( val.prop == 'day' ) {\n\t\t\t\t\t\t\tdob.setDate( dob.getDate() + ( arg - dob.getDay() ) );\n\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\tdob[ 'set' + prop ]( arg );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn dob[ 'get' + prop ]();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t$L.extend( proto, {\n\t\t\tweek : function( arg ) {\n\t\t\t\tif( this.validate() ) {\n\t\t\t\t\tvar dob = this.toDate();\n\t\t\t\t\tif( this.isDef( arg ) ) {\n\t\t\t\t\t\tdob.setDate( dob.getDate() + ( arg - this.week() ) * 7 );\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t} else{\n\t\t\t\t\t\treturn this.getWeekReverse( dob, 1 ).week;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tquarter : function( arg ) {\n\t\t\t\tif( this.validate() ) {\n\t\t\t\t\tvar dob = this.toDate();\n\t\t\t\t\tif( this.isDef( arg ) ) {\n\t\t\t\t\t\tvar mon = dob.getMonth();\n\t\t\t\t\t\tdob.setMonth( dob.getMonth() + ( arg - this.quarter() ) * 3 );\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t} else{\n\t\t\t\t\t\treturn Math.ceil( dob.getMonth() / 3 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tadd : function( val, prop, cyclic ) {\n\n\t\t\t\tif( val < 0 ){\n\t\t\t\t\treturn this.subtract( Math.abs( val ), prop, cyclic );\n\t\t\t\t}\n\n\t\t\t\tif( this.validate() ) {\n\t\t\t\t\tvar dob = this.toDate();\n\t\t\t\t\tif( this.isDef( prop ) ) {\n\t\t\t\t\t \tvar old_time = dob.getTimezoneOffset(),\n\t\t\t\t\t \tnewmoment = this.set( prop, this.get( prop ) + val );\n\t\t\t\t\t \tif( cyclic ){\n\t\t\t\t\t\t\treturn convertCyclic.call( this, newmoment );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn newmoment;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tsubtract : function( val, prop, cyclic ) {\n\n\t\t\t\tif( val < 0 ){\n\t\t\t\t\treturn this.add( Math.abs( val ), prop, cyclic );\n\t\t\t\t}\n\n\t\t\t\tif( this.validate() ) {\n\t\t\t\t\tvar dob = this.toDate();\n\t\t\t\t\tif( this.isDef( prop ) ) {\n\t\t\t\t\t\tvar newmoment = this.set( prop, this.get( prop ) - val );\n\t\t\t\t\t\tif( cyclic ){\n\t\t\t\t\t\t\treturn convertCyclic.call( this, newmoment );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn newmoment;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tmodify : function( val, prop, cyclic ){\n\n\t\t\t\tif( this.validate() ){\n\n\t\t\t\t\tif( prop == \"month\" ){\n\t\t\t\t\t\tif( val > 0 ){\n\t\t\t\t\t\t\tadd_value.call( this, val );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdeduct_value.call( this, Math.abs( val ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t} else{\n\t\t\t\t\t\tthis.add( val, prop, cyclic );\n\t\t\t\t\t}\n\n\t\t\t\t\tif( cyclic ){\n\t\t\t\t\t\tconvertCyclic.call( this, this );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tstartOf : function( prop ){\n\t\t\t\tif( this.validate() ){\n\t\t\t\t\tvar dob = this.toDate(),\n\t\t\t\t\tflag,\n\t\t\t\t\tformat = this.format(),\n\t\t\t\t\treplace = [],\n\t\t\t\t\tyear = Number( format.slice( 0, 4 ) ),\n\t\t\t\t\tmonth = Number( format.slice( 5, 7 ) ),\n\t\t\t\t\tdate = Number( format.slice( 8, 10 ) ),\n\t\t\t\t\thour = Number( format.slice( 11, 13 ) ),\n\t\t\t\t\tminute = Number( format.slice( 14, 16 ) ),\n\t\t\t\t\tsecond = Number( format.slice( 17, 19 ) ),\n\t\t\t\t\tmilliseconds = dob.getMilliseconds(),\n\t\t\t\t\tto_deduct = 0,\n\t\t\t\t\told_time = this.timezoneOffset( dob );\n\n\t\t\t\t\tprop = ( prop || \"\" ).toLowerCase();\n\n\t\t\t\t\tif( prop == \"week\" ){\n\t\t\t\t\t\tvar weekLong = this.weekLong,\n\t\t\t\t\t\tname = this.format( 'dddd' ),\n\t\t\t\t\t\twod = this.wod,\n\t\t\t\t\t\t__index = weekLong.indexOf( name ),\n\t\t\t\t\t\tdiff = ( __index - wod + 7 ) % 7;\n\t\t\t\t\t\tto_deduct = diff * 24 * 60 * 60 * 1e3;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tprop = \"hour\";\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch( prop ){\n\t\t\t\t\t\tcase \"year\" : {\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"month\" : {\n\t\t\t\t\t\t\tif( flag ){\n\t\t\t\t\t\t\t\tto_deduct += this.totdate( month - 1, this.isLeap( year ) ) * 24 * 60 * 60 * 1e3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"date\" : \n\t\t\t\t\t\tcase \"day\" : {\n\t\t\t\t\t\t\tif( flag ){\n\t\t\t\t\t\t\t\tto_deduct += ( date - 1 ) * 24 * 60 * 60 * 1e3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"hour\" : {\n\t\t\t\t\t\t\tif( flag ){\n\t\t\t\t\t\t\t\tto_deduct += hour * 60 * 60 * 1e3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"minute\" : {\n\t\t\t\t\t\t\tif( flag ){\n\t\t\t\t\t\t\t\tto_deduct += minute * 60 * 1e3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"second\" : {\n\t\t\t\t\t\t\tif( flag ){\n\t\t\t\t\t\t\t\tto_deduct += second * 1e3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif( to_deduct ){\n\t\t\t\t\t\tdob.setTime( dob.getTime() - to_deduct - milliseconds );\n\n\t\t\t\t\t\tvar new_time = this.timezoneOffset( dob ),\n\t\t\t\t\t\tdiff = new_time - old_time;\n\n\t\t\t\t\t\tif( diff ){\n\t\t\t\t\t\t\tdob.setTime( dob.getTime() + diff * 60 * 1e3 );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tendOf : function( prop ){\n\t\t\t\tif( this.validate() ){\n\n\t\t\t\t\tthis.startOf( prop );\n\n\t\t\t\t\tvar dob = this.toDate(),\n\t\t\t\t\tformat = this.format(),\n\t\t\t\t\treplace = [],\n\t\t\t\t\tyear = Number( format.slice( 0, 4 ) ),\n\t\t\t\t\tmonth = Number( format.slice( 5, 7 ) ),\n\t\t\t\t\tdate = Number( format.slice( 8, 10 ) ),\n\t\t\t\t\thour = Number( format.slice( 11, 13 ) ),\n\t\t\t\t\tminute = Number( format.slice( 14, 16 ) ),\n\t\t\t\t\tsecond = Number( format.slice( 17, 19 ) ),\n\t\t\t\t\tmilliseconds = dob.getMilliseconds(),\n\t\t\t\t\tto_add = 0,\n\t\t\t\t\told_time = this.timezoneOffset( dob );\n\n\t\t\t\t\tprop = ( prop || \"\" ).toLowerCase();\n\n\t\t\t\t\tif( prop == \"week\" ){\n\t\t\t\t\t\tto_add += 7 * 24 * 60 * 60 * 1e3;\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch( prop ){\n\t\t\t\t\t\tcase \"year\" : {\n\t\t\t\t\t\t\tto_add += this.totdate( 12, this.isLeap( year ) ) * 24 * 60 * 60 * 1e3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"month\" : {\n\t\t\t\t\t\t\tvar is_leap = this.isLeap( year );\n\n\t\t\t\t\t\t\tto_add += ( this.totdate( month, is_leap ) - this.totdate( month - 1, is_leap ) ) * 24 * 60 * 60 * 1e3;\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"date\" : \n\t\t\t\t\t\tcase \"day\" : {\n\t\t\t\t\t\t\tto_add += ( 24 - hour ) * 60 * 60 * 1e3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"hour\" : {\n\t\t\t\t\t\t\tto_add += ( 60 - minute ) * 60 * 1e3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\t\tcase \"minute\" : {\n\t\t\t\t\t\t\tto_add += ( 60 - second ) * 1e3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'second' : {\n\t\t\t\t\t\t\tto_add += 1e3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif( to_add ){\n\t\t\t\t\t\tdob.setTime( dob.getTime() + to_add - 1 );\n\n\t\t\t\t\t\tvar new_time = this.timezoneOffset( dob ),\n\t\t\t\t\t\tdiff = new_time - old_time;\n\n\t\t\t\t\t\tif( diff ){\n\t\t\t\t\t\t\tdob.setTime( dob.getTime() + diff * 60 * 1e3 );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tfromNow : function( arg, to_accurate ){\n\t\t\t\tif( this.validate() ){\n\t\t\t\t\tvar today = this,\n\t\t\t\t\tpast_date = $L.moment( arg );\n\n\t\t\t\t\tif( !past_date.validate() ){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar old_time = today.get( 'time' ),\n\t\t\t\t\tnew_time = past_date.get(  'time' ),\n\t\t\t\t\tdiff = parseInt( ( new_time - old_time ) / 1000 ),\n\t\t\t\t\tpast = diff < 0,\n\t\t\t\t\tlimits = { years : { val : 320 * 24 * 60 * 60, conv : 365 * 24 * 60 * 60 }, months : { val : 26 * 24 * 60 * 60, conv : 30 * 24 * 60 * 60 }, days : { val : 22 * 60 * 60, conv : 24 * 60 * 60 }, hours : { val : 45 * 60, conv : 60 * 60 }, minutes : { val : 44, conv : 60 }, seconds : { val : 0, conv : 1 } },\n\t\t\t\t\ttimestamp = new_time - old_time,\n\t\t\t\t\tns1 = to_accurate ? 'conv' : 'val',\n\t\t\t\t\tns2 = to_accurate ? 'floor' : 'round',\n\t\t\t\t\tfn = function( _diff, obj ){\n\t\t\t\t\t\tvar key,\n\t\t\t\t\t\tvalue;\n\n\t\t\t\t\t\tfor( key in limits ){\n\t\t\t\t\t\t\tif( _diff >= limits[ key ][ ns1 ] ) {\n\t\t\t\t\t\t\t\twindow.val = Math[ ns2 ]( _diff / limits[ key ].conv );\n\t\t\t\t\t\t\t\tvalue = val;\n\n\t\t\t\t\t\t\t\tvar new_diff = _diff - val * limits[ key ].conv;\n\t\t\t\t\t\t\t\tif( new_diff > 0 ){\n\t\t\t\t\t\t\t\t\tfn( new_diff, obj );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobj[ key ] = { value : value };\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tproperty : key,\n\t\t\t\t\t\t\tvalue : value\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t\tobj = { past : past, timestamp : timestamp };\n\n\t\t\t\t\tdiff = Math.abs( diff ); \n\n\t\t\t\t\treturn $L.extend( obj, fn( diff, obj ) );\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tisDst : function(){\n\n\t\t\t\tif( this.validate() ){\n\t\t\t\t\tvar __start = $L.moment( this ).startOf( 'day' ),\n\t\t\t\t\t__end = $L.moment( this ).endOf( 'day' );\n\n\t\t\t\t\tthis.__start = __start;\n\t\t\t\t\tthis.__end = __end;\n\t\t\t\t\t\n\t\t\t\t\treturn __start.format( 'Z' ) != __end.format( 'Z' );\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t},\n\n\t\t\tdstPoint : function( time_format, increment ){\n\t\t\t\tif( this.validate() && this.isDst() ){\n\t\t\t\t\tvar start = $L.moment( this.__start ),\n\t\t\t\t\tformat = start.format( 'Z' ),\n\t\t\t\t\tchange,\n\t\t\t\t\tcount = 0,\n\t\t\t\t\tlimit;\n\n\t\t\t\t\tincrement = increment || 30;\n\t\t\t\t\tlimit = 1440 / increment;\n\t\t\t\t\ttime_format = time_format || \"HH:mm:ss\";\n\n\t\t\t\t\twhile( count < limit ){\n\t\t\t\t\t\tvar new_format = start.add( increment, 'minutes' ).format( 'Z' ),\n\t\t\t\t\t\trgx = /(\\+|\\-)(\\d{2}):(\\d{2})$/;\n\t\t\t\t\t\tif( format !=  new_format ){\n\t\t\t\t\t\t\tvar diff = this.convertTimeZone( format.match( rgx ) ) - this.convertTimeZone( new_format.match( rgx ) );\n\n\t\t\t\t\t\t\tchange = {\n\t\t\t\t\t\t\t\tmoment : $L.moment( start ).subtract( 1, 'seconds' ),\n\t\t\t\t\t\t\t\ttime : start.add( 1, 'day' ).subtract( diff, 'minutes' ).format( time_format ),\n\t\t\t\t\t\t\t\tvalue : diff,\n\t\t\t\t\t\t\t\ttimeZoneOld : format,\n\t\t\t\t\t\t\t\ttimeZoneNew : new_format\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\t\n\n\t\t\t\t\treturn change;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tgetWeekDays : function( start, end ){\n\n\t\t\t\tif( this.validate() ){\n\t\t\t\t\tstart = start == void 0 ? 1 : start;\n\t\t\t\t\tend = end == void 0 ? 5 : end;\n\n\t\t\t\t\tif( end < start ){\n\t\t\t\t\t\tend += 7;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar dobj = this.getDObj(),\n\t\t\t\t\t__time = dobj.getTime(),\n\t\t\t\t\t__day = dobj.getDay(),\n\t\t\t\t\tfinal = [],\n\t\t\t\t\tdiff = end - start,\n\t\t\t\t\toff = __day - start,\n\t\t\t\t\tone_day = 24 * 60 * 60 * 1e3;\n\n\t\t\t\t\tfor( var i = 0; i <= diff; i++ ){\n\t\t\t\t\t\tfinal.push( $L.moment( new Date( __time - ( off - i ) * one_day ) ) );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn final;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\tfunction convertCyclic( newmoment ){\n\t\t\tvar dob = this.toDate();\n\t\t\t\n\t\t\tdob.setFullYear( parseInt( this.getCorrectYear( this.crctLength( Number( this.format( 'YYYY' ) ) % 100, 2 ) ) ) );\n\t\t\treturn this;\n\t\t}\n\n\t\tfunction i18N( format, callBack, convert_numbers ){\n\t\t\tif( this.validate() ){\n\n\t\t\t\tif( callBack == true ){\n\t\t\t\t\tconvert_numbers = callBack;\n\t\t\t\t\tcallBack = void 0;\n\t\t\t\t} else if( format == true ){\n\t\t\t\t\tconvert_numbers = format;\n\t\t\t\t\tformat = void 0;\n\t\t\t\t}\n\n\t\t\t\tformat = format || \"YYYY-MM-DDTHH:mm:ssZ\";\n\n\t\t\t\tvar parsed = this.parseFormat( this.replaceTxt( format ) ).reverse();\n\t\t\t\tformat = format.replace( /{{|}}/g, '' );\n\n\t\t\t\tif( convert_numbers ){\n\t\t\t\t\tconvert_numbers = window._lyteUiUtils ? window._lyteUiUtils.i18n( \"1\" ) != \"1\" : false;\n\t\t\t\t}\n\n\t\t\t\tparsed.forEach( function( item ){\n\t\t\t\t\tvar __format = item.format,\n\t\t\t\t\tvalue = __format.val,\n\t\t\t\t\tformatted = this.format( value ),\n\t\t\t\t\ti18ned = window._lyteUiUtils && !/^[0-9]$/.test( formatted || \"\" ) ? window._lyteUiUtils.i18n( formatted ) : formatted,\n\t\t\t\t\tindex = item.index;\n\n\t\t\t\t\tif( convert_numbers && !__format.str ){\n\t\t\t\t\t\tfor( var i = 0; i < 10; i++ ){\n\t\t\t\t\t\t\ti18ned = i18ned.replace( new RegExp( i, \"g\" ) , window._lyteUiUtils.i18n( i.toString() ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tformat = format.slice( 0, index ) + ( callBack ? callBack( formatted, i18ned, value ) : i18ned ) + format.slice( index + value.length );\n\t\t\t\t}.bind( this ) );\n\n\t\t\t\treturn format;\n\t\t\t}\n\t\t}\n\n\t\tfunction add_value( value ){\n\n\t\t\tvar ref_date = parseInt( this.format( 'DD' ) );\n\n\t\t\twhile( value-- ){\n\t\t\t\tvar ref_moment = $L.moment( this ).endOf( 'month' ), \n\t\t\t\tcur_end = parseInt( ref_moment.format( 'DD' ) ),\n\t\t\t\tend = parseInt( ref_moment.add( 1, 'milliseconds' ).endOf( 'month' ).format( 'DD' ) ),\n\t\t\t\tto_add = Math.max( cur_end, ref_date ) - ref_date + Math.min( ref_date, end );\n\n\t\t\t\tthis.add( to_add, 'day' );\n\t\t\t}\n\n\t\t}\n\n\t\tfunction deduct_value( value ){\n\t\t\t\n\t\t\tvar ref_date = parseInt( this.format( 'DD' ) );\n\n\t\t\twhile( value-- ){\n\t\t\t\tvar ref_moment = $L.moment( this ).startOf( 'month' ), \n\t\t\t\tcur_date = parseInt( this.format( 'DD' ) ),\n\t\t\t\tend = parseInt( ref_moment.subtract( 1, 'milliseconds' ).format( 'DD' ) ),\n\t\t\t\tto_subtract = cur_date + Math.max( 0, end - ref_date );\n\n\t\t\t\tthis.subtract( to_subtract, 'day' );\n\t\t\t}\n\t\t}\n\n\t}\n} );",";( function( cb ){\n\tif( typeof define == \"function\" && define.amd ){\n\t\tdefine( [ \"@zoho/lyte-dom\" ], cb );\n\t} else {\n\t\tcb( window.$L );\n\t}\n} )( function( $L ){\n\tif( $L ){\n\t\tvar shortMon = [ 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec' ],\n\t\tlongMon = [ 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'  ],\n\t\tweekLong = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n\t\tweekMid = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n\t\tweekShort = [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"],\n\t\tdayArr = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ],\n\t\tweek = 'W', wod = 1,\n\t\tlm = \"lyteMoment\",\n\t\tuLimit = 19,\n\t\tlLimit = 80,\n\t\ttimeZoneOffsets = {\"Etc/GMT+12\":-720,\"Etc/GMT+11\":-660,\"Pacific/Midway\":-660,\"Pacific/Niue\":-660,\"Pacific/Pago_Pago\":-660,\"Pacific/Samoa\":-660,\"US/Samoa\":-660,\"America/Adak\":-540,\"America/Atka\":-540,\"Etc/GMT+10\":-600,\"HST\":-600,\"Pacific/Honolulu\":-600,\"Pacific/Johnston\":-600,\"Pacific/Rarotonga\":-600,\"Pacific/Tahiti\":-600,\"SystemV/HST10\":-600,\"US/Aleutian\":-540,\"US/Hawaii\":-600,\"Pacific/Marquesas\":-510,\"AST\":-480,\"America/Anchorage\":-480,\"America/Juneau\":-480,\"America/Metlakatla\":-480,\"America/Nome\":-480,\"America/Sitka\":-480,\"America/Yakutat\":-480,\"Etc/GMT+9\":-540,\"Pacific/Gambier\":-540,\"SystemV/YST9\":-540,\"SystemV/YST9YDT\":-480,\"US/Alaska\":-480,\"America/Ensenada\":-420,\"America/Los_Angeles\":-420,\"America/Santa_Isabel\":-420,\"America/Tijuana\":-420,\"America/Vancouver\":-420,\"Canada/Pacific\":-420,\"Etc/GMT+8\":-480,\"Mexico/BajaNorte\":-420,\"PST\":-480,\"PST8PDT\":-420,\"Pacific/Pitcairn\":-480,\"SystemV/PST8\":-480,\"SystemV/PST8PDT\":-420,\"US/Pacific\":-420,\"America/Boise\":-360,\"America/Cambridge_Bay\":-360,\"America/Chihuahua\":-360,\"America/Creston\":-420,\"America/Dawson\":-420,\"America/Dawson_Creek\":-420,\"America/Denver\":-360,\"America/Edmonton\":-360,\"America/Fort_Nelson\":-420,\"America/Hermosillo\":-420,\"America/Inuvik\":-360,\"America/Mazatlan\":-360,\"America/Ojinaga\":-360,\"America/Phoenix\":-420,\"America/Shiprock\":-360,\"America/Whitehorse\":-420,\"America/Yellowknife\":-360,\"Canada/Mountain\":-360,\"Canada/Yukon\":-420,\"Etc/GMT+7\":-420,\"MST\":-420,\"MST7MDT\":-360,\"Mexico/BajaSur\":-360,\"Navajo\":-360,\"PNT\":-420,\"SystemV/MST7\":-420,\"SystemV/MST7MDT\":-360,\"US/Arizona\":-420,\"US/Mountain\":-360,\"America/Bahia_Banderas\":-300,\"America/Belize\":-360,\"America/Chicago\":-300,\"America/Costa_Rica\":-360,\"America/El_Salvador\":-360,\"America/Guatemala\":-360,\"America/Indiana/Knox\":-300,\"America/Indiana/Tell_City\":-300,\"America/Knox_IN\":-300,\"America/Managua\":-360,\"America/Matamoros\":-300,\"America/Menominee\":-300,\"America/Merida\":-300,\"America/Mexico_City\":-300,\"America/Monterrey\":-300,\"America/North_Dakota/Beulah\":-300,\"America/North_Dakota/Center\":-300,\"America/North_Dakota/New_Salem\":-300,\"America/Rainy_River\":-300,\"America/Rankin_Inlet\":-300,\"America/Regina\":-360,\"America/Resolute\":-300,\"America/Swift_Current\":-360,\"America/Tegucigalpa\":-360,\"America/Winnipeg\":-300,\"CST\":-360,\"CST6CDT\":-300,\"Canada/Central\":-300,\"Canada/Saskatchewan\":-360,\"Chile/EasterIsland\":-360,\"Etc/GMT+6\":-360,\"Mexico/General\":-300,\"Pacific/Easter\":-360,\"Pacific/Galapagos\":-360,\"SystemV/CST6\":-360,\"SystemV/CST6CDT\":-300,\"US/Central\":-300,\"US/Indiana-Starke\":-300,\"America/Atikokan\":-300,\"America/Bogota\":-300,\"America/Cancun\":-300,\"America/Cayman\":-300,\"America/Coral_Harbour\":-300,\"America/Detroit\":-240,\"America/Eirunepe\":-300,\"America/Fort_Wayne\":-240,\"America/Grand_Turk\":-240,\"America/Guayaquil\":-300,\"America/Havana\":-240,\"America/Indiana/Indianapolis\":-240,\"America/Indiana/Marengo\":-240,\"America/Indiana/Petersburg\":-240,\"America/Indiana/Vevay\":-240,\"America/Indiana/Vincennes\":-240,\"America/Indiana/Winamac\":-240,\"America/Indianapolis\":-240,\"America/Iqaluit\":-240,\"America/Jamaica\":-300,\"America/Kentucky/Louisville\":-240,\"America/Kentucky/Monticello\":-240,\"America/Lima\":-300,\"America/Louisville\":-240,\"America/Montreal\":-240,\"America/Nassau\":-240,\"America/New_York\":-240,\"America/Nipigon\":-240,\"America/Panama\":-300,\"America/Pangnirtung\":-240,\"America/Port-au-Prince\":-240,\"America/Porto_Acre\":-300,\"America/Rio_Branco\":-300,\"America/Thunder_Bay\":-240,\"America/Toronto\":-240,\"Brazil/Acre\":-300,\"Canada/Eastern\":-240,\"Cuba\":-240,\"EST\":-300,\"EST5EDT\":-240,\"Etc/GMT+5\":-300,\"IET\":-240,\"Jamaica\":-300,\"SystemV/EST5\":-300,\"SystemV/EST5EDT\":-240,\"US/East-Indiana\":-240,\"US/Eastern\":-240,\"US/Michigan\":-240,\"America/Anguilla\":-240,\"America/Antigua\":-240,\"America/Aruba\":-240,\"America/Asuncion\":-240,\"America/Barbados\":-240,\"America/Blanc-Sablon\":-240,\"America/Boa_Vista\":-240,\"America/Campo_Grande\":-240,\"America/Caracas\":-240,\"America/Cuiaba\":-240,\"America/Curacao\":-240,\"America/Dominica\":-240,\"America/Glace_Bay\":-180,\"America/Goose_Bay\":-180,\"America/Grenada\":-240,\"America/Guadeloupe\":-240,\"America/Guyana\":-240,\"America/Halifax\":-180,\"America/Kralendijk\":-240,\"America/La_Paz\":-240,\"America/Lower_Princes\":-240,\"America/Manaus\":-240,\"America/Marigot\":-240,\"America/Martinique\":-240,\"America/Moncton\":-180,\"America/Montserrat\":-240,\"America/Port_of_Spain\":-240,\"America/Porto_Velho\":-240,\"America/Puerto_Rico\":-240,\"America/Santiago\":-240,\"America/Santo_Domingo\":-240,\"America/St_Barthelemy\":-240,\"America/St_Kitts\":-240,\"America/St_Lucia\":-240,\"America/St_Thomas\":-240,\"America/St_Vincent\":-240,\"America/Thule\":-180,\"America/Tortola\":-240,\"America/Virgin\":-240,\"Atlantic/Bermuda\":-180,\"Brazil/West\":-240,\"Canada/Atlantic\":-180,\"Chile/Continental\":-240,\"Etc/GMT+4\":-240,\"PRT\":-240,\"SystemV/AST4\":-240,\"SystemV/AST4ADT\":-180,\"America/St_Johns\":-90,\"CNT\":-90,\"Canada/Newfoundland\":-90,\"AGT\":-180,\"America/Araguaina\":-180,\"America/Argentina/Buenos_Aires\":-180,\"America/Argentina/Catamarca\":-180,\"America/Argentina/ComodRivadavia\":-180,\"America/Argentina/Cordoba\":-180,\"America/Argentina/Jujuy\":-180,\"America/Argentina/La_Rioja\":-180,\"America/Argentina/Mendoza\":-180,\"America/Argentina/Rio_Gallegos\":-180,\"America/Argentina/Salta\":-180,\"America/Argentina/San_Juan\":-180,\"America/Argentina/San_Luis\":-180,\"America/Argentina/Tucuman\":-180,\"America/Argentina/Ushuaia\":-180,\"America/Bahia\":-180,\"America/Belem\":-180,\"America/Buenos_Aires\":-180,\"America/Catamarca\":-180,\"America/Cayenne\":-180,\"America/Cordoba\":-180,\"America/Fortaleza\":-180,\"America/Godthab\":-120,\"America/Jujuy\":-180,\"America/Maceio\":-180,\"America/Mendoza\":-180,\"America/Miquelon\":-120,\"America/Montevideo\":-180,\"America/Nuuk\":-120,\"America/Paramaribo\":-180,\"America/Punta_Arenas\":-180,\"America/Recife\":-180,\"America/Rosario\":-180,\"America/Santarem\":-180,\"America/Sao_Paulo\":-180,\"Antarctica/Palmer\":-180,\"Antarctica/Rothera\":-180,\"Atlantic/Stanley\":-180,\"BET\":-180,\"Brazil/East\":-180,\"Etc/GMT+3\":-180,\"America/Noronha\":-120,\"Atlantic/South_Georgia\":-120,\"Brazil/DeNoronha\":-120,\"Etc/GMT+2\":-120,\"America/Scoresbysund\":0,\"Atlantic/Azores\":0,\"Atlantic/Cape_Verde\":-60,\"Etc/GMT+1\":-60,\"Africa/Abidjan\":0,\"Africa/Accra\":0,\"Africa/Bamako\":0,\"Africa/Banjul\":0,\"Africa/Bissau\":0,\"Africa/Casablanca\":0,\"Africa/Conakry\":0,\"Africa/Dakar\":0,\"Africa/El_Aaiun\":0,\"Africa/Freetown\":0,\"Africa/Lome\":0,\"Africa/Monrovia\":0,\"Africa/Nouakchott\":0,\"Africa/Ouagadougou\":0,\"Africa/Sao_Tome\":0,\"Africa/Timbuktu\":0,\"America/Danmarkshavn\":0,\"Antarctica/Troll\":120,\"Atlantic/Canary\":60,\"Atlantic/Faeroe\":60,\"Atlantic/Faroe\":60,\"Atlantic/Madeira\":60,\"Atlantic/Reykjavik\":0,\"Atlantic/St_Helena\":0,\"Eire\":60,\"Etc/GMT\":-0,\"Etc/GMT+0\":-0,\"Etc/GMT-0\":-0,\"Etc/GMT0\":-0,\"Etc/Greenwich\":-0,\"Etc/UCT\":-0,\"Etc/UTC\":-0,\"Etc/Universal\":-0,\"Etc/Zulu\":-0,\"Europe/Belfast\":60,\"Europe/Dublin\":60,\"Europe/Guernsey\":60,\"Europe/Isle_of_Man\":60,\"Europe/Jersey\":60,\"Europe/Lisbon\":60,\"Europe/London\":60,\"GB\":60,\"GB-Eire\":60,\"GMT\":0,\"GMT0\":0,\"Greenwich\":0,\"Iceland\":0,\"Portugal\":60,\"UCT\":0,\"UTC\":0,\"Universal\":0,\"WET\":60,\"Zulu\":0,\"Africa/Algiers\":60,\"Africa/Bangui\":60,\"Africa/Brazzaville\":60,\"Africa/Ceuta\":120,\"Africa/Douala\":60,\"Africa/Kinshasa\":60,\"Africa/Lagos\":60,\"Africa/Libreville\":60,\"Africa/Luanda\":60,\"Africa/Malabo\":60,\"Africa/Ndjamena\":60,\"Africa/Niamey\":60,\"Africa/Porto-Novo\":60,\"Africa/Tunis\":60,\"Arctic/Longyearbyen\":120,\"Atlantic/Jan_Mayen\":120,\"CET\":120,\"ECT\":120,\"Etc/GMT-1\":60,\"Europe/Amsterdam\":120,\"Europe/Andorra\":120,\"Europe/Belgrade\":120,\"Europe/Berlin\":120,\"Europe/Bratislava\":120,\"Europe/Brussels\":120,\"Europe/Budapest\":120,\"Europe/Busingen\":120,\"Europe/Copenhagen\":120,\"Europe/Gibraltar\":120,\"Europe/Ljubljana\":120,\"Europe/Luxembourg\":120,\"Europe/Madrid\":120,\"Europe/Malta\":120,\"Europe/Monaco\":120,\"Europe/Oslo\":120,\"Europe/Paris\":120,\"Europe/Podgorica\":120,\"Europe/Prague\":120,\"Europe/Rome\":120,\"Europe/San_Marino\":120,\"Europe/Sarajevo\":120,\"Europe/Skopje\":120,\"Europe/Stockholm\":120,\"Europe/Tirane\":120,\"Europe/Vaduz\":120,\"Europe/Vatican\":120,\"Europe/Vienna\":120,\"Europe/Warsaw\":120,\"Europe/Zagreb\":120,\"Europe/Zurich\":120,\"MET\":120,\"Poland\":120,\"ART\":120,\"Africa/Blantyre\":120,\"Africa/Bujumbura\":120,\"Africa/Cairo\":120,\"Africa/Gaborone\":120,\"Africa/Harare\":120,\"Africa/Johannesburg\":120,\"Africa/Khartoum\":120,\"Africa/Kigali\":120,\"Africa/Lubumbashi\":120,\"Africa/Lusaka\":120,\"Africa/Maputo\":120,\"Africa/Maseru\":120,\"Africa/Mbabane\":120,\"Africa/Tripoli\":120,\"Africa/Windhoek\":120,\"Asia/Amman\":180,\"Asia/Beirut\":180,\"Asia/Damascus\":180,\"Asia/Famagusta\":180,\"Asia/Gaza\":180,\"Asia/Hebron\":180,\"Asia/Jerusalem\":180,\"Asia/Nicosia\":180,\"Asia/Tel_Aviv\":180,\"CAT\":120,\"EET\":180,\"Egypt\":120,\"Etc/GMT-2\":120,\"Europe/Athens\":180,\"Europe/Bucharest\":180,\"Europe/Chisinau\":180,\"Europe/Helsinki\":180,\"Europe/Kaliningrad\":120,\"Europe/Kiev\":180,\"Europe/Mariehamn\":180,\"Europe/Nicosia\":180,\"Europe/Riga\":180,\"Europe/Sofia\":180,\"Europe/Tallinn\":180,\"Europe/Tiraspol\":180,\"Europe/Uzhgorod\":180,\"Europe/Vilnius\":180,\"Europe/Zaporozhye\":180,\"Israel\":180,\"Libya\":120,\"Africa/Addis_Ababa\":180,\"Africa/Asmara\":180,\"Africa/Asmera\":180,\"Africa/Dar_es_Salaam\":180,\"Africa/Djibouti\":180,\"Africa/Juba\":180,\"Africa/Kampala\":180,\"Africa/Mogadishu\":180,\"Africa/Nairobi\":180,\"Antarctica/Syowa\":180,\"Asia/Aden\":180,\"Asia/Baghdad\":180,\"Asia/Bahrain\":180,\"Asia/Istanbul\":180,\"Asia/Kuwait\":180,\"Asia/Qatar\":180,\"Asia/Riyadh\":180,\"EAT\":180,\"Etc/GMT-3\":180,\"Europe/Istanbul\":180,\"Europe/Kirov\":180,\"Europe/Minsk\":180,\"Europe/Moscow\":180,\"Europe/Simferopol\":180,\"Indian/Antananarivo\":180,\"Indian/Comoro\":180,\"Indian/Mayotte\":180,\"Turkey\":180,\"W-SU\":180,\"Asia/Tehran\":270,\"Iran\":270,\"Asia/Baku\":240,\"Asia/Dubai\":240,\"Asia/Muscat\":240,\"Asia/Tbilisi\":240,\"Asia/Yerevan\":240,\"Etc/GMT-4\":240,\"Europe/Astrakhan\":240,\"Europe/Samara\":240,\"Europe/Saratov\":240,\"Europe/Ulyanovsk\":240,\"Europe/Volgograd\":240,\"Indian/Mahe\":240,\"Indian/Mauritius\":240,\"Indian/Reunion\":240,\"NET\":240,\"Asia/Kabul\":270,\"Antarctica/Mawson\":300,\"Asia/Aqtau\":300,\"Asia/Aqtobe\":300,\"Asia/Ashgabat\":300,\"Asia/Ashkhabad\":300,\"Asia/Atyrau\":300,\"Asia/Dushanbe\":300,\"Asia/Karachi\":300,\"Asia/Oral\":300,\"Asia/Qyzylorda\":300,\"Asia/Samarkand\":300,\"Asia/Tashkent\":300,\"Asia/Yekaterinburg\":300,\"Etc/GMT-5\":300,\"Indian/Kerguelen\":300,\"Indian/Maldives\":300,\"PLT\":300,\"Asia/Calcutta\":330,\"Asia/Colombo\":330,\"Asia/Kolkata\":330,\"IST\":330,\"Asia/Kathmandu\":345,\"Asia/Katmandu\":345,\"Antarctica/Vostok\":360,\"Asia/Almaty\":360,\"Asia/Bishkek\":360,\"Asia/Dacca\":360,\"Asia/Dhaka\":360,\"Asia/Kashgar\":360,\"Asia/Omsk\":360,\"Asia/Qostanay\":360,\"Asia/Thimbu\":360,\"Asia/Thimphu\":360,\"Asia/Urumqi\":360,\"BST\":360,\"Etc/GMT-6\":360,\"Indian/Chagos\":360,\"Asia/Rangoon\":390,\"Asia/Yangon\":390,\"Indian/Cocos\":390,\"Antarctica/Davis\":420,\"Asia/Bangkok\":420,\"Asia/Barnaul\":420,\"Asia/Ho_Chi_Minh\":420,\"Asia/Hovd\":420,\"Asia/Jakarta\":420,\"Asia/Krasnoyarsk\":420,\"Asia/Novokuznetsk\":420,\"Asia/Novosibirsk\":420,\"Asia/Phnom_Penh\":420,\"Asia/Pontianak\":420,\"Asia/Saigon\":420,\"Asia/Tomsk\":420,\"Asia/Vientiane\":420,\"Etc/GMT-7\":420,\"Indian/Christmas\":420,\"VST\":420,\"Asia/Brunei\":480,\"Asia/Choibalsan\":480,\"Asia/Chongqing\":480,\"Asia/Chungking\":480,\"Asia/Harbin\":480,\"Asia/Hong_Kong\":480,\"Asia/Irkutsk\":480,\"Asia/Kuala_Lumpur\":480,\"Asia/Kuching\":480,\"Asia/Macao\":480,\"Asia/Macau\":480,\"Asia/Makassar\":480,\"Asia/Manila\":480,\"Asia/Shanghai\":480,\"Asia/Singapore\":480,\"Asia/Taipei\":480,\"Asia/Ujung_Pandang\":480,\"Asia/Ulaanbaatar\":480,\"Asia/Ulan_Bator\":480,\"Australia/Perth\":480,\"Australia/West\":480,\"CTT\":480,\"Etc/GMT-8\":480,\"Hongkong\":480,\"PRC\":480,\"Singapore\":480,\"Australia/Eucla\":525,\"Asia/Chita\":540,\"Asia/Dili\":540,\"Asia/Jayapura\":540,\"Asia/Khandyga\":540,\"Asia/Pyongyang\":540,\"Asia/Seoul\":540,\"Asia/Tokyo\":540,\"Asia/Yakutsk\":540,\"Etc/GMT-9\":540,\"JST\":540,\"Japan\":540,\"Pacific/Palau\":540,\"ROK\":540,\"ACT\":570,\"Australia/Adelaide\":570,\"Australia/Broken_Hill\":570,\"Australia/Darwin\":570,\"Australia/North\":570,\"Australia/South\":570,\"Australia/Yancowinna\":570,\"AET\":600,\"Antarctica/DumontDUrville\":600,\"Antarctica/Macquarie\":600,\"Asia/Ust-Nera\":600,\"Asia/Vladivostok\":600,\"Australia/ACT\":600,\"Australia/Brisbane\":600,\"Australia/Canberra\":600,\"Australia/Currie\":600,\"Australia/Hobart\":600,\"Australia/Lindeman\":600,\"Australia/Melbourne\":600,\"Australia/NSW\":600,\"Australia/Queensland\":600,\"Australia/Sydney\":600,\"Australia/Tasmania\":600,\"Australia/Victoria\":600,\"Etc/GMT-10\":600,\"Pacific/Chuuk\":600,\"Pacific/Guam\":600,\"Pacific/Port_Moresby\":600,\"Pacific/Saipan\":600,\"Pacific/Truk\":600,\"Pacific/Yap\":600,\"Australia/LHI\":630,\"Australia/Lord_Howe\":630,\"Antarctica/Casey\":660,\"Asia/Magadan\":660,\"Asia/Sakhalin\":660,\"Asia/Srednekolymsk\":660,\"Etc/GMT-11\":660,\"Pacific/Bougainville\":660,\"Pacific/Efate\":660,\"Pacific/Guadalcanal\":660,\"Pacific/Kosrae\":660,\"Pacific/Norfolk\":660,\"Pacific/Noumea\":660,\"Pacific/Pohnpei\":660,\"Pacific/Ponape\":660,\"SST\":660,\"Antarctica/McMurdo\":720,\"Antarctica/South_Pole\":720,\"Asia/Anadyr\":720,\"Asia/Kamchatka\":720,\"Etc/GMT-12\":720,\"Kwajalein\":720,\"NST\":720,\"NZ\":720,\"Pacific/Auckland\":720,\"Pacific/Fiji\":720,\"Pacific/Funafuti\":720,\"Pacific/Kwajalein\":720,\"Pacific/Majuro\":720,\"Pacific/Nauru\":720,\"Pacific/Tarawa\":720,\"Pacific/Wake\":720,\"Pacific/Wallis\":720,\"NZ-CHAT\":765,\"Pacific/Chatham\":765,\"Etc/GMT-13\":780,\"MIT\":780,\"Pacific/Apia\":780,\"Pacific/Enderbury\":780,\"Pacific/Fakaofo\":780,\"Pacific/Tongatapu\":780,\"Etc/GMT-14\":840,\"Pacific/Kiritimati\":840,\"UT\":0,\"EDT\":-240,\"CDT\":-300,\"MDT\":-360,\"PDT\":-420},\n\t\t\n\t\ttimezone_regex = new RegExp( '(' + Object.keys( timeZoneOffsets ).join('|') + ')' ),\n\n\t\tdefault_timezone,\n\t\tdefault_offset,\n\n\t\tis_IE,\n\n\t\tformats = [\n\t\t\t{ val :'YYYY', type : 'year', regex : /\\d{4}/, len : 4 },\n\t\t\t{ val : 'GGGG', type : 'year', regex : /\\d{4}/, len : 4, isWEG : true }, \n\t\t\t{ val : 'gggg', type : 'year', regex : /\\d{4}/, len : 4, isWEG : true }, \n\t\t\t{ val : 'YY', type : 'year', regex : /\\d{2}/, len : 2 }, \n\t\t\t{ val : 'GG', type : 'year', regex : /\\d{2}/, len : 2, isWEG : true}, \n\t\t\t{ val : 'gg', type : 'year', regex : /\\d{2}/, len : 2, isWEG : true}, \n\t\t\t{ val : 'MMMM', type : \"month\", regex : /[A-z]{3,}/, long : true, str : true, array : longMon }, \n\t\t\t{ val : 'MMM', str : true, type : \"month\", regex : /[A-z]{3,}/, array : shortMon }, \n\t\t\t{ val : 'Mo', suff : true, type : \"month\", regex : /\\d{1,2}(?=st|nd|rd|th)/, max : 12 }, \n\t\t\t{ val : 'MM', type : \"month\", regex : /\\d{2}/, len : 2, max : 12, alt : true }, \n\t\t\t{ val : 'M', type : \"month\", regex : /\\d{1,2}/, max : 12 }, \n\t\t\t{ val : 'DDDD', type : 'date', regex : /\\d{3}/, len : 3, year : true }, \n\t\t\t{ val : 'DDDo', type : 'date', suff : true, regex : /\\d{1,3}(?=st|nd|rd|th)/, len : 3, year : true, ignore : /\\d{3}(?=st|nd|rd|th)/ }, \n\t\t\t{ val : 'DDD', type : 'date', regex : /\\d{1,3}/, year : true, ignore : /\\d{3}/}, \n\t\t\t{ val : 'Do', type : 'date', suff : true , regex : /\\d{1,2}(?=st|nd|rd|th)/ }, \n\t\t\t{ val : 'DD', type : 'date', regex : /\\d{2}/, len : 2, alt : true }, \n\t\t\t{ val : 'D', type : 'date', regex : /\\d{1,2}/ }, \n\t\t\t{ val : '[' + week + ']Wo', type : 'week', suff : true, regex : new RegExp('\\[' + week + '\\]\\d{1,2}(?=st|nd|th|rd)'), isWEG : true },\n\t\t\t{ val : '[' + week + ']wo', ignore : 1, type : 'week', suff : true, regex : new RegExp('\\[' + week + '\\]\\d{1,2}(?=st|nd|th|rd)'), isWEG : true }, \n\t\t\t{ val : '[' + week + ']WW', type : 'week', regex : new RegExp( week +'(\\\\d{2})'), len : 2, isWEG : true, match : 1 }, \n\t\t\t{ val : '[' + week + ']ww', ignore : 1, type : 'week', regex : new RegExp( week +'(\\\\d{2})'), len : 2, isWEG : true, match : 1 }, \n\t\t\t{ val : '[' + week + ']W', type : 'week', regex : new RegExp( week +'(\\\\d{1,2})'), isWEG : true, match : 1 }, \n\t\t\t{ val : '[' + week + ']w', ignore : 1, type : 'week', regex : new RegExp( week +'(\\\\d{1,2})'), isWEG : true, match : 1 }, \n\t\t\t{ val : 'Wo', type : 'week', pref : 0, suff : true, regex : new RegExp('\\[' + week + '\\]\\d{1,2}(?=st|nd|th|rd)'), isWEG : true },\n\t\t\t{ val : 'wo', type : 'week', pref : 0, ignore : 1, suff : true, regex : new RegExp('\\[' + week + '\\]\\d{1,2}(?=st|nd|th|rd)'), isWEG : true }, \n\t\t\t{ val : 'WW', type : 'week', pref : 0, regex : new RegExp( '(\\\\d{2})'), len : 2, isWEG : true, match : 1 }, \n\t\t\t{ val : 'ww', type : 'week', pref : 0, ignore : 1, regex : new RegExp( '(\\\\d{2})'), len : 2, isWEG : true, match : 1 }, \n\t\t\t{ val : 'W', type : 'week', pref : 0, regex : new RegExp( '(\\\\d{1,2})'), isWEG : true, match : 1 }, \n\t\t\t{ val : 'w', type : 'week', pref : 0, ignore : 1, regex : new RegExp( '(\\\\d{1,2})'), isWEG : true, match : 1 }, \n\t\t\t{ val : 'E', type : 'day', regex : /\\d{1}/, isWEG : true }, \n\t\t\t{ val : 'e', type : 'day', regex : /\\d{1}/, isWEG : true, local : true }, \n\t\t\t{ val : 'A', type : 'meridian', regex : /AM|PM/, str : true, time : true },\n\t\t\t{ val : 'a', type : 'meridian', regex : /am|pm/, str : true, time : true, lower : true },\n\t\t\t{ val : 'ZZ', type : 'timezone', regex : /(\\+|\\-)(\\d{2})(\\d{2})$/, time : true, len : 2 },\n\t\t\t{ val : 'Z', type : 'timezone', regex : /(\\+|\\-)(\\d{2}):(\\d{2})$/, time : true, len : 2 },\n\t\t\t{ val : 'HH', type : 'hour', regex : /\\d{2}/, railway : true, time : true, len : 2, max : 23 },\n\t\t\t{ val : 'H', type : 'hour', regex : /\\d{1,2}/, railway : true, time : true, max : 23 },\n\t\t\t{ val : 'hh', type : 'hour', regex : /\\d{2}/, time : true, len : 2, max : 12, min : 1 },\n\t\t\t{ val : 'h', type : 'hour', regex : /\\d{1,2}/, time : true, max : 12, min : 1 },\n\t\t\t{ val : 'kk', type : 'hour', regex : /\\d{2}/, railway : true, time : true, len : 2, max : 24, deduct : -1 },\n\t\t\t{ val : 'k', type : 'hour', regex : /\\d{1,2}/, railway : true, time : true, max : 24, deduct : -1 },\n\t\t\t{ val : 'mm', type : 'minute', regex : /\\d{2}/, time : true, len : 2, max : 59 },\n\t\t\t{ val : 'm', type : 'minute', regex : /\\d{1,2}/, time : true, max : 59 },\n\t\t\t{ val : 'ss', type : 'second', regex : /\\d{2}/, time : true, len : 2, max : 59 },\n\t\t\t{ val : 's', type : 'second', regex : /\\d{1,2}/, time : true, max : 59 },\n\t\t\t{ val : 'S', type : 'millisecond', regex : /[0-9]{1,}/, time : true, valForm : /[S]+/ },\n\t\t\t{ val : 'zz', type : 'timezone', regex : timezone_regex, str : true, time : true },\n\t\t\t{ val : 'z', type : 'timezone', regex : timezone_regex, str : true, time : true },\n\t\t\t{ val : 'X', type : 'timestamp', regex : /\\d{10}/, time : true},\n\t\t\t{ val : 'x', type : 'timestamp', regex : /\\d{13,}/, time : true, milli : true}, \n\t\t\t{ val : 'dddd', type : \"longdate\", regex : /[A-z]{3,}/, long : true, str : true, array : weekLong },\n\t\t\t{ val : 'ddd', type : \"longdate\", regex : /[A-z]{3}/, str : true, array : weekMid },\n\t\t\t{ val : 'dd', type : \"longdate\", regex : /[A-z]{2}/, str : true, array : weekShort },\n\t\t\t{ val : 'do', type : \"longdate\", regex : /\\d{1}(?=st|nd|rd|th)/, suff : true},\n\t\t\t{ val : 'd', type : 'longdate', regex : /\\d{1}/ },\n\t\t\t{ val : 'Qo', type : 'quarter', regex : /\\d{1}(?=st|nd|rd|th)/, suff : true }, \n\t\t\t{ val : 'Q', type : 'quarter', regex : /\\d{1}/ }\n\t\t\t];\n\n\t\t\t( function(){\n\t\t\ttry{\n\t\t\t\tnew Date().toLocaleString( \"en-US\", { timeZone: 'Europe/London' } )\n\t\t\t\t//    new Intl.DateTimeFormat('en-US', {\n\t\t\t\t//   year: 'numeric', month: 'numeric', day: 'numeric',\n\t\t\t\t//   hour: 'numeric', minute: 'numeric', second: 'numeric',\n\t\t\t\t//   timeZone: 'Europe/London'\n\t\t\t\t// }).format( new Date() );\n\t\t\t} catch( e ){\n\t\t\t\tis_IE = true;\n\t\t\t}\n\t\t\t})();\n\n\t\tfunction convert_frm_i18n( format, arg, number_conversion, callback ){\n\n\t\t\tvar parsed = this.parseFormat( this.replaceTxt( format ) ).reverse();\n\t\t\tformat = format.replace( /{{|}}/g, '' );\n\n\t\t\tparsed.forEach( function( item ){\n\t\t\t\tvar arr = item.format.array || [],\n\t\t\t\tfn = window._lyteUiUtils;\n\n\t\t\t\tif( item.format.type == 'meridian' ){\n\t\t\t\t\tarr = item.format.lower ? [ 'am', 'pm' ] : [ 'AM', 'PM' ];\n\t\t\t\t}\n\n\t\t\t\tif( number_conversion && !item.format.str && fn && fn.i18n( \"1\" ) != \"1\" ){\n\t\t\t\t\tarr = [ \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\" ];\n\t\t\t\t}\n\n\t\t\t\tArray.from( arr ).reverse().forEach( function( _item ){\n\t\t\t\t\tvar conv = fn ? fn.i18n( _item ) : _item ;\n\n\t\t\t\t\tif( callback ){\n\t\t\t\t\t\tconv = callback( arg, _item, conv, item.format.val ) || conv;\n\t\t\t\t\t}\n\n\t\t\t\t\tif( _item == conv ){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\targ = replace_original( arg, _item, conv );\n\t\t\t\t});\n\t\t\t});\n\t\t\treturn arg;\n\t\t}\n\n\t\tfunction replace_original( arg, original, i18n ){\n\t\t\tvar index = arg.indexOf( i18n );\n\t\t\tif( index != -1 ){\n\t\t\t\treturn replace_original( arg.replace( i18n, original ), original, i18n );\n\t\t\t}\n\t\t\treturn arg;\n\t\t}\n\n\t\tfunction lyteMoment( arg, format, uL, lL ){\n\n\t\t\tif( arg ){\n\t\t\t\tthis._arg = arg; \n\t\t\t}\n\t\t\tthis._format = format;\n\t\t\tvar ret = isEmpty( arg ),\n\t\t\tconvert_i18n,\n\t\t\ti18n_callback,\n\t\t\tignore_timezone,\n\t\t\tinstance_timezone,\n\t\t\tinstance_offset,\n\t\t\tnumber_conversion,\n\t\t\t__wod;\n\n\t\t\tif( ret ) {\n\t\t\t\targ = new Date();\n\t\t\t}\n\n\t\t\tif( uL && uL.constructor == Object ){\n\t\t\t\tlL = uL.lL;\n\t\t\t\tconvert_i18n = uL.i18n;\n\t\t\t\ti18n_callback = uL.i18n_callback;\n\t\t\t\tignore_timezone = uL.ignore_timezone;\n\t\t\t\tinstance_timezone = uL.timezone;\n\t\t\t\tinstance_offset = uL.timezoneOffset;\n\t\t\t\t__wod = uL.wod;\n\t\t\t\tnumber_conversion = uL.number_conversion;\n\t\t\t\tuL = uL.uL;\n\t\t\t}\n\n\t\t\tif( !ignore_timezone ){\n\t\t\t\tthis.timezone( instance_timezone || default_timezone, instance_offset == void 0 ? default_offset : instance_offset );\n\t\t\t}\n\n\t\t\tif( convert_i18n && format && arg && arg.constructor == String ){\n\t\t\t\targ = convert_frm_i18n.call( this, format, arg, number_conversion, i18n_callback );\n\t\t\t}\n\n\t\t\tthis.uL = uL == undefined ? uLimit : uL;\n\t\t\tthis.lL = lL == undefined ? lLimit : lL;\n\t\t\tthis.wod = __wod == void 0 ? wod : __wod;\n\n\t\t\tif( !( isDef( uL ) && isDef( lL ) ) ){\n\t\t\t\tif( uL ){\n\t\t\t\t\tthis.alt = true;\t\t\n\t\t\t\t} else { \n\t\t\t\t\tthis.alt = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._isValid = validate.call( this, arg, format )\n\t\t}\n\n\t\tfunction isDef( arg ) {\n\t\t\treturn arg != undefined;\n\t\t}\n\n\t\tfunction totdate( month, isLeap1, day ){\n\t\t\tvar total = 0;\n\t\t\tfor(var i = 0; i < month; i++ ) {\n\t\t\t\ttotal += dayArr[ i ];\n\t\t\t\tif( isLeap1 && i == 1 ) {\n\t\t\t\t\ttotal += 1;\n\t\t\t\t}\n\t\t\t} \n\t\t\treturn total + ( day || 0 );\n\t\t}\n\n\t\tfunction isEmpty( arg ){\n\t\t\tif( !arg ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvar cons = arg.constructor;\n\t\t\tif( cons == Array && !cons.length ){\n\t\t\t\treturn true;\n\t\t\t} else if( cons == Object && !Object.keys( arg ).length ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\n\t\t}\n\n\t\tfunction isLeap( year ) {\n\t\t\tyear = year + '';\n\t\t\tif( year.length == 2 ) {\n\t\t\t\tyear = getCorrectYear( parseInt( year ) );\n\t\t\t}\n\t\t\tyear = parseInt( year );\n\t\t\treturn ( ( year % 4 == 0 ) && ( year % 100 != 0 ) ) || ( year % 400 == 0 );\n\t\t}\n\n\t\tfunction nthconv( date ) {\n\t\t\t\tif( date > 3 && date < 21 ) {\n\t\t\t\t\treturn 'th'\n\t\t\t\t}\n\t\t\t\tswitch ( date % 10 ) {\n\t\t\t\tcase 1 :  return \"st\";\n\t\t\t\t\tcase 2 :  return \"nd\";\n\t\t\t\t\tcase 3 :  return \"rd\";\n\t\t\t\tdefault : return \"th\";\n\t\t\t\t}\n\t\t}\n\n\t\tfunction replaceTxt( format ) {\n\t\t\tvar matches = format.match( /{{/ ), matches1 = format.match( /}}/ );\n\t\t\tif( !( matches && matches1 ) ) {\n\t\t\t\treturn format;\n\t\t\t}\n\t\t\tformat = format.replace( format.slice( matches.index, matches1.index + 2 ), function( arg ){\n\t\t\t\tvar ret = \"\"\n\t\t\t\tfor( var j = 0; j < arg.length - 4; j++ ) {\n\t\t\t\t\tret += '*';\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t} )\n\t\t\treturn replaceTxt( format );\n\t\t}\n\n\t\tfunction parseFormat( format, validate ) { \n\t\t\tvar forCopy = formats, order = [],\n\t\t\tprev;\n\t\t\tfor( var i = 0; i < forCopy.length; i++ ) {\n\t\t\t\tvar cur = forCopy[ i ];\n\t\t\t\tif( !format.length ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif( format.indexOf( cur.val ) > -1 ) {\n\t\t\t\t\tif( validate && cur.alt ){\n\t\t\t\t\t\tprev = true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tcur = $L.extend( true, {}, cur );\n\n\t\t\t\t\tif( prev ){\n\t\t\t\t\t\tcur.val = forCopy[ i - 1 ].val;\n\t\t\t\t\t}\n\t\t\t\t\tprev = false;\n\t\t\t\t\torder.push( { format : cur, index : format.indexOf( cur.val ) });\n\t\t\t\t\tformat = format.replace( cur.val, Math.pow( 10, cur.val.length - 1 ) );\n\t\t\t\t\ti--;\n\t\t\t\t\tcontinue;\n\t\t\t\t} \n\t\t\t}\n\t\t\treturn order.sort(function( a, b ){\n\t\t\t\t\treturn a.index - b.index\n\t\t\t\t});\n\t\t}\n\n\t\tfunction fmReplace( arg, arr ) {\n\t\t\tvar length = 0;\n\t\t\tfor( var i = 0; i < arr.length; i++ ) {\n\t\t\t\targ = arg.slice( 0, arr[ i ].index + length ) + arr[ i ].format.val + lm + arg.slice( arr[ i ].index + length + arr[ i ].format.val.length );\n\t\t\t\tlength += 10;\n\t\t\t}\n\t\t\treturn arg;\n\t\t}\n\n\t\tfunction replace( arg, val, suff, rep ) {\n\t\t\targ = arg.replace( val, rep || \"\" );\n\t\t\tif( suff ) {\n\t\t\t\targ = arg.replace( /st|nd|rd|th/, '' )\n\t\t\t}\n\t\t\treturn arg;\n\t\t}\n\n\t\tfunction find( array, val ){\n\t\t\tarray = array || [];\n\n\t\t\tvar crct, i,\n\t\t\t__length = array.length;\n\n\t\t\tfor( i = 0; i < __length; i++ ) {\n\t\t\t\tvar __cur = array[ i ];\n\n\t\t\t\tif( new RegExp( __cur ).test( val ) ) {\n\t\t\t\t\tcrct = __cur;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn  { mon : crct, index : i };\n\t\t}\n\n\t\tfunction getMonth( val, suff, str, long ) {\n\t\t\tvar mon;\n\t\t\tif( str ) {\n\t\t\t\tvar ret = find( long ? longMon : shortMon, val );\n\t\t\t\tmon = ret.mon;\n\t\t\t\tval = ret.index;\n\t\t\t\tif( !mon || val > 11 ){\n\t\t\t\t\tval = \"Invalid\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tval = parseInt( val ) - 1;\n\t\t\t\tif( val > 11 ) {\n\t\t\t\t\tval = 'Invalid';\n\t\t\t\t} \n\t\t\t}\n\n\t\t\treturn { val : val, mon : mon };\n\t\t}\n\n\t\tfunction convertTimeZone( arg ) {\n\t\t\tvar ret,\n\t\t\thour = parseInt( arg[ 2 ] ),\n\t\t\tminute = parseInt( arg[ 3 ] );\n\n\t\t\tret = hour * 60 + minute;\n\t\t\treturn arg[ 1 ] == '+' ? ( ret * -1 ) : ret;\n\t\t}\n\n\t\tfunction convertRailway( hour, pm ) {\n\t\t\tif( pm && hour < 12 ) {\n\t\t\t\thour += 12;\n\t\t\t} else if( hour == 12 && !pm ) {\n\t\t\t\thour = 0;\n\t\t\t}\n\t\t\treturn hour;\n\t\t}\n\n\t\tfunction getDay( val, isLeap ) {\n\t\t\tvar val = parseInt( val ), ini = 0, ind = 0, inc = dayArr[ 0 ];\n\t\t\tif( val > ( 365 + ( isLeap ? 1 : 0 ) ) ){\n\t\t\t\treturn {};\n\t\t\t}\n\t\t\twhile( ini + inc < val ) {\n\t\t\t\tini += inc;\n\t\t\t\tind++;\n\t\t\t\tinc = dayArr[ ind ]\n\t\t\t\tif( isLeap && ind == 1 ) {\n\t\t\t\t\tinc += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn { day : val - ini , mon : ind };\n\t\t}\n\n\t\tfunction getWeek( obj ) {\n\t\t\tif( obj.day != undefined || obj.week ) {\n\t\t\t\t// var dtt = new Date( obj.year , 0 ,1 );\n\t\t\t\t// if( !validate.call( this, dtt ) ) {\n\t\t\t\t// \treturn {};\n\t\t\t\t// }\n\t\t\t\t// var dt = dtt.getDay(), isLeap1 = isLeap( obj.year || dtt.getFullYear() ),\n\t\t\t\t// total = wod + obj.week == 1 ? ( obj.day - dt + wod ) : ( obj.week == 2 ? ( 7 + wod - dt + obj.day ) : ( 7 + wod - dt + obj.day + ( obj.week - 2 ) * 7 ) )\n\t\t\t\t// if( total > ( 365 + ( isLeap1 ? 1 : 0 ) ) ) {\n\t\t\t\t// \tvar newStart = new Date( obj.year + 1 , 0 ,1 ).getDay();\n\t\t\t\t// \tif( newStart > 4 ) {\n\t\t\t\t// \t\tobj.year += 1;\n\t\t\t\t// \t\ttotal = total - ( ( 365 + ( isLeap1 ? 1 : 0 ) ) );\n\t\t\t\t// \t}\n\t\t\t\t// }\n\t\t\t\t// if( total > ( 365 + ( isLeap1 ? 1 : 0 ) ) || obj.day == 0 || obj.day > 7 ) {\n\t\t\t\t// \tobj.month = obj.year = obj.date = 'Invalid';\n\t\t\t\t// \treturn;\n\t\t\t\t// }\n\t\t\t\t// var ret = getDay( total, isLeap1 );\n\t\t\t\t// obj.month = ret.mon; obj.date = ret.day;\n\n\t\t\t\tvar start = new Date( obj.year, 0, 1 );\n\t\t\t\tstart.setDate( wod + ( ( obj.week || 1 ) - 1 ) * 7 + ( obj.day || 0 ) );\n\n\t\t\t\tif( obj.year == start.getFullYear() ){\n\t\t\t\t\tobj.month = start.getMonth();\n\t\t\t\t\tobj.date = start.getDate();\n\t\t\t\t} else {\n\t\t\t\t\tobj.month = obj.date = \"Invalid\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( obj.year ) {\n\t\t\t\tvar yr = parseInt( obj.year );\n\t\t\t\tif( yr < 100 ) {\n\t\t\t\t\tobj.year = getCorrectYear( yr );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( obj.month < 0 ) {\n\t\t\t\tobj.month = 'Invalid';\n\t\t\t}\n\t\t\tif( obj.date < 1 ) {\n\t\t\t\tobj.date = 'Invalid';\n\t\t\t}\n\t\t}\n\n\t\tfunction getWeekReverse( dobj, ignore ){\n\t\t\tvar __wod = wod,\n\t\t\ttimezone = this._timezone;\n\n\t\t\tif( timezone ){\n\t\t\t\tdobj = new Date( $L.moment( dobj ).timezone( timezone ).format( 'YYYY-MM-DD' ) );\n\t\t\t}\n\n\t\t\tif( __wod ){\n\t\t\t\tdobj = new Date( dobj );\n\t\t\t\tdobj.setDate( dobj.getDate() - __wod );\n\t\t\t}\n\n\t\t\tvar ret = __getWeekReverse( dobj, ignore );\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tfunction __getWeekReverse( dobj, ignore ){\n\t\t\tvar year = dobj.getFullYear(),\n\t\t\tis_leap = isLeap( year ),\n\t\t\tmonth = dobj.getMonth(),\n\t\t\tdate = dobj.getDate(),\n\t\t\t__week_start = 0,\n\t\t\t__week_end = ( __week_start - 1 + 7 ) % 7,\n\t\t\tyear_start = new Date( year, 0, __week_start + 1 ),\n\t\t\tstartday = year_start.getDay(),\n\t\t\tstart_date = year_start.getDate(),\n\t\t\tcur_day = dobj.getDay(),\n\t\t\ttotal = totdate( month, is_leap ) + date,\n\t\t\tdays_without_ends = total - ( 7 - startday + __week_start ) - ( cur_day + 1 ),\n\t\t\t__weeks = ( days_without_ends / 7 ) + 1;\n\n\t\t\tif( month == 11 ){\n\t\t\t\tvar year_end = new Date( year, 11, 31 + __week_start ),\n\t\t\t\tendday = year_end.getDay(),\n\t\t\t\tenddate = year_end.getDate(),\n\t\t\t\texp_end = date + ( __week_end - endday + 7 ) % 7;\n\n\t\t\t\tif( exp_end > 31 + __week_start ){\n\t\t\t\t\treturn {\n\t\t\t\t\t\tweek : 1,\n\t\t\t\t\t\tday : cur_day\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} \n\n\t\t\t__weeks++;\n\n\t\t\treturn {\n\t\t\t\tweek : __weeks,\n\t\t\t\tday : cur_day\n\t\t\t};\n\t\t}\n\n\t\t// function getWeekReverse( dobj, ignore ) {\n\t\t// \tvar isLeap1 = isLeap( dobj.getFullYear() ), month = dobj.getMonth(), date = dobj.getDate(),\n\t\t// \ttotal = ignore ? 0 : - wod, startday = new Date( dobj.getFullYear(), 0 ).getDay();\n\t\t// \ttotal += totdate( month, isLeap1 );\n\n\t\t// \tif( !ignore ) {\n\t\t// \t\tif( month == 0 && startday > 4 && date < 3 ){\n\n\t\t// \t\t\t// isLeap1 = isLeap( dobj.getFullYear() - 1 );\n\t\t// \t\t\t// total = total + 365 + ( isLeap1 ? 1 : 0 );\n\t\t// \t\t\t// startday = new Date( dobj.getFullYear() - 1, 0 ).getDay();\n\t\t// \t\t\t// repYear = true;\n\n\t\t// \t\t\tvar ret = getWeekReverse( new Date( dobj.getFullYear() - 1, 11, 31 ) );\n\t\t// \t\t\tret.repYear = true;\n\t\t// \t\t\tret.day = ret.day + date;\n\n\t\t// \t\t\treturn ret;\n\t\t// \t\t} \n\t\t// \t}\n\n\t\t// \t\treturn { week : Math.ceil( ( total + startday + date ) / 7 ), day : dobj.getDay() + 1};\n\t\t// }\t\n\n\t\tfunction getCorrectYear( year ){\n\t\t\tvar copyYear = year + '';\n\t\t\tyear = parseInt( year );\n\n\t\t\tif( copyYear.length == 2 ){\n\t\t\t\tvar today = Number( $L.moment().format( 'YYYY' ) ),\n\t\t\t\tprefix = parseInt( today / 100 ),\n\t\t\t\tcurTwodigit = today % 100,\n\t\t\t\tupperLimit = ( curTwodigit + ( this.uL || uLimit ) ) % 100,\n\t\t\t\tlowerLimit = ( curTwodigit - ( this.lL || lLimit ) + 100 ) % 100;\n\n\t\t\t\tif( curTwodigit > lowerLimit ){\n\t\t\t\t\tif( year < lowerLimit ){\n\t\t\t\t\t\tyear = ( prefix + 1 ) + '' + crctLength( year, 2 );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tyear = prefix + '' + crctLength( year, 2 );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif( year < lowerLimit ){\n\t\t\t\t\t\tyear = prefix + '' + crctLength( year, 2 );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tyear = ( prefix - 1 ) + '' + crctLength( year, 2 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn year;\n\t\t}\n\n\t\tfunction valFormat( arg, format ){\n\t\t\tvar copyFormat = {}, \n\t\t\tret, \n\t\t\tdate,\n\t\t\t__new = new Date(),\n\t\t\tprseVal = parseFormat( replaceTxt( format ), true ), \n\t\t\tcopyArg = arg,\n\t\t\tformat = format.replace(/{{|}}/g, ''),\n\t\t\tcopyFormat1 = format,\n\t\t\tto_ret;\n\n\t\t\tfor( var i = 0; i < prseVal.length; i++ ) {\n\t\t\t\tvar ret, cur = prseVal[ i ].format;\n\t\t\t\tswitch( cur.type ) {\n\t\t\t\t\tcase 'date' :\n\t\t\t\t\tcase 'year':\n\t\t\t\t\tcase 'week' :\n\t\t\t\t\tcase 'day' : {\n\t\t\t\t\t\tif( cur.regex.test(arg) ) {\n\t\t\t\t\t\t\tif( cur.type == \"year\" ){\n\t\t\t\t\t\t\t\tret = arg.match( cur.regex )[ cur.match || 0 ];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tret = parseInt( arg.match( cur.regex )[ cur.match || 0 ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcopyFormat[ cur.type ] = ret;\n\t\t\t\t\t\t\targ = replace( arg, cur.regex, cur.suff );\n\t\t\t\t\t\t\tcopyArg = replace( copyArg, cur.regex, cur.suff, cur.val );\n\t\t\t\t\t\t\tif( cur.type == 'week' ) {\n\t\t\t\t\t\t\t\targ = replace( arg, week );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( cur.type == 'day' && cur.local ) {\n\t\t\t\t\t\t\t\tcopyFormat.day++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( cur.year ) {\n\t\t\t\t\t\t\t\tcopyFormat.date = getDay( copyFormat.date ).day;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif( copyFormat.year && copyFormat.week ) {\n\t\t\t\t\t\t\t\tcopyFormat[ cur.type ] = wod;\n\t\t\t\t\t\t\t\tformat = format.replace( cur.val, '' );\n\t\t\t\t\t\t\t\tcopyFormat1 = copyFormat1.replace( cur.val, '' );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcopyFormat[ cur.type ] = 'Invalid';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( /date/i.test( cur.type ) ){\n\t\t\t\t\t\t\tif( copyFormat[ cur.type ] == 0 ){\n\t\t\t\t\t\t\t\tcopyFormat[ cur.type ] = 'Invalid';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'month' : {\n\t\t\t\t\t\tif( cur.regex.test(arg) ) {\n\t\t\t\t\t\t\tret = getMonth( arg.match(  cur.regex )[ 0 ], cur.suff, cur.str, cur.long );\n\t\t\t\t\t\t\tcopyFormat.month = ret.val;\n\t\t\t\t\t\t\targ = replace( arg, ret.mon || ( cur.regex ), cur.suff );\n\t\t\t\t\t\t\tcopyArg = replace( copyArg, ret.mon || ( cur.regex ), cur.suff, cur.val );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcopyFormat.month = 'Invalid';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( copyFormat.month < 0 ){\n\t\t\t\t\t\t\tcopyFormat.month = 'Invalid';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'quarter' : {\n\t\t\t\t\t\tif( cur.regex.test(arg) ) {\n\t\t\t\t\t\t\tret = arg.match(  cur.regex )[ 0 ];\n\t\t\t\t\t\t\tcopyFormat.quarter = ret;\n\t\t\t\t\t\t\targ = replace( arg, ret, cur.suff );\n\t\t\t\t\t\t\tcopyArg = replace( copyArg, ret, cur.suff, cur.val );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'longdate' : {\n\t\t\t\t\t\tif( cur.regex.test(arg) ) {\n\t\t\t\t\t\t\tif( cur.str ) {\n\t\t\t\t\t\t\t\tret = find( cur.array, arg.match(  cur.regex )[ 0 ] );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tret = parseInt( arg.match( cur.regex )[ 0 ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcopyFormat.longdate = !isDef( ret.index ) ? ret : ret.index;\n\t\t\t\t\t\t\targ = replace( arg, ret.mon || ret, cur.suff )\n\t\t\t\t\t\t\tcopyArg = replace( copyArg, ret.mon || ret, cur.suff, cur.val );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'hour' : \n\t\t\t\t\tcase 'minute' : \n\t\t\t\t\tcase 'second' :\n\t\t\t\t\tcase 'meridian' : {\n\t\t\t\t\t\tif( cur.regex.test(arg) ) {\n\t\t\t\t\t\t\tif( cur.str ) {\n\t\t\t\t\t\t\t\tret = arg.match( cur.regex )[ 0 ];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tret = parseInt( arg.match( cur.regex )[ 0 ] );\n\t\t\t\t\t\t\t\tif( cur.railway ) {\n\t\t\t\t\t\t\t\t\tcopyFormat.railway = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( cur.deduct ) {\n\t\t\t\t\t\t\t\tret--;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar __min = cur.min;\n\n\t\t\t\t\t\t\tif( ( cur.max && ret > cur.max ) || ( __min != void 0 && ret < __min ) ) {\n\t\t\t\t\t\t\t\tret = 'Invalid';\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcopyFormat[ cur.type ] = ret;\n\n\t\t\t\t\t\t\targ = replace( arg, cur.regex );\n\t\t\t\t\t\t\tcopyArg = replace( copyArg, cur.regex, cur.suff, cur.val );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'millisecond' : {\n\t\t\t\t\t\tif( cur.regex.test(arg) ) {\n\t\t\t\t\t\t\tret = arg.match( cur.regex )[ 0 ];\n\t\t\t\t\t\t\tcopyFormat.millisecond = parseFloat( ret );\n\t\t\t\t\t\t\targ = replace( arg, ret ).replace(/[S]+/, '');\n\t\t\t\t\t\t\tcopyArg = replace( copyArg, cur.regex, cur.suff, cur.val );\n\t\t\t\t\t\t\tcopyFormat1 = copyFormat1.replace(/[S]+/, 'S');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'timestamp' : {\n\t\t\t\t\t\tif( cur.regex.test(arg) ) {\n\t\t\t\t\t\t\tret = parseInt( arg.match( cur.regex )[ 0 ] );\n\t\t\t\t\t\t\tcopyFormat.timestamp = ret * ( cur.milli ? 1 : 1000 );\n\t\t\t\t\t\t\targ = replace( arg, ret );\n\t\t\t\t\t\t\tcopyArg = replace( copyArg, ret, cur.suff, cur.val );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'timezone' : {\n\t\t\t\t\t\tif( cur.regex.test(arg) ) {\n\t\t\t\t\t\t\tif( cur.str ) {\n\t\t\t\t\t\t\t\tret = arg.match( cur.regex )[ 0 ];\n\t\t\t\t\t\t\t\tret = -timeZoneOffsets[ ret ];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tret = convertTimeZone( arg.match( cur.regex ) )\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcopyFormat.timezone = ret;\n\t\t\t\t\t\t\targ = replace( arg, cur.regex );\n\t\t\t\t\t\t\tcopyArg = replace( copyArg, cur.regex, cur.suff, cur.val );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tformat = format.replace( cur.valForm || cur.val, '' );\n\t\t\t}\n\t\t\t\t\n\t\t\t// date = new Date( __new.getFullYear(), isDef( copyFormat.month ) ? copyFormat.month : __new.getMonth(), copyFormat.date || 1 );\n\t\t\t// date = new Date( __new.getFullYear(), 0 );\n\n\t\t\tdate = new Date( __new.getFullYear(), isDef( copyFormat.month ) ? copyFormat.month : __new.getMonth(), copyFormat.date || 1, copyFormat.hour || ( copyFormat.meridian == \"PM\" ? 12 : 0 ), copyFormat.minute || 0, copyFormat.second || 0 );\n\n\t\t\tif( isDef( copyFormat.day ) || isDef( copyFormat.week ) ){\n\t\t\t\tvar oriDate = copyFormat.date\n\t\t\t\tif( !isDef( copyFormat.year ) ) {\n\t\t\t\t\tcopyFormat.year = date.getFullYear();\n\t\t\t\t}\n\t\t\t\tif( !isDef( copyFormat.day ) ) {\n\t\t\t\t\tcopyFormat.day = wod;\n\t\t\t\t} \n\t\t\t\tgetWeek.call( this, copyFormat );\n\t\t\t\tif( isDef( oriDate ) ){\n\t\t\t\t\tif( copyFormat.date > oriDate ) {\n\t\t\t\t\t\tcopyFormat.month++;\n\t\t\t\t\t} \n\t\t\t\t\tcopyFormat.date = oriDate;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( isDef( copyFormat.longdate ) && copyFormat.day && copyFormat.day != copyFormat.longdate ) {\n\t\t\t\tdate.setFullYear( 'Invalid' );\n\t\t\t} else if( isDef( copyFormat.year ) ) {\n\t\t\t\tdate.setFullYear( getCorrectYear( copyFormat.year ) );\n\t\t\t}\n\t\t\tif( isDef( copyFormat.month ) ) {\n\t\t\t\tdate.setMonth( copyFormat.month );\n\t\t\t}\n\t\t\tif( isDef( copyFormat.date ) ) {\n\t\t\t\tdate.setDate( copyFormat.date <= ( dayArr[ date.getMonth() ] + ( date.getMonth() == 1 && isLeap( date.getFullYear() ) ? 1 : 0 ) ) ? copyFormat.date : 'Invalid');\n\t\t\t}\n\t\t\tif( isDef( copyFormat.hour ) ) {\n\t\t\t\tvar mer = copyFormat.meridian;\n\t\t\t\tdate.setHours( copyFormat.railway ? convertRailway( copyFormat.hour, mer ? ( /pm/i.test( mer ) ) : ( copyFormat.hour > 11 ) ) : ( /pm/i.test( mer ) ? ( copyFormat.hour < 12 ? ( copyFormat.hour + 12 ) : copyFormat.hour ) : copyFormat.hour % 12 ) )\n\t\t\t}\n\t\t\tif( isDef( copyFormat.minute ) ) {\n\t\t\t\tdate.setMinutes( copyFormat.minute )\n\t\t\t}\n\t\t\tif( isDef( copyFormat.second ) ) {\n\t\t\t\tdate.setSeconds( copyFormat.second )\n\t\t\t}\n\t\t\tif( isDef( copyFormat.millisecond ) ){\n\t\t\t\tdate.setMilliseconds( copyFormat.millisecond )\n\t\t\t}\n\t\t\tif( isDef( copyFormat.timestamp ) ) {\n\t\t\t\tdate = new Date( copyFormat.timestamp )\n\t\t\t}\n\n\t\t\tif( validate.call( this, date ) ){\n\t\t\t\tif( isDef( copyFormat.timezone ) ){\n\t\t\t\t\t// to_ret = true;\n\t\t\t\t\tvar act_diff = date.getTimezoneOffset();\n\n\t\t\t\t\tcopyFormat.timezone -= act_diff;\n\t\t\t\t\tdate.setMinutes( date.getMinutes() + copyFormat.timezone );\n\n\t\t\t\t\tvar new_diff = date.getTimezoneOffset();\n\n\t\t\t\t\tif( act_diff != new_diff ){\n\n\t\t\t\t\t\t/* Daylight saving time causing many issues.\n\t\t\t\t\t\t\t\tHere when we are passing wrong timezone date Ex. '2021-11-07T02:30:00-04:00' new date reads it correctly ( In -04:00 timezone machine ). But setting the timezone difference in setMinutes causing problem.\n\t\t\t\t\t\t\tDont know the exact fix. So wrote this as temporary fix. Assuming string contains timezone is readable in new Date()*/\n\n\t\t\t\t\t\tvar new_date = new Date( this._arg );\n\t\t\t\t\t\t// May be we can create a date object by passing already available data\n\n\t\t\t\t\t\tif( new_date.toString() == 'Invalid Date' ){\n\t\t\t\t\t\t\t/* In this case can't do anything from moment side. Need to change the input date string */ \n\t\t\t\t\t\t\tdate.setMinutes( date.getMinutes() - copyFormat.timezone );\n\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\tdate = new_date;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t} else if( isDef( this._timezone ) ){\n\t\t\t\t\tvar ori_timezone = this.timezoneOffset( date );\n\n\t\t\t\t\tcopyFormat.timezone =  ori_timezone - date.getTimezoneOffset();\n\t\t\t\t\tdate.setMinutes( date.getMinutes() + copyFormat.timezone );\n\n\t\t\t\t\t/*\n\t\t\t\t\t\t* This below code is written for reading a time in different timezone without timezone present in date string.\n\t\t\t\t\t\t* My machine is in Asia/Calcutta timezone 'Mar 11, 2022'. Niru <nirmala.b@zohocorp.com> reported this for input type date.\n\t\t\t\t\t\t* Here DST changes on 'Mar 13, 2022 02:00 AM' in \"US/Pacific\" \n\t\t\t\t\t\t* ex . 'Mar 13, 2022 03:00 AM'\n\t\t\t\t\t\t* In this case if i use normal functions setting hour 3 will automatically changes to hour 4 of -07:00 timezone\n\t\t\t\t\t\t* To fix this issue after changing date again finding offset and subtracting the same for getting 3 of -07:00 timezone\n\t\t\t\t\t\t*/\n\n\t\t\t\t\tvar new_timezone = this.timezoneOffset( date ),\n\t\t\t\t\tdiff = ori_timezone - new_timezone;\n\n\t\t\t\t\tif( diff ){\n\t\t\t\t\t\tdate.setMinutes( date.getMinutes() - diff );\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t\t* Here same as above\n\t\t\t\t\t\t* 'Mar 13, 2022 02:59 AM' is an invalid date for \"US/Pacific\" timezone.\n\t\t\t\t\t\t* correct output is generally assumed as 03:59 of -07:00 timezone\n\t\t\t\t\t\t* if i deduct timezone change it goes to 01:59 of -08:00 timezone\n\t\t\t\t\t\t* if converted hour and inputed hour are not matching we having an invalid hour value\n\t\t\t\t\t\t* so here i am adding it again for getting 03:59 of -07:00 timezone value\n\t\t\t\t\t\t*/\n\n\t\t\t\t\tvar __hour = copyFormat.hour;\n\n\t\t\t\t\tif( isDef( __hour ) && __hour != parseInt( $L.moment( date ).format( 'h' ) ) ){\n\t\t\t\t\t\tdate.setMinutes( date.getMinutes() + diff );\n\t\t\t\t\t}\n\t\t\t\t\t/* ends */\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar def_format = \"YYYY-MM-DDTHH:mm:ssZ\"; \n\n\t\t\tif( copyFormat1 != def_format && arg.length == format.length && copyFormat1 == copyArg && validate.call( this, date ) ) {\n\t\t\t\treturn this._isCorrectFormat = true;\n\t\t\t} else if( !this._format || copyFormat1 == def_format ) {\n\t\t\t\treturn validate.call( this, new Date( this._arg ) );\n\t\t\t}\n\n\t\t\treturn to_ret;\n\t\t}\n\n\t\tfunction crctLength( val, length, suff, deduct ) {\n\t\t\tvar sfx = ''\n\t\t\tif( deduct ) {\n\t\t\t\tval++;\n\t\t\t}\n\t\t\tif( suff ) {\n\t\t\t\tsfx = nthconv( val );\n\t\t\t}\n\t\t\tif( length ) {\n\t\t\t\tval = val.toString();\n\t\t\t\tfor( var i = 1; i < length; i++ ) {\n\t\t\t\t\tif( val.length <= i ) {\n\t\t\t\t\t\tval = '0' + val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn val + sfx;\n\t\t}\n\n\t\tfunction getDObj(){\n\t\t\tvar date = this._dateObj,\n\t\t\ttimeZone = this._timezone;\n\n\t\t\tif( timeZone ) {\n\t\t\t\tif( this.is_IE ){\n\t\t\t\t\tdate.setMinutes( date.getMinutes() + date.getTimezoneOffset() - this.timezoneOffset( date ) );\n\t\t\t\t} else{\n\t\t\t\t\tvar new_date = new Date( convert_timezone_DLS.call( this, date, timeZone ) );\n\n\t\t\t\t\tif( validate.call( this, new_date, true ) ){\n\t\t\t\t\t\treturn new_date;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn date;\n\t\t}\n\n\t\tfunction setTimezoneName(date_obj, _this) {\n\t\t\tvar mod_obj;\n\n\t\t\ttry {  \n\t\t\t\tif( _this._timezone ){ \n\t\t\t\t\tmod_obj = date_obj.toLocaleString('en-US', { timeZone: _this._timezone, timeZoneName: \"long\" }).split(/AM|PM/)[1];\n\t\t\t\t} else {\n\t\t\t\t\tmod_obj = new Date().toTimeString().match(/\\(([^)]+)\\)/)[1];\t\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\tmod_obj = new Date().toTimeString().match(/\\(([^)]+)\\)/)[1];\n\t\t\t}\n\t\t\tif( date_obj ){\n\t\t\t\treturn mod_obj.trim().match(/\\b\\w/g).join('');\n\t\t\t} \n\t\t\treturn mod_obj;\n\t\t}\n\n\t\tfunction convertFormat( arg ) {\n\t\t\tvar parseVal = parseFormat( replaceTxt( arg ) ), isWeek = {},\n\t\t\tact_date = this.toDate(),\n\t\t\tobj = this.split_date( act_date ),\n\t\t\tfake_time,\n\t\t\tcreate_fake = function(){\n\t\t\t\treturn new Date( act_date.getTime() + ( act_date.getTimezoneOffset() - obj.timezone ) * 1e3 * 60 );\n\t\t\t}.bind( this );\n\n\t\t\targ = fmReplace( arg.replace(/{{|}}/g, ''), parseVal );\n\t\t\tfor( var i = 0; i < parseVal.length; i++ ) {\n\t\t\t\tvar ret, cur = parseVal[ i ].format;\n\t\t\t\tswitch( cur.type ) {\n\t\t\t\t\tcase \"date\" : {\n\t\t\t\t\t\targ = arg.replace( cur.val + lm, crctLength( ( cur.year ? totdate( obj.month - 1, isLeap( obj.year ), obj.date ) : obj.date ), cur.len, cur.suff ) )\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"month\" : {\n\t\t\t\t\t\tif( cur.str ) {\n\t\t\t\t\t\t\targ = arg.replace( cur.val + lm, cur.array[ obj.month - 1 ] );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\targ = arg.replace( cur.val + lm, crctLength( obj.month, cur.len, cur.suff ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"year\" : {\n\t\t\t\t\t\targ = arg.replace( cur.val + lm, cur.len == 2 ? crctLength( obj.year % 100, 2 ) : ( ( obj.year + '' ).length == 4 ) ? obj.year : crctLength( obj.year, 4 ) );\n\t\t\t\t\t\tisWeek.year = isWeek.year || [];\n\t\t\t\t\t\tisWeek.year.push( cur );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"day\" :\n\t\t\t\t\tcase \"week\" : {\n\t\t\t\t\t\tisWeek.flag = true\n\t\t\t\t\t\tisWeek[ cur.type ] = isWeek[ cur.type ] || [];\n\t\t\t\t\t\tisWeek[ cur.type ].push( cur );\n\t\t\t\t\t}\t\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"quarter\" : {\n\t\t\t\t\t\targ = arg.replace( cur.val + lm, crctLength( Math.ceil( ( obj.month ) / 3 ), null , cur.suff ) )\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'longdate' : {\n\t\t\t\t\t\tfake_time =  fake_time || create_fake();\n\t\t\t\t\t\tvar __day = fake_time.getDay();\n\t\t\t\t\t\tif( cur.str ) {\n\t\t\t\t\t\t\targ = arg.replace( cur.val + lm, cur.array[ __day ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\targ = arg.replace( cur.val + lm, crctLength( __day, null , cur.suff ) )\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'hour' : {\n\t\t\t\t\t\tvar hr = obj.hour;\n\t\t\t\t\t\targ = arg.replace( cur.val + lm, crctLength( !cur.railway ? ( hr > 12 ? hr % 12 : ( hr || 12 ) ) : hr, cur.len, null, cur.deduct ) )\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'minute' : {\n\t\t\t\t\t\targ = arg.replace( cur.val + lm, crctLength( obj.minute, cur.len ) );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'second' : {\n\t\t\t\t\t\targ = arg.replace( cur.val + lm, crctLength( obj.second, cur.len ) );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'millisecond' : {\n\t\t\t\t\t\targ = arg.replace( cur.val + lm, crctLength( act_date.getMilliseconds(), 3 ) ).replace( /\\\\S+/, '' )\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'timezone' : {\n\t\t\t\t\t\tvar val = '';\n\t\t\t\t\t\tif( !cur.str ) {\n\t\t\t\t\t\t\tvar off = obj.timezone, hr = crctLength( Math.abs( parseInt( off / 60 ) ), 2 ), min = crctLength( Math.abs( off % 60 ), 2 ), sign = off <= 0 ? '+' : '-';\n\t\t\t\t\t\t\tif( cur.val == 'ZZ' ) {\n\t\t\t\t\t\t\t\tval = sign + hr + min;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tval = sign + hr + ':' + min;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if( cur.val == \"z\" ){\n\t\t\t\t\t\t\tval = obj.timezoneName || setTimezoneName(act_date, this) || \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\targ = arg.replace( cur.val + lm, val );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'timestamp' : {\n\t\t\t\t\t\tvar val = '';\n\t\t\t\t\t\tif( cur.val == 'X' ) {\n\t\t\t\t\t\t\t\tval += parseInt( act_date.getTime() / 1000 )\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tval += act_date.getTime();\n\t\t\t\t\t\t}\n\t\t\t\t\t\targ = arg.replace( cur.val + lm, val );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'meridian' : {\n\t\t\t\t\t\tvar forr = obj.meridian;\n\t\t\t\t\t\tif( cur.lower ) {\n\t\t\t\t\t\t\tforr = forr.toLowerCase();\n\t\t\t\t\t\t}\n\t\t\t\t\t\targ = arg.replace( cur.val + lm, forr );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( isWeek.flag ) {\n\t\t\t\tfake_time = fake_time || create_fake();\n\t\t\t\tvar ret = getWeekReverse( fake_time );\n\t\t\t\tif( isWeek.week ){\n\t\t\t\t\tfor( var j = 0; j < isWeek.week.length; j++ ){\n\t\t\t\t\t\tvar __cur = isWeek.week[ j ],\n\t\t\t\t\t\t__ret = getWeekReverse( fake_time, __cur.ignore );\n\t\t\t\t\t\targ = arg.replace( __cur.val + lm, ( __cur.pref == 0 ? \"\" : week ) + crctLength( __ret.week, __cur.len, __cur.suff ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( isWeek.day ) {\n\t\t\t\t\tfor( var j = 0; j < isWeek.day.length; j++ ){\n\t\t\t\t\t\targ = arg.replace( isWeek.day[ j ].val + lm, ret.day - ( isWeek.day[ j ].local ? 1 : 0 ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( ret.repYear && isWeek.year ) {\n\t\t\t\t\tfor( var j = 0; j < isWeek.year.length; j++ ){\n\t\t\t\t\t\targ = arg.replace( ( isWeek.year[ j ].len == 2 ? obj.year % 100 : obj.year ), ( isWeek.year[ j ].len == 2 ? obj.year % 100 : obj.year ) - 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn arg.replace(/{{|}}/g, '');\n\t\t}\n\n\t\tfunction validate( arg, format ) {\n\t\t\tvar cons = arg.constructor;\n\t\t\t\n\t\t\tif( cons == Date || cons == ( new Date().constructor ) ) {\n\t\t\t\tif( format != true ){\n\t\t\t\t\tthis._dateObj = arg;\n\t\t\t\t\tthis._isMoment = true;\n\t\t\t\t}\n\t\t\t\tif( arg.toString() == 'Invalid Date' ) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else if( typeof arg == \"string\" ) {\n\t\t\t\tif( format ) {\n\t\t\t\t\tvar ret = valFormat.call( this, arg, format );\n\t\t\t\t\tif( ret && this._isCorrectFormat ) {\n\t\t\t\t\t\tthis._format = format;\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t} else {\n\t\t\t\t\tif( this.constructFormat ){\n\t\t\t\t\t\treturn validate.call( this, arg, this.constructFormat.call( this, arg ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn( 'Its not supported in lyte-moment-basic.js. Add lyte-moment-additional.js for format construction' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if( Array.isArray( arg ) ) {\n\t\t\t\t// new (Function.prototype.bind.apply(Date, [null].concat([1996,04,28])))\n\t\t\t\treturn validate.call( this, new Date( Date.parse( Date.apply( Date, cons ) ) ).getTime() );\n\t\t\t} else if( typeof arg == \"number\" ) {\n\t\t\t\targ *= /^\\d{10}$/.test( arg ) ? 1000 : 1;\n\t\t\t\treturn validate.call( this, new Date( arg ) );\n\t\t\t} else if( arg._isMoment ) {\n\n\t\t\t\tthis.name_space = arg.name_space;\n\t\t\t\tthis.dls_check_map = arg.dls_check_map;\n\t\t\t\tthis._timezone = arg._timezone; \n\n\t\t\t\treturn validate.call( this, arg._dateObj.getTime() );\n\t\t\t}\n\t\t}\n\n\t\tfunction create_dls( date_obj, name ){\n\t\t\tvar date = date_obj.getDate(),\n\t\t\tmonth = date_obj.getMonth() + 1,\n\t\t\tyear = date_obj.getFullYear(),\n\t\t\thour = date_obj.getHours(),\n\t\t\tminute = date_obj.getMinutes(),\n\t\t\tsecond = date_obj.getSeconds(),\n\t\t\tstr = crctLength( month, 2 ) + \"/\" + crctLength( date, 2 ) + \"/\" + year + \", \" + crctLength( hour > 12 ? ( hour % 12 ) : ( hour || 12 ), 2 ) + \":\" + crctLength( minute, 2 ) + \":\" + crctLength( second, 2 ) + \" \" + ( hour > 11 ? 'PM' : \"AM\" ) + \" \",\n\t\t\toffset = -date_obj.getTimezoneOffset();\n\n\t\t\tif( name == \"long\" ){\n\t\t\t\tstr += setTimezoneName();\n\t\t\t} else {\n\t\t\t\tstr += ( \"GMT\" + ( offset >= 0 ? '+' : \"\" ) +  crctLength( parseInt( offset / 60 ), 2 ) + \":\" + crctLength( offset % 60, 2 ) );\n\t\t\t}\n\n\t\t\treturn str;\n\t\t}\n\n\t\tfunction convert_timezone_DLS( date_obj, name, short ){\n\n\t\t\tshort = short || \"short\";\n\n\t\t\tvar ns = date_obj.getTime() + '_' + name + \"_\" + short;\n\n\t\t\tif( ns == this.name_space ){\n\t\t\t\treturn this.dls_check_map;\n\t\t\t}\n\n\t\t\tthis.name_space = ns;\n\n\t\t\treturn ( this.dls_check_map = ( name ? date_obj.toLocaleString( \"en-US\", { timeZone: name, timeZoneName: short } ) : create_dls( date_obj, short ) ) );\n\t\t}\n\n\t\tlyteMoment.prototype = {\n\n\t\t\tisDef : isDef, \n\n\t\t\tfind : find,\n\n\t\t\ttotdate : totdate,\n\n\t\t\tisLeap : isLeap,\n\n\t\t\tdayArr : dayArr,\n\n\t\t\tgetDObj : getDObj,\n\n\t\t\tgetWeekReverse : getWeekReverse,\n\n\t\t\tweekShort : weekShort,\n\n\t\t\tweekMid : weekMid,\n\n\t\t\tweekLong : weekLong,\n\n\t\t\tlongMon : longMon,\n\n\t\t\tshortMon : shortMon,\n\n\t\t\tweek : week,\n\n\t\t\tcrctLength : crctLength,\n\n\t\t\tformats : formats,\n\n\t\t\treplace : replace,\n\n\t\t\tinbuiltFormats : {},\n\n\t\t\tgetCorrectYear : getCorrectYear,\n\n\t\t\tparseFormat : parseFormat,\n\n\t\t\treplaceTxt : replaceTxt,\n\n\t\t\tis_IE : is_IE,\n\n\t\t\tconvertTimeZone : convertTimeZone,\n\n\t\t\tvalidate : function(){\n\t\t\t\treturn !!this._isValid;\n\t\t\t},\n\n\t\t\ttoDate : function(){\n\t\t\t\treturn this._dateObj;\n\t\t\t},\n\n\t\t\tisSame : function( arg ){\n\t\t\t\tif( this.validate() && arg && arg._isMoment && arg._isValid ) {\n\t\t\t\t\treturn this._dateObj.getTime() == arg._dateObj.getTime();\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t},\n\n\t\t\tformat : function( arg ) {\n\t\t\t\tif( this.validate() ) {\n\t\t\t\t\targ = this.inbuiltFormats[ arg ] || arg || \"YYYY-MM-DDTHH:mm:ssZ\";\n\t\t\t\t\treturn convertFormat.call( this, arg );\t\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tutc : function( arg ) {\n\t\t\t\treturn this.timezone( 'UTC' );\n\t\t\t},\n\n\t\t\tlocal : function( arg ){\n\t\t\t\treturn this.timezone( void 0 );\n\t\t\t},\n\n\t\t\ttimezone : function( arg, off ){\n\t\t\t\tthis._timezone = arg;\n\n\t\t\t\tif( isDef( off ) ){\n\t\t\t\t\tif( typeof off == 'string' ){\n\t\t\t\t\t\ttimeZoneOffsets[ arg ] = -convertTimeZone( off.match( /(\\+|\\-)(\\d{2}):(\\d{2})$/ ) ); \n\t\t\t\t\t} else{\n\t\t\t\t\t\ttimeZoneOffsets[ arg ] = off;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.is_IE = true;\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t},\t\n\n\t\t\tgetCurrentTimeZone : function(){\n\t\t\t\treturn this._timezone;\n\t\t\t},\n\n\t\t\tparseDate : function( str, date_obj, timezone ){\n\t\t\t\tvar date_rgx = /(\\d+)\\/(\\d+)\\/(\\d+),\\s(\\d+):(\\d+):(\\d+)\\s(AM|PM)/,\n\t\t\t\tmatch = str.match( date_rgx ),\n\t\t\t\tobj = {\n\t\t\t\t\ttimezoneName : \"\"\n\t\t\t\t},\n\t\t\t\tgmt_rgx = /GMT(\\+|-)(\\d+):(\\d+):(\\d+)$/,\n\t\t\t\thr_min_rgx = /GMT(\\+|-)(\\d+):(\\d+)$/,\n\t\t\t\thr_only_gmt = /GMT(\\+|-)(\\d+)$/,\n\t\t\t\tend_rgx = /\\s([A-Z]+)$/;\n\n\t\t\t\t[ 'month', 'date', 'year', 'hour', 'minute', 'second' ].forEach( function( item, index ){\n\t\t\t\t\tobj[ item ] = parseInt( match[ index + 1 ] );\n\t\t\t\t});\n\n\t\t\t\tobj.meridian = match[ 7 ];\n\n\t\t\t\tvar hr = obj.hour,\n\t\t\t\tns = {\"ACDT\":\"GMT+10:30\",\"ACST\":\"GMT+9:30\",\"ACT\":\"GMT-5\",\"ACWST\":\"GMT+8:45\",\"ADT\":\"GMT-3\",\"AEDT\":\"GMT+11\",\"AEST\":\"GMT+10\",\"AFT\":\"GMT+4:30\",\"AKDT\":\"GMT-8\",\"AKST\":\"GMT-9\",\"AMST\":\"GMT-3\",\"AMT\":\"GMT+4\",\"ART\":\"GMT-3\",\"AST\":\"GMT+3\",\"AT\":\"GMT-4/GMT-3\",\"AWST\":\"GMT+8\",\"AZOST\":\"GMT+0\",\"AZOT\":\"GMT-1\",\"AZT\":\"GMT+4\",\"BDT\":\"GMT+8\",\"BIT\":\"GMT-12\",\"BNT\":\"GMT+8\",\"BOT\":\"GMT-4\",\"BRST\":\"GMT-2\",\"BRT\":\"GMT-3\",\"BST\":\"GMT+11\",\"BTT\":\"GMT+6\",\"CAT\":\"GMT+2\",\"CCT\":\"GMT+6:30\",\"CDT\":\"GMT-4\",\"CEST\":\"GMT+2\",\"CET\":\"GMT+1\",\"CHADT\":\"GMT+13:45\",\"CHAST\":\"GMT+12:45\",\"CHOST\":\"GMT+9\",\"CHOT\":\"GMT+8\",\"CHST\":\"GMT+10\",\"CHUT\":\"GMT+10\",\"CIST\":\"GMT-8\",\"CIT\":\"GMT+8\",\"CKT\":\"GMT-10\",\"CLST\":\"GMT-3\",\"CLT\":\"GMT-4\",\"COST\":\"GMT-4\",\"COT\":\"GMT-5\",\"CST\":\"GMT+8\",\"CT\":\"GMT-6/GMT-5\",\"CVT\":\"GMT-1\",\"CWST\":\"GMT+8:45\",\"CXT\":\"GMT+7\",\"DAVT\":\"GMT+7\",\"DDUT\":\"GMT+10\",\"EASST\":\"GMT-5\",\"EAST\":\"GMT-6\",\"EAT\":\"GMT+3\",\"ECT\":\"GMT-5\",\"EDT\":\"GMT-4\",\"EEST\":\"GMT+3\",\"EET\":\"GMT+2\",\"EGST\":\"GMT+0\",\"EGT\":\"GMT-1\",\"EIT\":\"GMT+9\",\"EST\":\"GMT-5\",\"ET\":\"GMT-5/GMT-4\",\"FET\":\"GMT+3\",\"FJT\":\"GMT+12\",\"FKST\":\"GMT-3\",\"FKT\":\"GMT-4\",\"FNT\":\"GMT-2\",\"GALT\":\"GMT-6\",\"GAMT\":\"GMT-9\",\"GET\":\"GMT+4\",\"GFT\":\"GMT-3\",\"GILT\":\"GMT+12\",\"GIT\":\"GMT-9\",\"GMT\":\"GMT+0\",\"GST\":\"GMT-2\",\"GYT\":\"GMT-4\",\"HADT\":\"GMT-9\",\"HAST\":\"GMT-10\",\"HKT\":\"GMT+8\",\"HMT\":\"GMT+5\",\"HOVST\":\"GMT+8\",\"HOVT\":\"GMT+7\",\"ICT\":\"GMT+7\",\"IDT\":\"GMT+3\",\"IOT\":\"GMT+6\",\"IRDT\":\"GMT+4:30\",\"IRKT\":\"GMT+8\",\"IRST\":\"GMT+3:30\",\"IST\":\"GMT+2\",\"JST\":\"GMT+9\",\"KGT\":\"GMT+6\",\"KOST\":\"GMT+11\",\"KRAT\":\"GMT+7\",\"KST\":\"GMT+9\",\"LHDT\":\"GMT+11\",\"LHST\":\"GMT+10:30\",\"LINT\":\"GMT+14\",\"MAGT\":\"GMT+11\",\"MART\":\"GMT-9:30\",\"MAWT\":\"GMT+5\",\"MDT\":\"GMT-6\",\"MHT\":\"GMT+12\",\"MIST\":\"GMT+11\",\"MIT\":\"GMT-9:30\",\"MMT\":\"GMT+6:30\",\"MSK\":\"GMT+3\",\"MST\":\"GMT+8\",\"MT\":\"GMT-7/GMT-6\",\"MUT\":\"GMT+4\",\"MVT\":\"GMT+5\",\"MYT\":\"GMT+8\",\"NCT\":\"GMT+11\",\"NDT\":\"GMT-2:30\",\"NFT\":\"GMT+11\",\"NPT\":\"GMT+5:45\",\"NRT\":\"GMT+12\",\"NST\":\"GMT-3:30\",\"NT\":\"GMT-3:30\",\"NUT\":\"GMT-11\",\"NZDT\":\"GMT+13\",\"NZST\":\"GMT+12\",\"OMST\":\"GMT+6\",\"ORAT\":\"GMT+5\",\"PDT\":\"GMT-7\",\"PET\":\"GMT-5\",\"PETT\":\"GMT+12\",\"PGT\":\"GMT+10\",\"PHOT\":\"GMT+13\",\"PhST\":\"GMT+8\",\"PHT\":\"GMT+8\",\"PKT\":\"GMT+5\",\"PMDT\":\"GMT-2\",\"PMST\":\"GMT-3\",\"PONT\":\"GMT+11\",\"PST\":\"GMT-8\",\"PT\":\"GMT-8/GMT-7\",\"PWT\":\"GMT+9\",\"PYST\":\"GMT-3\",\"PYT\":\"GMT-4\",\"RET\":\"GMT+4\",\"ROTT\":\"GMT-3\",\"SAKT\":\"GMT+11\",\"SAMT\":\"GMT+4\",\"SAST\":\"GMT+2\",\"SBT\":\"GMT+11\",\"SCT\":\"GMT+4\",\"SGT\":\"GMT+8\",\"SLST\":\"GMT+5:30\",\"SRET\":\"GMT+11\",\"SRT\":\"GMT-3\",\"SST\":\"GMT-11\",\"SYOT\":\"GMT+3\",\"TAHT\":\"GMT-10\",\"TFT\":\"GMT+5\",\"THA\":\"GMT+7\",\"TJT\":\"GMT+5\",\"TKT\":\"GMT+13\",\"TLT\":\"GMT+9\",\"TMT\":\"GMT+5\",\"TOT\":\"GMT+13\",\"TRT\":\"GMT+3\",\"TVT\":\"GMT+12\",\"ULAST\":\"GMT+9\",\"ULAT\":\"GMT+8\",\"USZ1\":\"GMT+2\",\"UTC\":\"GMT+0\",\"UYST\":\"GMT-2\",\"UYT\":\"GMT-3\",\"UZT\":\"GMT+5\",\"VET\":\"GMT-4\",\"VLAT\":\"GMT+10\",\"VOLT\":\"GMT+4\",\"VOST\":\"GMT+6\",\"VUT\":\"GMT+11\",\"WAKT\":\"GMT+12\",\"WAST\":\"GMT+2\",\"WAT\":\"GMT+1\",\"WEST\":\"GMT+1\",\"WET\":\"GMT+0\",\"WFT\":\"GMT+12\",\"WGST\":\"GMT-2\",\"WIB\":\"GMT+7\",\"WIT\":\"GMT+9\",\"WST\":\"GMT+8\",\"YAKT\":\"GMT+9\",\"YEKT\":\"GMT+5\"},\n\t\t\t\t_this = this;\n\n\t\t\t\tif( match[ 7 ] == 'PM' ){\n\t\t\t\t\tif( hr != 12 ){\n\t\t\t\t\t\tobj.hour += 12;\n\t\t\t\t\t}\n\t\t\t\t} else{\n\t\t\t\t\tif( hr == 12 ){\n\t\t\t\t\t\tobj.hour = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction fn( str, frm_recursive, frm_long ){\n\t\t\t\t\tif( gmt_rgx.test( str ) ){\n\t\t\t\t\t\tvar gmt_match = str.match( gmt_rgx );\n\t\t\t\t\t\tobj.timezone = ( parseInt( gmt_match[ 2 ] ) * 60 + parseInt( gmt_match[ 3 ] ) ) * ( gmt_match[ 1 ] == '-' ? 1 : -1 );\n\t\t\t\t\t} else if( hr_min_rgx.test( str ) ){\n\t\t\t\t\t\tvar gmt_match = str.match( hr_min_rgx );\n\t\t\t\t\t\tobj.timezone = ( parseInt( gmt_match[ 2 ] ) * 60 + parseInt( gmt_match[ 3 ] ) ) * ( gmt_match[ 1 ] == '-' ? 1 : -1 );\n\t\t\t\t\t} else if( hr_only_gmt.test( str ) ){\n\t\t\t\t\t\tvar gmt_match = str.match( hr_only_gmt );\n\t\t\t\t\t\tobj.timezone = ( parseInt( gmt_match[ 2 ] ) * 60 ) * ( gmt_match[ 1 ] == '-' ? 1 : -1 );\n\t\t\t\t\t} else{\n\t\t\t\t\t\tif( frm_recursive ){\n\t\t\t\t\t\t\tif( frm_long ){\n\t\t\t\t\t\t\t\tvar __cur = timeZoneOffsets[ frm_long ];\n\t\t\t\t\t\t\t\tif( __cur ){\n\t\t\t\t\t\t\t\t\tvar final_str = \"GMT\",\n\t\t\t\t\t\t\t\t\thr = parseInt( __cur / 60 ),\n\t\t\t\t\t\t\t\t\tmin = Math.abs( __cur % 60 );\n\n\t\t\t\t\t\t\t\t\tif( __cur > 0 ){\n\t\t\t\t\t\t\t\t\t\tfinal_str += \"+\";\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfinal_str += ( hr + \":\" + min );\n\n\t\t\t\t\t\t\t\t\treturn fn( final_str, true );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tobj.timezone = 0;\n\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\tif( end_rgx.test( str ) ){\n\n\t\t\t\t\t\t\t\tvar clone = {\n\t\t\t\t\t\t\t\t\t\"AMT\" : {\n\t\t\t\t\t\t\t\t\t\t\"Amazon Time\" : \"GMT-4\",\n\t\t\t\t\t\t\t\t\t\t\"Armenia Time\" : \"GMT+4\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\"AST\" : {\n\t\t\t\t\t\t\t\t\t\t\"Atlantic Standard Time\" : \"GMT-4\",\n\t\t\t\t\t\t\t\t\t\t\"Arabia Standard Time\" : \"GMT+3\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\"BST\" : {\n\t\t\t\t\t\t\t\t\t\t\"British Summer Time\" : \"GMT+1\",\n\t\t\t\t\t\t\t\t\t\t\"Bangladesh Standard Time\" : \"GMT+6\",\n\t\t\t\t\t\t\t\t\t\t\"Bougainville Standard Time\" : \"GMT+11\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\"CDT\" : {\n\t\t\t\t\t\t\t\t\t\t\"Central Daylight Time\" : \"GMT-5\",\n\t\t\t\t\t\t\t\t\t\t\"Cuba Daylight Time\" : \"GMT-4\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\"CST\" : {\n\t\t\t\t\t\t\t\t\t\t\"Central Standard Time\" : \"GMT-6\",\n\t\t\t\t\t\t\t\t\t\t\"Cuba Standard Time\" : \"GMT-5\",\n\t\t\t\t\t\t\t\t\t\t\"China Standard Time\" : \"GMT+8\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\"GST\" : {\n\t\t\t\t\t\t\t\t\t\t\"Gulf Standard Time\" : \"GMT+4\",\n\t\t\t\t\t\t\t\t\t\t\"South Georgia Time\" : \"GMT-2\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\"IST\" : {\n\t\t\t\t\t\t\t\t\t\t\"Indian Standard Time\" : \"GMT+5:30\",\n\t\t\t\t\t\t\t\t\t\t\"Irish Standard Time\" : \"GMT+1\",\n\t\t\t\t\t\t\t\t\t\t\"Israel Standard Time\" : \"GMT+2\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\"MST\" : {\n\t\t\t\t\t\t\t\t\t\t\"Mountain Standard Time\" : \"GMT-7\",\n\t\t\t\t\t\t\t\t\t\t\"Malaysia Standard Time\" : \"GMT+8\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\"WGST\" : {\n\t\t\t\t\t\t\t\t\t\t\"West Greenland Time\" : \"GMT-3\",\n\t\t\t\t\t\t\t\t\t\t\"West Greenland Summer Time\" : \"GMT-2\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tvalue = str.match( end_rgx )[ 1 ],\n\t\t\t\t\t\t\t\tclone_value = clone[ value ],\n\t\t\t\t\t\t\t\tto_send = ns[ value ],\n\t\t\t\t\t\t\t\tfrm_long;\n\n\t\t\t\t\t\t\t\tobj.timezoneName = value;\n\n\t\t\t\t\t\t\t\tif( clone_value ){\n\t\t\t\t\t\t\t\t\tvar return_str = convert_timezone_DLS.call( _this, date_obj, timezone, 'long' );\n\t\t\t\t\t\t\t\t\tfor( var key in clone_value ){\n\t\t\t\t\t\t\t\t\t\tif( return_str.indexOf( key ) != -1 ){\n\t\t\t\t\t\t\t\t\t\t\tto_send = clone_value[ key ];\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if( !to_send ){\n\t\t\t\t\t\t\t\t\tto_send = convert_timezone_DLS.call( _this, date_obj, timezone, 'long' );\n\t\t\t\t\t\t\t\t\tfrm_long = value;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tvar dual = [ 'AT', 'CT', 'ET', 'MT', 'PT' ];\n\t\t\t\t\t\t\t\t\tif( dual.indexOf( value ) != -1 ){\n\t\t\t\t\t\t\t\t\t\tto_send = to_send.replace( /\\/(.+)/, '' );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tfn( to_send, true, frm_long );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tfn( str );\n\n\t\t\t\treturn obj;\n\t\t\t},\n\n\t\t\tsplit_date : function( date_obj ){\n\t\t\t\tif( this.is_IE ){\n\t\t\t\t\tvar dobj = this.getDObj(),\n\t\t\t\t\thr = dobj.getHours(),\n\t\t\t\t\tobj = {\n\t\t\t\t\t\tyear : dobj.getFullYear(),\n\t\t\t\t\t\tmonth : dobj.getMonth() + 1,\n\t\t\t\t\t\tdate : dobj.getDate(),\n\t\t\t\t\t\thour : hr,\n\t\t\t\t\t\tminute : dobj.getMinutes(),\n\t\t\t\t\t\tsecond : dobj.getSeconds(),\n\t\t\t\t\t\tmeridian : hr > 11 ? \"PM\" : \"AM\",\n\t\t\t\t\t\ttimezone : this.timezoneOffset( date_obj )\n\t\t\t\t\t};\n\t\t\t\t\treturn obj;\n\t\t\t\t} else {\n\t\t\t\t\ttry{\n\t\t\t\t\t\tvar timezone_date = convert_timezone_DLS.call( this, date_obj, this._timezone ),\n\t\t\t\t\t\ttimezone_split = this.parseDate( timezone_date, date_obj, this._timezone );\n\t\t\t\t\t\treturn timezone_split;\n\t\t\t\t\t} catch( e ){\n\t\t\t\t\t\tthis.is_IE = true;\n\t\t\t\t\t\treturn this.split_date( date_obj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\ttimezoneOffset : function( date_obj ){\n\t\t\t\tif( isDef( this._timezone ) ){\n\t\t\t\t\tif( this.is_IE ){\n\t\t\t\t\t\tvar value = timeZoneOffsets[ this._timezone ];\n\t\t\t\t\t\treturn -( isDef( value ) ? value : this._timezone );\n\t\t\t\t\t}\n\n\t\t\t\t\tvar timezone_split = this.split_date( date_obj );\n\n\t\t\t\t\treturn timezone_split.timezone;\n\t\t\t\t}\n\n\t\t\t\tif( this.validate() ){\n\t\t\t\t\treturn this.toDate().getTimezoneOffset();\n\t\t\t\t}\n\n\t\t\t\treturn new Date().getTimezoneOffset();\n\t\t\t},\n\n\t\t\tutcOffset : function( arg ) {\n\t\t\t\tif( this._isValid ) {\n\t\t\t\t\treturn this.timezoneOffset( this.toDate() );\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t}\n\n\t\t$L.moment = function( arg, format, uL, lL ){\n\t\t\treturn new lyteMoment( arg, format, uL, lL );\n\t\t}\n\n\t\t$L.moment.lyteMoment = lyteMoment;\n\n\t\t$L.moment.setLimits = function( a, b ){\n\t\t\tuLimit = a;\n\t\t\tlLimit = b;\n\t\t}\n\n\t\t$L.moment.setTimezone = function( arg, off ){\n\t\t\tdefault_timezone = arg;\n\t\t\tif( isDef( off ) ){\n\t\t\t\tdefault_offset = off;\n\t\t\t}\n\t\t}\n\n\t\t$L.moment.setWod = function( value ){\n\t\t\twod = value;\n\t\t}\n\t}\n} );",";( function( cb ){\n\tif( typeof define == \"function\" && define.amd ){\n\t\t  define( [ \"@zoho/lyte-dom\" ], cb );\n\t  } else {\n\t\t  cb( window.$L );\n\t  }\n} )( function( $L ){\n   if( $L ) {\n    var uA = window.navigator.userAgent, \n    isSaf =  { \n        uA : uA, \n        isUbuntu : /ubuntu/ig.test( uA ), \n        isIpad : /ipad/ig.test( uA ), \n        safari : /safari/ig.test( uA ), \n        isIE11Lyte : /rv:11/ig.test( uA ), \n        isEdgeLyte : /Edge/ig.test( uA ), \n        mode : {}, \n        chrome  : !!window.chrome , \n        firefox : /firefox/ig.test( uA ) \n    };\n\n    function appendDiv( className, obj, dir, is_parent ) {\n        var div = document.createElement( 'div' ), innerDiv;\n        div.className = className;\n        div._scrolldiv = this;\n        div.style.visibility = 'hidden';\n        innerDiv = document.createElement( 'div' );\n        innerDiv.classList.add( 'lyteScrollDiv' );\n        if( obj.handlerClass ) {\n            innerDiv.classList.add( obj.handlerClass );\n        }\n        if( obj.containerClass ) {\n            div.classList.add( obj.containerClass )\n        }\n        div.appendChild(innerDiv);\n        if( dir ) {\n            innerDiv._direction = dir;\n            if( obj.horizontalContainerClass ){\n                div.classList.add( obj.horizontalContainerClass );\n            }\n            if( obj.horizontalHandlerClass ) {\n                innerDiv.classList.add( obj.horizontalHandlerClass );\n            }\n            this._horiDiv = div;\n        } else {\n            if( obj.verticalContainerClass  ) {\n                div.classList.add( obj.verticalContainerClass );\n            }\n            if( obj.verticalHandlerClass ){\n                innerDiv.classList.add( obj.verticalHandlerClass );\n            }\n            this._vertDiv = div;\n        }\n\n        ( is_parent ? this.parentElement : this ).appendChild( div )\n        \n        div.addEventListener( 'click', outerDivClick, true );\n        innerDiv.addEventListener( 'mousedown', innerDivClick );\n        if( !this._infiniteScroll ){        \n            innerDiv.addEventListener( 'touchstart', innerDivClick );       \n        }\n        return div;\n    }   \n\n    function set( elem, prop, val ) {\n        if( elem.style[ prop ] != val ){\n            elem.style[ prop ] = val\n        }\n    }\n\n    function checkscrollable( evt ){\n        evt = evt || { target : this };\n        var target = evt.target.correspondingElement || evt.target, ret;\n\n        if( target.closest( '.lyteConnectWrapper.preventWheel' ) ){\n            return true;\n        }\n        \n        while( target && target != this ) {\n            if( target.classList.contains( 'preventWheel' ) ) {\n                ret = true;\n                break;\n            }\n            target = target.parentElement\n        }\n        return ret\n    }\n\n    function check( flag, elem, obj, mode, evt ){\n        var fg;\n        evt = evt || {};\n\n        window.fn = function( elem ){\n            set( elem, 'visibility', 'hidden' );\n            elem.classList.remove( 'visible' );\n        };\n\n        if( !flag.scroll ) {\n            var is_showon_scroll = this._scrollData.showOn == 'scroll';\n            if( !( [ 'mouseenter', 'touchstart' ].indexOf( evt.type ) != -1 && is_showon_scroll ) ){\n                var from_reset = ( this._enableScroll = !flag.frm_reset ),\n                is_event_added = $L( this ).hasClass( \"eventBinded\" );\n\n                if( elem && ( !is_showon_scroll || !flag.frm_reset ) ) {\n                    clearTimeout( elem._entertimeout );\n                    clearTimeout( elem._leavetimeout );\n                    delete elem._entertimeout; delete elem._leavetimeout;\n                    if( !flag.scrollbar ){\n\n                        if( !from_reset && !is_event_added ){\n                            return;\n                        }\n\n                        if( evt.type == \"touchstart\" ){\n                            elem._entertimeout = setTimeout( set.bind( this, elem, 'visibility', 'visible' ), 150 );\n                        } else {\n                            set( elem, 'visibility', 'visible' );\n                        }\n                        elem.classList.add( 'visible' );\n                        updatePos.call( this, mode, undefined, {}, obj );\n                    } else{\n                        window.fn( elem );\n                    }\n                }\n            }\n            fg = true\n        } else {\n            if( elem ) {\n               window.fn( elem );\n            }\n        }\n        return fg\n    }\n\n    function initialWheel( evt ){\n        this.removeEventListener( 'wheel', initialWheel, true )\n        if( !this.classList.contains( 'eventBinded' ) ){\n            var close_connect = this.closest( \"lyte-connect\" );\n            if( !close_connect ){\n                mouseenter.call( this, { type : 'mouseenter' } );\n            }\n        }\n        evt.preventDefault()\n    }\n\n    function format_bcr( bcr ){\n        var obj = {};\n        [ 'x', 'y', 'bottom', 'height', 'top', 'width', 'left', 'right' ].forEach( function( item ){\n            obj[ item ] = Math.round( bcr[ item ] );\n        });\n        return obj;\n    }\n\n    function mouseenter( evt, frm_reset ) {\n        // console.log( evt.target, evt.type, evt.currentTarget );\n        if( this.classList.contains( 'eventBinded' ) && evt != true ){\n            return\n        }\n        if( evt.type == 'mouseenter' && this._prtmseenr ){\n            return;\n        }\n        var flag, \n        obj = { scrollLeft : Math.round( this.scrollLeft ), scrollTop : Math.round( this.scrollTop ), scrollWidth : this.scrollWidth, scrollHeight : this.scrollHeight, bcr : format_bcr( this.getBoundingClientRect() ) },\n        scrolldata = this._scrollData;\n\n        this._wheelObj = obj\n        if( this.classList.contains( 'lyteTableScroll' ) ){\n            forTable.call( this, obj )\n        }\n        this._direction = window.getComputedStyle(  this ).direction;\n        obj.vertbcr = this._vertDiv ?  this._vertDiv.getBoundingClientRect() : {}\n        obj.horbcr = this._horiDiv ?  this._horiDiv.getBoundingClientRect() : {}\n        flag = check.call( this, fitForScroll.call( this, true, obj, frm_reset ), this._vertDiv, obj, true, evt )\n        flag = check.call( this, fitForScroll.call( this, false, obj, frm_reset ), this._horiDiv, obj, false, evt ) || flag\n        if( flag && evt ) {\n            this._mouseleave = this._mouseleave || mouseleave.bind( scrolldata.appendTo == \"parent\" ? this.parentElement : this );\n            if( evt.type == \"touchstart\" ) {\n               if( evt.touches.length == 1 ){\n                    clearTimeout( this._tchtime );\n                    document.addEventListener( 'touchcancel', this._mouseleave, true )\n                } else {\n                    return;\n                }\n            } else {\n                this.addEventListener( 'wheel', wheelEvent, true );\n                this.addEventListener('keydown', keydownFunc, true);\n                if( this._scrollData.showOn == 'scroll' ){\n                    this.addEventListener( 'mousemove', hideScrollbar, true );\n                }\n            }\n            this._allowTouch = true;\n            document.addEventListener( 'touchend', this._mouseleave, true )\n            this.classList.add( 'eventBinded' )\n            this._tabindex = this._tabindex == undefined ? this.tabIndex : this._tabindex;\n            if(this.tabIndex == -1){\n                this.tabIndex = scrolldata.tabIndex || 0;\n            }\n        }\n    } \n\n    function keydownFunc( evt ) {\n        if( evt.target != this ){\n            return\n        }\n\n        var key = evt.key,\n        elem = this,\n        sL =  Math.round( elem.scrollLeft ),\n        sT = Math.round( elem.scrollTop ),\n        wd = elem.offsetWidth,\n        hgt = elem.offsetHeight,\n        s_wd = elem.scrollWidth,\n        s_hgt = elem.scrollHeight,\n        obj = { \n            scrollLeft : sL, \n            scrollTop : sT, \n            scrollWidth : s_wd, \n            scrollHeight : s_hgt, \n            bcr : elem.getBoundingClientRect() \n        },\n        step = this._scrollData.keyStep,\n        dir = this._direction == 'rtl',\n        pos,\n        mode,\n        __new,\n        is_negative = dir && ( !window._lyteUiUtils || window._lyteUiUtils.isNegativeScroll() ),\n        meta = evt.metaKey || evt.ctrlKey;\n\n        switch( key ){\n            case \"ArrowLeft\" : {\n                mode = false;\n\n                if( meta ){\n                    if( dir ){\n                        if( is_negative ){\n                            __new = wd - s_wd;\n                        } else {\n                            __new = s_wd - wd;\n                        }\n                    } else {\n                        __new = 0;\n                    }\n                } else {\n                    if( dir && is_negative ){\n                        dir = false;\n                    }\n                    __new = sL - step * ( dir ? -1 : 1 );\n                }\n            }\n            break;\n            case \"ArrowRight\" : {\n                mode = false;\n                \n                if( meta ){\n                    if( dir ){\n                        if( is_negative ){\n                            __new = 0;\n                        } else {\n                            __new = wd - s_wd;\n                        }\n                    } else {\n                        __new = s_wd - wd;\n                    }\n                } else {\n                    if( dir && is_negative ){\n                        dir = false;\n                    }\n                    __new = sL + step * ( dir ? -1 : 1 );\n                }\n            }\n            break;\n            case \"ArrowDown\" : {\n                __new = Math.min( sT + step, s_hgt - hgt );\n                mode = true;\n            }\n            break;\n            case \"ArrowUp\" : {\n                __new = Math.max( 0, sT - step );\n                mode = true;\n            }\n            break;\n            case \"PageDown\" : {\n                __new = Math.min( sT + hgt, s_hgt - hgt );\n                mode = true;\n            }\n            break;\n            case \"PageUp\" : {\n                __new = Math.max( sT - hgt, 0 );\n                mode = true;\n            }\n            break;\n            case \"Home\" : {\n                __new = 0;\n                mode = true;\n            }\n            break;\n            case \"End\" : {\n                __new = s_hgt - hgt;\n                mode = true;\n            }\n            break;\n        }\n\n        if( mode != void 0 && shouldPrevent.call( elem, obj, mode, __new - ( mode ? sT : sL ) ) ){\n            elem[ mode ? 'scrollTop' : 'scrollLeft' ] = __new;\n            scroll.call( elem, evt )\n            evt.preventDefault();\n        }\n    }\n\n    function mouseleave( evt ){\n        evt = evt || {};\n        if( ( evt.relatedTarget && this.contains( evt.relatedTarget ) ) || document._scrollmouseup ){\n            return\n        }\n        if( evt.type == 'touchend' ) {     \n            var tar = evt.target.correspondingElement || evt.target;        \n            if( tar && tar.classList.contains( 'lyteScrollContainer' ) ) {      \n                return;     \n            }       \n        }\n        var bars = $L( this ).children( '.lyteScrollContainer' ), scrlDiv = this._scrolldiv || this;\n        if( bars.length ) {\n            for(  var i = 0; i < bars.length; i++ ) {\n                var __cur_bar = bars[ i ];\n\n                clearTimeout( __cur_bar._entertimeout );\n                clearTimeout( __cur_bar._leavetimeout );\n                delete __cur_bar._entertimeout;\n                delete __cur_bar._leavetimeout;\n\n                __cur_bar.classList.remove( 'visible' )\n                if( evt.type == 'touchend' ){\n                    __cur_bar._leavetimeout = setTimeout( set.bind( this, __cur_bar, 'visibility', 'hidden'), 150 )\n                } else {\n                    __cur_bar.style.visibility = 'hidden';\n                }\n            }\n            if( evt.type == 'mouseleave' ) {\n                scrlDiv.removeEventListener('wheel', wheelEvent, true);\n                scrlDiv.removeEventListener('keydown', keydownFunc, true);\n                scrlDiv.removeEventListener( 'mousemove', hideScrollbar, true );\n                scrlDiv.addEventListener( 'wheel', initialWheel, true );\n            } else if( evt.type == 'touchend' || evt.type == \"touchcancel\" ) {\n                scrlDiv._prtmseenr = true;\n                scrlDiv._tchtime = setTimeout( function(){\n                    delete scrlDiv._prtmseenr;\n                }, 500 )\n                document.removeEventListener( 'touchcancel', scrlDiv._mouseleave, true )\n            }\n            if( evt.type ){\n                document.removeEventListener( 'touchend', scrlDiv._mouseleave, true )\n                delete scrlDiv._allowTouch;\n                scrlDiv.classList.remove( 'eventBinded' );\n                // scrlDiv.tabIndex = this._scrolldiv._tabindex;\n                // delete scrlDiv._tabindex;\n                 delete scrlDiv._wheelObj;\n                delete scrlDiv._prevPosY; delete scrlDiv._mouseleave;\n                delete scrlDiv._prevPosX; delete scrlDiv._wheelEvt;\n            }\n            delete scrlDiv._enableScroll;\n        }\n    }\n\n    function outerDivClick( evt ) {\n        if( !this.classList.contains( 'visible' ) ){\n            return\n        }\n        var isTch = evt.type == \"touchmove\";       \n        if( isTch ) {       \n            if( evt.touches.length > 1 ){       \n                return;     \n            } else {        \n                evt.preventDefault();       \n                evt = evt.touches[ 0 ]      \n            }       \n        }       \n        var elem = this._scrolldiv, mode, inn = this.children[ 0 ], outBcr = this.getBoundingClientRect(), inBcr = inn.getBoundingClientRect(),\n        obj = { scrollLeft : Math.round( elem.scrollLeft ), scrollTop : Math.round( elem.scrollTop ), scrollWidth : elem.scrollWidth, scrollHeight : elem.scrollHeight, bcr : elem.getBoundingClientRect() },\n        hgt = 'width', top1 = 'left', sT = 'scrollLeft', sH = 'scrollWidth', bt = 'right', cY = 'clientX';\n        if( this.classList.contains( 'lyteTableScroll' ) && !obj.$nodeClient ){\n            forTable.call( this, obj )\n        }\n        obj.vertbcr = this._vertDiv ?  this._vertDiv.getBoundingClientRect() : {}\n        obj.horbcr = this._vertDiv ?  this._horiDiv.getBoundingClientRect() : {}\n        if(!inn._direction){\n            mode = true;\n            hgt = 'height', top1 = 'top', sT = 'scrollTop', sH = 'scrollHeight', bt = 'bottom', cY = 'clientY';\n        }\n        var scramt = evt.type != 'click' ? ( evt[ cY ] - ( this.prev || evt[ cY ] ) ) : ( evt[ cY ] - ( inBcr[ top1 ] + inBcr[ hgt ] / 2 ) ), newsL;\n        newsL = ( scramt / ( obj.bcr[ hgt ] + obj.bcr[ top1 ] - outBcr[ top1 ] ) * obj[ sH ] )\n        elem[ sT ] += ( newsL ) ;\n        scroll.call( elem, evt );\n        this.prev = evt[ cY ];\n    }\n\n    function innerDivClick( evt ) {\n       var isTch = evt.type == \"touchstart\",\n       __parentNode = this.parentNode,\n       __document = document,\n       ael = 'addEventListener';\n\n        __document[ ael ]( isTch ? 'touchmove' : 'mousemove', __document._scrollmousemove = outerDivClick.bind( __parentNode ), true );\n        __document[ ael ]( isTch ? 'touchend' : 'mouseup', __document._scrollmouseup = mouseup.bind( __parentNode ), true );\n\n        evt.preventDefault();\n        evt.stopPropagation();\n    }\n\n    function mouseup( evt ) {\n        var isTch = evt.type == \"touchend\",\n        __document = document,\n        rel = \"removeEventListener\",\n        scroll_elem = this._scrolldiv || this,\n        target = evt.target,\n        scrolldata = scroll_elem._scrollData;\n\n        __document[ rel ]( isTch ? 'touchmove' : 'mousemove', __document._scrollmousemove, true );\n        __document[ rel ]( isTch ? 'touchend' : 'mouseup', __document._scrollmouseup, true );\n\n        delete __document._scrollmousemove;\n        delete __document._scrollmouseup; \n        delete this.prev;\n\n        if( !scroll_elem.contains( target.correspondingElement || target ) && scrolldata.showOn != 'always' ){\n            mouseleave.call( scrolldata.appendTo == \"parent\" ? scroll_elem.parentNode : scroll_elem , { type : 'mouseleave' } );\n        }\n    }\n\n    function mousedown( evt ) {\n\n        var scrolldata = this._scrollData,\n        __document = document;\n\n        if( __document._scrollmouseup ) {\n            return\n        }\n        __document.addEventListener( 'mouseup', __document._scrollmouseup = mouseup.bind( scrolldata.appendTo == \"parent\" ? this.parentElement : this ), true )\n    }\n\n    function fitForScroll( mode, obj, frm_reset ) {\n        var sL = 'scrollTop', sW = 'scrollHeight', wd = 'height', elem = mode ? this._vertDiv : this._horiDiv,\n        scrolldata = this._scrollData,\n        margin = scrolldata.scrollYMarginOffset;\n\n        if( !mode ) {\n            sL = 'scrollLeft', sW = 'scrollWidth', wd = 'width';\n            margin = scrolldata.scrollXMarginOffset;\n        }\n        if( obj[ sL ] + obj.bcr[ wd ] >= obj[ sW ] && obj[ sL ] == 0 ){\n            if( elem && elem.classList.contains( 'visible' ) ) {\n                check.call( this, { scroll : true, scrollbar : true }, elem )\n            }\n            return {\n                scroll : true,\n                scrollbar : true,\n                frm_reset : frm_reset\n            }\n        }\n\n        return{\n            scroll : false,\n            scrollbar : ( obj[ sW ] - obj.bcr[ wd ] ) <= margin,\n            frm_reset : frm_reset\n        }\n    }\n\n    function wheelEvent( evt ){\n         if( checkscrollable.call( this, evt ) ) {\n                return\n            }\n        if( evt.type == 'touchmove' ) { \n            if( this._allowTouch && evt.touches.length == 1 ) {\n                var curr = evt.touches[ 0 ];\n                wheelEvent1.call( this, evt, [ (this._prevPosX || curr.clientX ) - curr.clientX,  ( this._prevPosY || curr.clientY ) - curr.clientY ] )\n                this._prevPosY = curr.clientY;\n                this._prevPosX = curr.clientX;\n            }\n        } else {   \n            wheelEvent1.call( this, evt )\n        }\n    }\n\n    function shouldPrevent( obj, mode, val ){\n        var sL = 'scrollTop', sW = 'scrollHeight', wd = 'height', elem = mode ? this._vertDiv : this._horiDiv;\n        if( !mode ) {\n            sL = 'scrollLeft';\n            sW = 'scrollWidth';\n            wd = 'width';\n        }\n\n        if( mode ){\n            if( ( val > 0 && Math.round( obj[ sL ] + obj.bcr[ wd ] ) >= obj[ sW ] ) || ( val < 0 && obj[ sL ] == 0 ) ){\n                return false\n            }\n        } else {\n            if( ( val > 0 && Math.round( obj[ sL ] + obj.bcr[ wd ] ) >= obj[ sW ] ) || ( val < 0 && Math.round( -obj[ sL ] + obj.bcr[ wd ] ) >= obj[ sW ] ) ){\n                return false\n            } else if( !mode && isSaf.firefox && this._direction == 'rtl' && ( val < 0 && obj[ sL ] == 0 ) ){\n                return true\n            } else if( ( val < 0 && obj[ sL ] == 0 ) && !( val < 0 && isSaf.safari && this._direction == 'rtl' && obj[ sL ] == 0 ) ){\n                return false;\n            }\n        }\n        return true\n    }\n\n    function getWheel( evt ) {\n        var data = this._scrollData, min = data.min, max = data.max,\n        fact1 = data.wheelSpeed, fact = fact1, uA = isSaf.uA.toLowerCase(), inf = this._infiniteScroll, ie = isSaf.isIE11Lyte;\n        if( ( uA.indexOf('edge') != -1 || (( uA.indexOf('trident') != -1 || uA.indexOf('msie') != -1)) ) && this._direction == 'rtl' ){\n            fact1 *= -1\n        }\n        // if( evt.shiftKey ) {\n        //     fact1 *= -1; fact *= -1; \n        // }\n        var x, \n        y, \n        delta = evt.deltaMode && evt.deltaMode == 1,\n        __deltaX = evt.deltaX,\n        __deltaY = evt.deltaY;\n\n        if( evt.shiftKey ){\n            var __temp = __deltaX;\n            __deltaX = __deltaY;\n            __deltaY = __temp;\n        }\n\n        if( __deltaX > 0 ) {\n            x = Math.max( delta ? ( __deltaX * 6 ) :  __deltaX, (inf ? 0 : 4 ) )\n        } else if( __deltaX < 0 ) {\n            x = Math.min( inf ? 0 : -4, delta ? ( __deltaX * 6 ) : __deltaX )\n        }\n        if( __deltaY > 0 ) {\n            y = Math.min( max, Math.max( delta ? ( __deltaY * 6 ) : __deltaY, inf ? 0 : 4 ), ie ? 20 : Infinity );\n        } else if( __deltaY < 0 ) {\n            y = Math.max( min, Math.min( inf ? 0 : -4, delta ? ( __deltaY * 6 ) : __deltaY ), ie ? -20 : -Infinity );\n        }\n        return [ x * fact1, y * fact ]\n    }\n\n    function nestedScroll( evt, ret ){  \n        var target = evt.target;\n        while( target != this ) {\n            var sT = Math.round( target.scrollTop ),\n            sH = target.scrollHeight,\n            oH = target.offsetHeight,\n            compsty = window.getComputedStyle( target ),\n            isMatch = ( /scroll|auto/i.test( compsty.overflowY ) || ( target.classList.contains( 'lyteScrollBar' ) && /hidden/i.test( compsty.overflowY  ) ) );\n\n\n            if( oH < sH  ){\n                if( ret ){\n                    if( oH + sT < sH && isMatch ){\n                        return true;\n                    }\n                } else {\n                    if( sT && isMatch ){\n                        return true;\n                    }\n                }\n            }\n            target = target.parentNode;\n        }\n    }\n\n    function wheelEvent1( evt, tch ) {            \n        var ret = tch || getWheel.call( this, evt );\n        var a = ret[ 0 ] || 0, \n        b = ret[ 1 ] || 0, \n        mode = false, \n        obj = this._wheelObj || {} , \n        fit, \n        stpre, \n        isTable = this.classList.contains( 'lyteTableScroll' ),\n        __deltaX = evt.deltaX,\n        __deltaY = evt.deltaY,\n        scrolldata = this._scrollData;\n\n        if( evt.shiftKey ){\n            var __temp = __deltaX;\n            __deltaX = __deltaY;\n            __deltaY = __temp;\n        }\n\n        if( Math.abs( tch ? a : ( __deltaX || 0 ) ) <= Math.abs( tch ? b : ( __deltaY || 0 ) ) ) {\n            mode = true\n        }\n        if( scrolldata.nested && mode && nestedScroll.call( this, evt, b > 0 ) ){\n            return;\n        }\n\n        if( scrolldata.showOn == 'scroll' ){\n            if( !this._enableScroll ){\n                mouseenter.call( this, true )\n                evt.preventDefault();\n                return\n            }\n            clearTimeout( this._scrollplugin )  \n            this._scrollplugin = setTimeout(mouseleave.bind( scrolldata.appendTo == \"parent\" ? this.parentElement : this, {} ), scrolldata.tOut )\n        }\n\n        if( this._scrollEnd ) {\n            obj= { scrollLeft : Math.round( this.scrollLeft ), scrollTop : Math.round( this.scrollTop ), scrollWidth : this.scrollWidth, scrollHeight : this.scrollHeight, bcr : format_bcr( this.getBoundingClientRect() ) };\n            this._wheelObj = obj\n            if( this.classList.contains( 'lyteTableScroll' ) ){\n                forTable.call( this, obj )\n            }\n        }\n        if( this._wheelObj ){\n            fit = fitForScroll.call( this, mode, obj );\n            if(( fit.scroll && mode /*&& b > 0*/ && (  !this._vertDiv || ( this._vertDiv && !this._vertDiv.classList.contains( 'visible' ) ) ) ) || ( fit.scroll && !mode /*&& a < 0*/ && ( !this._horiDiv || ( this._horiDiv && !this._horiDiv.classList.contains( 'visible' ) ) ) ) ){\n                return\n            }\n            stpre = shouldPrevent.call( this, obj, mode, mode ? b : a ); \n\n\n            var is_inf = this._infiniteScroll,\n            is_stopped = is_inf ? this.comp._stopScroll : false;\n\n            if( ( is_inf && b > 0 ) || stpre ){\n                 evt.preventDefault();\n                if( !stpre && isTable && mode ) {\n                    this.comp.scrollTable.call( this.comp, { yScroll : b }, this._wheelObj )\n                }\n            } else{\n                if( scrolldata.preventOnEnd ){\n                    evt.preventDefault();\n                }\n                return\n            }\n        }\n        if( mode ) {\n            if( isSaf.isIE11Lyte ) {\n                if( this._wheelObj ){\n                    this._wheelObj.scrollTop = Math.max( Math.min( this._wheelObj.scrollTop + b, this._wheelObj.scrollHeight - this._wheelObj.bcr.height ), 0 )\n                    if(  isTable ) {\n                        evt.yScroll = b;\n                        this.comp.scroll.call( this, evt )\n                    }\n                    this.scrollTop += b;\n                } \n            } else if( !isSaf.isIE11Lyte ) {\n                this.scrollTop += b;\n            }\n        } else {\n             if( isSaf.isIE11Lyte ) {\n                if( this._wheelObj ) {\n                    this._wheelObj.scrollLeft = Math.max( Math.min( this._wheelObj.scrollLeft + a, this._wheelObj.scrollWidth - this._wheelObj.bcr.width ), 0 )\n                    if(  isTable ) {\n                        evt.xScroll = a;\n                        this.comp.scroll.call( this, evt )\n                    }\n                    this.scrollLeft += a;\n                }\n            } else {\n               this.scrollLeft += a; \n            }\n         }   \n        if( isSaf.safari || isSaf.isIE11Lyte || isSaf.isIpad ) {\n                this._alive = true;\n                clearTimeout( this._alivetime )\n                this._alivetime = setTimeout( function(){\n                   delete this._alive; delete this._alivetime; \n                }.bind( this ), 16 )\n            this._scrollFun.call( this, evt )\n        }\n\n\n        // if( this.comp ){\n        //     clearTimeout( this._overlay.time );\n        //     !this._overlay.classList.contains( 'lytescrolling' ) && this._overlay.classList.add( 'lytescrolling' );\n        //     this._overlay.time = setTimeout( function(){\n        //         this._overlay.classList.remove( 'lytescrolling' );\n        //         delete this._overlay.time;\n        //     }.bind( this ), 250 ) \n        // }\n    }\n\n    function scroll( evt ) {\n        var a, b, issafIE = isSaf.isIE11Lyte || isSaf.safari || isSaf.isIpad, isIe = isSaf.isIE11Lyte ;\n        if( issafIE && evt && evt.type == 'scroll' && ( this._alive && !evt._byFunc ) ) {\n            trigEvt.call( this, isSaf.mode.a, isSaf.mode.b, this._wheelObj || { bcr : {} }, evt )\n        } else{\n            var obj= { scrollLeft : Math.round( this.scrollLeft ), scrollTop : Math.round( this.scrollTop ), scrollWidth : this.scrollWidth, scrollHeight : this.scrollHeight, bcr : this.getBoundingClientRect() };\n            this._wheelObj = obj\n            if( this.classList.contains( 'lyteTableScroll' ) ){\n                forTable.call( this, obj )\n            }\n            if( this.prevScrlLeft != obj.scrollLeft ) {\n                a = obj.scrollLeft - ( this.prevScrlLeft || 0 );\n                b = 0;\n                updatePos.call( this, false, a , evt, obj )\n            } \n            if( this.prevScrlTop!= obj.scrollTop ) {\n                b = obj.scrollTop - ( this.prevScrlTop || 0 );\n                a = 0;\n                updatePos.call( this, true, b , evt, obj )\n            }\n            isSaf.mode.b = b; isSaf.mode.a = a;\n            if( !isIe || ( issafIE && ( !this._alive || evt._byFunc ) ) ) {\n               if(  this.classList.contains( 'lyteTableScroll' ) ) {\n                    this.comp.scroll.call( this, evt )\n                }\n            }\n        }\n    }\n\n     function hideScrollbar( evt ) {\n        clearTimeout( this._scrollplugin );  \n        this._scrollplugin = setTimeout( mouseleave.bind( this._scrollData.appendTo == \"parent\" ? this.parentElement : this ), 500 );\n    }\n\n    function forTable( obj ) {\n        var component =  this.comp, headerList = component.$node.getElementsByTagName( 'lyte-th' )\n        if( this._infiniteScroll ){\n            obj.$nodeClient = this.parentElement.getBoundingClientRect();\n            var dummy =  this.getElementsByClassName( 'lytePreventInfiniteScroll' );\n            obj.neglected = [];\n            for( var m = 0; m < dummy.length; m++ ) {\n                if( /*isVisible( dummy[ m ] )*/ !dummy[ m ].classList.contains( 'lyteHidden' ) ) {\n                    obj.neglected.push( dummy[ m ] );\n                }\n            }\n\n            obj.compNeg = dummy;\n            if( this.comp._top != undefined ) {\n                obj.topElem = [];\n                var body = this.getElementsByTagName( 'lyte-tbody' )[ 0 ],\n                another = body.getElementsByTagName( 'lyte-tr' );\n                for( var n = 0; n < another.length; n++ ) {\n                    if( !another[ n ].classList.contains( 'dummy' ) ) {\n                        obj.topElem.push( another[ n ] );\n                    }\n                }\n                obj.topElem = obj.topElem[ this.comp._top + obj.compNeg.length ]\n                obj.topElemClient = obj.topElem ? this.comp.topElem( obj.topElem ) : {};\n                obj.bottmElem = body.querySelector( 'lyte-tr:nth-of-type(' + ( ( this.comp._bottom + 1 + obj.compNeg.length ) ) + ')' );\n                obj.bottmElemClient = obj.bottmElem ? this.comp.topElem( obj.bottmElem ) : {}\n                obj.tbody = body\n                obj.tbodyClient = obj.tbody ? obj.tbody.getBoundingClientRect() : {};\n            }\n        }\n        obj.scrollDivClient = obj.bcr;\n        for(var k = 0; k < headerList.length; k++)\n            {\n                headerList[k].property = headerList[k].getBoundingClientRect();\n                headerList[k].order = k\n            }\n        obj.calculated = true;  \n    }\n\n    function trigEvt( a, b, obj, evt ) {\n        delete this._scrollEnd; \n\n        var offset = this._scrollData.offset,\n        __direction = this._direction == \"rtl\";\n\n        if( ( ( Math.ceil( obj.scrollLeft + obj.bcr.width + offset.x ) >= obj.scrollWidth ) && !( __direction && isSaf.chrome ) ) || ( ( isSaf.firefox || isSaf.safari ) && __direction && ( Math.ceil( -obj.scrollLeft + obj.bcr.width + offset.x ) >= obj.scrollWidth ) ) || ( __direction && isSaf.chrome &&  obj.scrollLeft == offset.x ) ) {\n            evt.horiScrollEnd = true;\n        }\n        if( Math.ceil( obj.scrollTop + obj.bcr.height + offset.y ) >= obj.scrollHeight ) {\n            this._scrollEnd = evt.vertScrollEnd = true;\n        }\n        evt.yScroll = b; evt.xScroll = a;\n        evt._byPlugin = true;\n        this._wheelObj = obj;\n    }\n\n    function updatePos( mode, a, evt, obj ){\n        var __this = this,\n        __vert = __this._vertDiv,\n        __hori = __this._horiDiv;\n\n        if( parseInt( Math.abs( a ) ) == 0 || ( mode && !__vert ) ||( !mode && !__hori ) ){\n            return;\n        }\n\n        var __out = mode ? __vert : __hori,\n        rail_bcr = obj[ ( mode ? 'vert' : 'hori' ) + 'bcr' ] || __out.getBoundingClientRect(),\n        __inn = __out.children[ 0 ],\n        sL = \"scrollTop\",\n        sW = \"scrollHeight\",\n        wd = \"height\",\n        lt = \"top\",\n        direction = __this._direction == \"rtl\",\n        btm = \"bottom\",\n        __scrolldata = __this._scrollData,\n        __bcr = obj.bcr,\n        is_container = __scrolldata.appendTo != \"parent\",\n        top_offset = mode ? ( __scrolldata.topOffset || 0 ) : 0;\n\n        if( is_container ){\n            rail_bcr = __bcr;\n        }\n\n        if( !mode ){\n            sL = \"scrollLeft\";\n            sW = \"scrollWidth\";\n            wd = \"width\";\n            lt = \"left\";\n        }\n\n        var __width = __bcr[ wd ],\n        rail_bcr_lt = rail_bcr[ lt ],\n        __rt = ( __width - ( rail_bcr_lt + top_offset - __bcr[ lt ] ) ) / obj[ sW ],\n        trt = obj[ sL ] / obj[ sW ],\n        mL = __scrolldata.minLength,\n        minLength = mL ? ( mL != \"auto\" ? mL : 0 ) : 0.1 * __width,\n        __final;\n\n        set( __inn, wd, Math.max( __rt * __width, minLength ).toFixed( 3 ) + 'px' );\n\n        if( direction && __inn._direction ){\n            if( ( isSaf.safari && (  window._lyteUiUtils.isNegativeScroll() || !window.chrome ) ) || isSaf.firefox ) {\n                __final =  ( ( obj[ sL ] / obj[ sW ] * 100 )  * obj.bcr[ wd ] / parseFloat( Math.max( __rt * __width, minLength ).toFixed( 3 ) ) );;\n            } else {\n                __final =  ( ( -( obj[ sW ] - __width - obj[ sL ] ) / obj[ sW ] * 100 ) * __width / parseFloat( Math.max( __rt * __width, minLength ).toFixed( 3 ) ) );\n            }\n            __final = 'translateX(' + __final + '%)';\n        } else {\n            __final = ( mode ? 'translateY' : 'translateX' ) + '(' + trt * ( __width - ( rail_bcr_lt - __bcr[ lt ] ) - ( Math.max( 0, minLength - __rt * __width ) ) ) + 'px)';\n        }\n\n        set( __inn, 'transform', __final );\n\n        if( is_container ){\n            set( __out, wd, __width + 'px' );\n\n            var __other_elem = mode ? __hori : __vert,\n            __to_set = 'translate' + '(' + obj.scrollLeft + 'px,' + obj.scrollTop + 'px)';\n\n            set( __other_elem, 'transform', __to_set );\n            set( __out, 'transform', __to_set );\n        }\n\n        __this.prevScrlLeft = obj.scrollLeft; \n        __this.prevScrlTop = obj.scrollTop;\n\n        if( evt.type ){\n            trigEvt.call( __this, mode ? 0 : a, mode ? a : 0, obj, evt );\n        }\n    }\n\n    function removeScroll(){\n        var elements = this;\n        for( var i = 0; i < elements.length; i++ ) {\n            var elem = elements[ i ], wrap = elem.parentElement;\n            if( !wrap ){\n                continue;\n            }\n\n            var scrolldata = elem._scrollData;\n\n            if( scrolldata ) {\n\n                if( scrolldata.appendTo != \"parent\" ){\n                    wrap = elem;\n                }\n\n                delete elem._scrollData;\n            }\n            var scrollDivs = wrap.querySelectorAll( 'div.lyteScrollContainer' );\n            for(var k = 0; k < scrollDivs.length; k++){\n                if( scrollDivs[k].parentElement == wrap ) {\n                    delete scrollDivs[ k ]._entertimeout;\n                    delete scrollDivs[ k ]._leavetimeout;\n                    wrap.removeChild(scrollDivs[k]);\n                }\n            }\n            elem.classList.remove( 'lyteScrollBar', 'eventBinded' );\n            elem.removeEventListener( 'mouseenter', mouseenter, true );\n            elem.removeEventListener( 'wheel', initialWheel, true );\n            elem.removeEventListener( 'touchstart', mouseenter, true )\n            wrap.removeEventListener( 'mouseleave', mouseleave, true );\n            elem.removeEventListener( 'mousedown', mousedown );\n            elem.removeEventListener( 'touchmove', wheelEvent, { passive : false } )\n            elem.removeEventListener( 'scroll', scroll, true );\n            clearTimeout( elem._tchtime );\n            if( elem._mouseleave ){\n                document.removeEventListener( 'touchcancel', elem._mouseleave, true );\n                document.removeEventListener( 'touchend', elem._mouseleave, true );\n            }\n            delete elem._wheelObj; delete elem._vertDiv; delete elem._horiDiv;\n            delete elem._scrollFun; delete elem._alivetime; delete elem._alive; delete elem._wheelObj;\n            delete elem.resetScrollbar; delete wrap._scrolldiv; delete elem._tchtime;\n            delete elem._allowTouch;\n            elem.classList.remove( 'eventBinded' );\n            elem.tabIndex = elem._tabindex;\n            delete elem._tabindex; delete elem._wheelObj;\n            delete elem._prevPosY; delete elem._mouseleave;\n            delete elem._prevPosX; delete elem._wheelEvt;\n        }\n        return this;\n    }\n\n    function destroy(){\n        $L( '.lyteScrollBar' ).scroll( 'destroy' );\n        window.removeEventListener('scroll', globalscroll, true ); \n        return this; \n    }\n\n    function reset(){\n        var elements = this;\n        for( var i = 0; i < elements.length; i++ ){\n            var __elems = elements[ i ],\n            data = __elems._scrollData;\n\n            if( data ){\n                if( data.appendTo != \"parent\" ){\n                    var obj = {\n                        transform : \"\",\n                        width : \"\",\n                        height : \"\"\n                    };\n                    \n                    $L( __elems._horiDiv ).css( obj );\n                    $L( __elems._vertDiv ).css( obj );\n                }\n               __elems.resetScrollbar( true, true );\n            }\n        }\n        return this;\n    }\n\n    $L.prototype.removeScroll = function(){\n        // console.warn( 'removeScroll deprecated. Use scroll(\"destroy\") instead' );\n        return removeScroll.call( this );\n    }\n\n    $L.prototype.scroll = function( obj ) {\n        if( obj && obj.constructor == String ){\n            if( obj == \"destroy\" ){\n                return removeScroll.call( this );\n            } else if( obj == \"destroyScroll\" ){\n                destroy.call( this );\n            } else if( obj == \"reset\" ){\n                reset.call( this );\n            }\n            return;\n        }\n\n        var fn = function( obj, name, _default ){\n            var value = obj[ name ];\n            if( value == void 0 ){\n                value = _default;\n            }\n            obj[ name ] = value;\n        };\n\n        obj = obj || {};\n        obj.showOn = obj.showOn || 'hover';\n        obj.keyStep = obj.keyStep || 30;\n        obj.wheelSpeed = obj.wheelSpeed || 1;\n        // its a major change. to ensure same behaviour of normal scroll and to overcome issue in browser zoomed state changed this to false\n        fn( obj, 'preventOnEnd', false );\n        obj.offset = obj.offset || { x : 0, y : 0 };\n        obj.tOut = obj.scrollTimeout || 500;\n        obj.nested = obj.nested || false;\n        obj.min = obj.min || -Infinity;\n        obj.max = obj.max || Infinity;\n\n        obj.appendTo = obj.appendTo || \"parent\";\n\n        fn( obj, 'scrollYMarginOffset', 5 );\n        fn( obj, 'scrollXMarginOffset', 5 );\n        if( obj.preventXScroll ){\n            obj.preventHorizontal = true; \n        }\n        if( obj.preventYScroll ){\n            obj.preventVertical = true;\n        }\n        var elements = this,\n        is_parent = obj.appendTo == \"parent\";\n\n        for( var i = 0; i < elements.length; i++ ) {\n            var elem =  elements[ i ], vertDiv, horiDiv, wrp = elem.parentElement;\n            is_parent && set( wrp, 'position', 'relative' );\n            if( elem._scrollData ) {\n                $L( elem ).removeScroll()\n            }\n            elem.resetScrollbar = mouseenter.bind( elements[ i ] );\n            is_parent && ( wrp._scrolldiv = elem );\n            elem._scrollData = obj;\n            if( !obj.preventVertical ) {\n                vertDiv = appendDiv.call( elem, 'lyteScrollContainer lyteScrollContainerY', obj, void 0, is_parent );\n                if(obj.verticalPosition == 'left'){\n                    vertDiv.classList.add('left');\n                }\n            }\n            if( !obj.preventHorizontal ) {\n                vertDiv = appendDiv.call( elem, 'lyteScrollContainer lyteScrollContainerX', obj, true, is_parent );\n                if(obj.horizontalPosition == 'top'){\n                    vertDiv.classList.add('top');\n                }\n            }\n            if(isSaf.firefox ){\n                elem.scrollLeft = 0;\n                elem.scrollTop = 0;\n            } \n            elem.addEventListener( 'mouseenter', mouseenter, true )\n            elem.addEventListener( 'touchstart', mouseenter, true )\n            elem.addEventListener( 'touchmove', wheelEvent, { passive : false } )\n            elem.addEventListener( 'mousedown', mousedown );\n            elem.addEventListener( 'wheel', initialWheel, true );\n            \n            if( obj.showOn != 'always' ){\n                ( is_parent ? wrp : elem ).addEventListener( 'mouseleave', mouseleave, true )\n            } else {\n                setTimeout( mouseenter.bind( elem ), 100, {} )\n            }\n\n            elem.classList.add( 'lyteScrollBar' )\n            elem._scrollFun = scroll;\n        }\n      return this;\n    }\n\n    $L.prototype.destroyLyteScroll = function(){\n        // console.warn( 'destroyLyteScroll deprecated. Use scroll(\"destroyScroll\") instead' );\n        return destroy.call( this );  \n    }\n\n    $L.prototype.resetScrollbar = function(){\n        // console.warn( 'resetScrollbar deprecated. Use scroll(\"reset\") instead' );\n        return reset.call( this );\n    }\n\n    function globalscroll( evt ){\n        var el = evt.target.correspondingElement || evt.target;\n        if( el != document && el != document.body && el._scrollFun ) {\n            el._scrollFun.call( el, evt );\n        }\n        if( evt._byFunc ) {\n            evt.preventDefault();\n            evt.stopPropagation();\n            evt.stopImmediatePropagation();\n        }\n    }\n    window.addEventListener('scroll', globalscroll, true ); \n   }\n} );",";( function( cb ){\n  if( typeof define == \"function\" && define.amd ){\n\t\tdefine( [ \"@zoho/lyte-dom\" ], cb );\n\t} else {\n\t\tcb( window.$L );\n\t}\n})( function( $L ){\n    if( $L ){\n      function getScope( elem, scope ){\n          var data = elem._searchPluginData;\n          scope = data.dynamicScope ? data.dynamicScope( elem ) : scope;\n          if( data.checkFromParent ){\n            scope = elem.parentNode;\n          }\n          return scope;\n      }\n\n     function keyUpBind( event ){\n         if([37,13,38,39,40,91,27,16,18].indexOf(event.keyCode) > -1){ \n           return\n         }\n         var element = this,\n         data = element._searchPluginData,\n         searchDelay = data.searchDelay;\n\n         clearTimeout(this.timeout); \n         clearTimeout( this._iptime );\n         if( searchDelay == void 0 ){\n            pressFunc.call( this, event );\n         } else {\n            this.timeout = setTimeout( pressFunc.bind( this ), searchDelay, event );\n         }\n      }\n\n      function inputBind( event ){\n         clearTimeout( this._iptime );\n         this._iptime = setTimeout( pressFunc.bind( this ), 250, event );\n      }\n\n      function pressFunc( event ){\n          var element = this;\n          event = event || {};\n          var data = this._searchPluginData,\n          ret = findingList.call(this,event),\n          searchList = ret[0],\n          targetList = ret[1],\n          searchComp = ret[2],\n          related = ret[ 3 ],\n          casesen  = data.caseSensitive,\n          minLength = data.minLength ? data.minLength : 0,\n          method = data.method ? data.method : 'contains',\n          keyCode = event.keyCode || event.which,\n          val = fNcase( casesen, element.tagName == 'LYTE-INPUT' ? element.querySelector( 'input,textarea' ).value : element.value, data.trim ),\n          visibleList = [], flag, comp = data.component, hiddenList = [],\n          hiddenSelector = data.hiddenSelector;\n\n          if( data.diacritic ){\n             val = window._lyteUiUtils.convert_diacritics( val );\n          }\n\n          if(val.length >= minLength || keyCode == 8 || keyCode == 46 )\n            { \n              if(val.length)\n                  {\n                    for( var i = 0; i < searchList.length; i++ ) { \n                        var str = fNcase( casesen, searchList[i].trim() );\n                        if( switchfun( method, val, str ) ) {\n                            visibleList.push( searchComp[i] );\n                        } else {\n                           hiddenList.push( searchComp[ i ] );\n                        }   \n                    }\n                  }\n               else\n                  {\n                    visibleList = Array.apply( Array, searchComp );\n                  }   \n              if( data.onSearch && data.onSearch( visibleList, event , val ) == false ){\n                return;\n              }\n               for(var i = 0; i < searchList.length; i++)\n                   {  \n                       var str = fNcase( casesen, searchList[i].trim() ), val = val;\n                       additionalHand.call( this, targetList[i], switchfun( method, val, str ) , val )   \n                   } \n              if( !/tree|accordion/.test( comp ) ) {\n                  for( var i = 0; i < related.length; i++ ) {\n                      if( related[ i ].querySelectorAll( data.target || data.search ).length == related[ i ].querySelectorAll( '.lyteSearchHidden' + ( hiddenSelector ? ( ',' + hiddenSelector ) : '' ) ).length ) {\n                          related[ i ].classList.add( 'lyteSearchHidden' );\n                      } else {\n                          related[ i ].classList.remove( 'lyteSearchHidden' );\n                      }\n                   }\n              } else if( comp == 'accordion' ){\n                  $L.fastdom.measure( accfilter.bind( this, visibleList, hiddenList, val ) )\n              } else if( comp == \"tree\" ){\n                 $L.fastdom.measure( treefilter.bind( this, visibleList, hiddenList, val ) )\n              }\n          }                 \n      }\n\n      function arrayFrom( nodeList ){\n          var arrayList = [];\n          for(var i = 0; i < nodeList.length; i++)\n            {\n              arrayList.push(nodeList[i]);\n            }\n          return arrayList.slice(); \n      }\n\n        function fNcase( bool, value, trim ){\n          if( !bool ){\n              value = value.toLowerCase();\n          }\n          if( trim ){\n              value = value.trim();\n          }\n          return value;\n        }\n\n        function switchfun( method, val, str ){\n          var check;\n          switch( method )\n            {\n              case 'contains' : {\n                  check = str.indexOf( val ) >= 0\n                  break;    \n              }\n              case 'startsWith' : {\n                    check = str.indexOf( val ) == 0; \n                    break;\n              }\n              case 'endsWith' : {\n                    var ind = str.lastIndexOf( val );\n                    if( ind != -1 ){\n                      check = ( ind  + val.length ) == str.length;\n                    }\n                    break;\n              }\n            }\n            return check;\n        }\n\n        function hiderecurse( elem ){\n          for( var i = elem.length - 1; i >= 0; i-- ) {\n              var icon = elem.eq( i );\n              if( icon.hasClass( 'lyteIconOpened' ) ){\n                  setTimeout( icon.click.bind( icon ) , 20 );\n              }\n          }\n        }\n\n        function searchListFind( nodeName ){\n              var searchList = [];\n              var target = [];\n              for(var i = 0; i < nodeName.childElementCount; i++)\n                {\n                  while(nodeName.children[i].childElementCount)\n                    {\n                        window.returnedVal = searchListFind(nodeName.children[i]);\n                        searchList = searchList.concat(window.returnedVal[0]);\n                        target = target.concat(window.returnedVal[1]);\n                        break;\n                    }\n                  if(!nodeName.children[i].childElementCount) \n                      {\n                        searchList.push(nodeName.children[i].textContent);\n                        target.push(nodeName.children[i]);\n                      }\n                }\n              return [searchList,target];\n        };\n\n        function findingList(){\n              var data = this._searchPluginData;\n              var scope = getScope( this, typeof data.scope == 'string' ? document.querySelector(data.scope) : data.scope );\n              var searchList = [], targetList = [], searchComp = [], related = [];\n\n              if( !scope ){\n                  return [ searchList, targetList, searchComp, related ];\n              }\n\n              if(data.search)   \n                  {\n                      searchComp = scope.querySelectorAll( data.search.trim() )\n                      var target = data.target ? data.target : data.search;\n                      for(var j = 0; j < searchComp.length; j++){\n                          var valueToPush = searchComp[ j ].textContent;\n                          if( data.diacritic ){\n                            valueToPush = window._lyteUiUtils.convert_diacritics( valueToPush );\n                          }\n                          searchList.push( valueToPush );\n                      }\n                      targetList = scope.querySelectorAll( target )\n                  }\n              else\n                  {\n                      var callSearchList = searchListFind(scope)\n                      searchList = callSearchList[0];\n                      targetList = callSearchList[1];\n                      searchComp = targetList.slice();\n                  } \n                if( data.related && ( data.target || data.scope  ) ) {\n                    related = scope.querySelectorAll( data.related );\n                }\n                return [searchList, targetList, searchComp, related];  \n        };\n\n        function accfilter ( vis, hid, value ){\n              var scope = $L( getScope( this, this._searchPluginData.scope ) )[ 0 ];\n              for( var i = 0; i < vis.length; i++ ){\n                var close1 = $L( vis[ i ] ).closest( 'lyte-accordion-item', scope )\n                for( var j = 0; j < hid.length; j++ ){\n                  var close2 = $L( hid[ j ] ).closest( 'lyte-accordion-item', scope )\n                  if( close1[ 0 ] == close2[ 0 ] ){\n                      hid.splice( j, 1 );\n                      j--; continue;\n                  }\n                }\n                if( vis[ i + 1 ] ) {\n                  var close2 = $L( vis[ i + 1 ] ).closest( 'lyte-accordion-item', scope );\n                  if( close1[ 0 ] == close2[ 0 ] ){\n                      vis.splice( i + 1, 1 );\n                      i--;\n                  }\n                }\n              }\n              // scope[ 0 ].component.getAllHeights();\n              $L.fastdom.mutate( function(){\n                  for( var i = scope.ltProp( 'exclusive' ) ? ( vis.length - 1 ) : 0; i < vis.length; i++ ){\n                    var isclose = false, close = $L( vis[ i ] ).closest( 'lyte-accordion-item' );\n                    isclose = !close.hasClass( 'lyteAccordionActive' );\n                    if( !value ){\n                        isclose = !isclose\n                    }\n                    if( isclose ){\n                        close.click();\n                    }\n                  }\n\n                  for( var j = 0; j < hid.length; j++ ){\n                      var close = $L( hid[ j ] ).closest( 'lyte-accordion-item' )\n                      close.hasClass( 'lyteAccordionActive' ) && close.click();\n                  }\n              })\n        }\n\n        function treeinremove ( arr ){\n            for( var i = 0; i < arr.length; i++ ){\n                if( arr[ i + 1 ] ){\n                  var cur = $L( arr[ i ] ).closest( '.lyteTreeBodyDiv' )[ 0 ], next = $L( arr[ i + 1 ] ).closest( '.lyteTreeBodyDiv' )[ 0 ];\n                  if( cur.contains( next ) ){\n                      arr.splice( i + 1, 1 );\n                  } else if(next.contains( cur ) ){\n                      arr.splice( i, 1 );\n                      i--;\n                  }\n                }\n            }\n        }\n\n        function treefilter( vis, hid, value, clear ){\n          var scope = $L( getScope( this, this._searchPluginData.scope ) )[ 0 ];\n          for( var i = 0; i < vis.length; i++ ){\n            var cur = $L( vis[ i ] ).closest( '.lyteTreeBodyDiv' );\n            for( var j = 0; j < hid.length; j++ ){\n              var hide = $L( hid[ j ] ).closest( '.lyteTreeBodyDiv' ),\n              flg = cur[ 0 ].contains( hide[ 0 ] ) || hide[ 0 ].contains( cur[ 0 ] );\n              if( flg ){\n                  hide.addClass( 'lyteSearchHidden' );\n                  hid.splice( j, 1 );\n                  j--;\n              }\n            }\n          }\n          for( var i = 0; i < vis.length; i++ ){\n            removeClse( vis[ i ], scope )\n            value.length && scope.ltProp( 'stateAttr', $L( vis[ i ] ).closest( 'lyte-tree-body' ).attr( 'data-value' ) )\n          }\n          if( value.length ) {\n            for( var i = 0; i < hid.length; i++ ){\n              $L( hid[ i ] ).closest( '.lyteTreeBodyDiv' ).addClass( 'lyteSearchHidden' )\n            }\n          } else {\n            hiderecurse( $L( 'lyte-yield:not(.noChildClass) lyte-tree-icon', scope ), clear );\n          }\n        }\n\n        function removeClse( target, scope ){\n            var el = $L( target ).closest( '.lyteSearchHidden', scope );\n            if( el.length ){\n              el.removeClass( 'lyteSearchHidden' );\n              removeClse( target, scope );\n            }\n        }\n\n        function additionalHand( target, check, val ){\n            var query = this._searchPluginData, comp = query.component;\n            if( check ){\n                if( comp == 'dropdown' ){\n                  var clo = $L( target ).closest( 'lyte-drop-box' )[ 0 ] \n                  if( clo ) {\n                    clo.classList.contains( 'lyteDropdownHidden' ) && ( clo.origindd ? clo.origindd.toggle() : $L( clo ).closest( 'lyte-dropdown' ).get( 0 ).toggle() )\n                  }\n                } \n              target.classList.remove( 'lyteSearchHidden' );\n            } else if( comp != \"tree\" ) {\n              if( target.classList.contains( 'lyteSearchHidden' ) ){\n                  return;\n              }\n              target.classList.add( 'lyteSearchHidden' );\n            }\n        }\n\n        $L.prototype.search = function( data ){\n            data = data ? data : {};\n            if(!data.scope)\n                {\n                    console.error('scope is not given');\n                    return;\n                }\n            // var scope = typeof data.scope == 'string' ? document.body.querySelector( data.scope.trim() ) : data.scope;    \n            var element = this[ 0 ]\n            var searchList = [], targetList = [], searchComp = [];\n            element._searchPluginData = data;\n\n            if( !data.hasOwnProperty( 'searchDelay' ) ){\n              data.searchDelay = 100;\n            }\n\n            if( data.component == \"accordion\" ){\n              data.related = \"lyte-accordion-item\";\n            } else if( data.component == \"tree\" ){\n              data.related = \".lyteTreeBodyDiv lyte-yield:not(.noChildClass) lyte-tree-icon\";\n            }\n\n            element.setValueForSearch = element.setValue = function(value){\n                var element = this\n                value = value != undefined ? value : '';\n                element.tagName == 'LYTE-INPUT' ? element.ltProp({'value' : value}) : element.value = value;\n                var evt = new Event('keyup');\n                evt.which = evt.keyCode = 8;\n                element.dispatchEvent(evt);\n            }\n\n        element.addEventListener('keyup', keyUpBind ); \n\n        element.addEventListener( 'input', inputBind);\n        element.reset = pressFunc.bind( element );                  \n        return this;\n      }\n\n      $L.prototype.removeSearch = function(){\n          var removeElements = this;\n\n          for( var i = 0; i < removeElements.length; i++ ){\n              var current = removeElements[ i ],\n              scope, search, related;\n              if( !current._searchPluginData ){\n                continue;\n              }\n\n              delete current.reset; \n              scope = current._searchPluginData.scope;\n              search = current._searchPluginData.target || current._searchPluginData.search;\n              related = current._searchPluginData.related;\n              if( !scope ){\n                continue;\n              }\n              scope = $L( getScope( current, scope ) );\n              scope.find( search ).removeClass( 'lyteSearchHidden' );\n              related && scope.find( related ).removeClass( 'lyteSearchHidden' );\n              delete current._searchPluginData;\n              delete current.setValueForSearch; delete current.setValue;\n\n              current.removeEventListener( 'input', inputBind );\n              current.removeEventListener( 'keyup', keyUpBind );\n          }\n          return this;\n      }\n    }\n});\n"],"names":[],"sourceRoot":""}