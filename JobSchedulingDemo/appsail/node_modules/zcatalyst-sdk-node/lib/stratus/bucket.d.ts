/// <reference types="node" />
/// <reference types="node" />
import { AuthorizedHttpClient } from '../utils/api-request';
import { StratusObject } from './object';
import { ICatalystObjects, ICatalystBucket, ICatalystCorsRes, ICatalystObjectDetails, ICatalystPagedObjectOptions, ICatalystPreSignedUrlOptions, ICatalystPutObjectOptions, ICatalystUnzipRes, ICatalystObjectRenameRes, ICatalystMultipartSummaryRes, ICatalystInitiateUpload } from '../utils/pojo/stratus';
import Stratus from '.';
import { Readable, Stream } from 'stream';
export declare class Bucket {
    #private;
    bucketDetails: ICatalystBucket;
    auth: boolean;
    constructor(stratusInstance: Stratus, bucket: ICatalystBucket | string);
    getAuthorizationClient(): AuthorizedHttpClient;
    /**
     * Get the bucket name.
     * @returns name of the bucket
     */
    getName(): string;
    /**
     * List the objects and it's details in the bucket by pagination.
     * @param options ICatalystPagedObjectOptions to be applied for the list objects operation.
     * @returns ICatalystObjects.
     */
    listPagedObjects({ folderListing, ...options }?: ICatalystPagedObjectOptions): Promise<ICatalystObjects>;
    /**
     * List the objects and its details in the bucket as iterable.
     * @param prefix given prefixed objects to be returned.
     * @param maxKeys number of objects returned.
     * @returns AsyncGenerator<StratusObject, void>.
     */
    listIterableObjects({ prefix, maxKeys }?: {
        prefix?: string;
        maxKeys?: string;
    }): AsyncGenerator<StratusObject, void>;
    /**
     * Get the details of the given bucket.
     * @returns ICatalystBucket.
     */
    getDetails(): Promise<ICatalystBucket>;
    /**
     * Delete all the objects in the bucket
     * @returns boolean.
     */
    truncate(): Promise<boolean>;
    /**
     * Copy the given object to destination.
     * @param objectName name of the source object.
     * @param destObject name of the destination object.
     * @example
     * ```js
     * const sourceObject = 'sam/out/temp.txt';
     * const destObject = 'out/sam/temp.txt';
     * // invoke copy operation
     * const copyObjectRes = await bucket.copyObject(sourceObject, destObject);
     * console.log(copyObjectRes);
     * ```
     * @returns ICatalystUnzipRes.
     */
    copyObject(objectName: string, destObject: string): Promise<ICatalystUnzipRes>;
    /**
     * Renames an existing object in the bucket.
     * @param objectName name of the source object.
     * @param destObject name of the destination object.
     * @example
     * ```js
     * const sourceObject = 'sam/out/temp.txt';
     * const destObject = 'out/sam/temp.txt';
     * // invoke rename operation
     * const renameObjectRes = await bucket.renameObjectObject(sourceObject, destObject);
     * console.log(renameObjectRes);
     * ```
     * @returns ICatalystObjectRenameRes.
     */
    renameObject(objectName: string, destObject: string): Promise<ICatalystObjectRenameRes>;
    /**
     * Generate pre signed url for the given object
     * @param objectName name of the object.
     * @param urlAction provide the method based on the operation(put/get) performed.
     * @param signedUrlOptions to be applied when generating a pre signed url.
     * @example
     * ```js
     * const objectName = 'sam/out/temp.txt';
     * // signed url options
     * const options = {
     * 		'expiry_in_seconds': '3000',
     * 		'active_from':'23736279382'
     * }
     * // generate presigned url
     * const preSignedUrlRes = await bucket.generatePreSignedUrl(objectName, 'GET', options);
     * console.log(preSignedUrlRes);
     * ```
     * @returns { accessUrl: string }.
     */
    generatePreSignedUrl(objectName: string, urlAction: 'PUT' | 'GET', signedUrlOptions?: ICatalystPreSignedUrlOptions): Promise<{
        accessUrl: string;
    }>;
    /**
     * Delete the given path and it's objects in the bucket
     * @param path to be deleted.
     * @example
     * ```js
     * const path = 'sam/';
     * // invoke delete path operation
     * const pathDeleteRes = await bucket.deletePath(path);
     * console.log(pathDeleteRes);
     * ```
     * @returns ICatalystObjectDetails.
     */
    deletePath(path: string): Promise<ICatalystObjectDetails>;
    /**
     * Clear all the cached items in the bucket.
     * @param path path to be cleared.
     * @example
     * ```js
     * const path = ['sam', 'out/sam/temp.txt'];
     * // invoke purge cache operation
     * const purgeCacheRes = await bucket.purgeCache(path);
     * console.log(purgeCacheRes);
     * ```
     * @returns ICatalystObjectDetails.
     */
    purgeCache(path?: Array<string>): Promise<ICatalystObjectDetails>;
    /**
     * Download the object in the bucket.
     * @param objectName Name of the object.
     * @param getObjectOptions to be applied when download operation performed.
     *  @example
     * ```js
     * const objectName = 'out/sam/temp.txt';
     * const options = {
     * 		'versionId': 'bfjd673e2hgh2',
     * 		'range': '0-200'
     * }
     * // invoke object download operation
     * const getObjectRes = await bucket.getObject(objectName, options);
     * ```
     * @returns Readable object as stream.
     */
    getObject(objectName: string, { range, versionId }?: {
        range?: string;
        versionId?: string;
    }): Promise<Readable>;
    /**
     * Delete a object in the bucket.
     * @param objectName Name of the object.
     * @param versionId Id of the object.
     * @param ttl time to live in seconds.
     * @example
     * ```js
     * const objectName = 'out/sam/temp.txt';
     * const options = {
     * 		'versionId': 'bfjd673e2hgh2',
     * 		'ttl': 300 // in seconds
     * }
     * // invoke object deletion operation
     * const deleteObjectRes = await bucket.deleteObject(objectName, options);
     * console.log(deleteObjectRes);
     * ```
     * @returns Record<string, string>.
     */
    deleteObject(objectName: string, { versionId, ttl }?: {
        versionId?: string;
        ttl?: number;
    }): Promise<Record<string, string>>;
    /**
     * Delete multiple objects in the bucket.
     * @param objects to be deleted.
     * @param ttl in seconds. The object will not be deleted immediately,
     * but only after the specified amount of time.
     * @example
     * ```js
     * const objects = [
     * 		{
     * 			'objectName': 'out1/sam1/temp1.txt',
     * 			'versionId': 'jsdbe6738y3bje'
     * 		},
     * 		{
     * 			'objectName': 'out2/sam2/temp2.txt',
     * 			'versionId': '34mnkejh89f9'
     * 		}
     * ];
     * const ttl = 1000;
     * // invoke objects deletion operation
     * const deleteObjectsRes = await bucket.deleteObjects(objects, ttl);
     * console.log(deleteObjectsRes);
     * ```
     * @returns Record<string, string>.
     */
    deleteObjects(objects: Array<{
        objectName: string;
        versionId?: string;
    }>, ttl?: number): Promise<Record<string, string>>;
    /**
     * Upload an object to the bucket
     * @param objectName name of the object.
     * @param objectData body of the object.
     * @param uploadOptions to be applied while uploading object to the bucket.
     * @example
     * ```js
     * const objectName = 'out1/sam1/temp1.txt';
     * const objectData = fs.createReadStream('/user/alwind/sam/sample.txt');
     * const options = {
     * 		'overwritte': 'true',
     * 		'expiresAfter': '2000' // it will be deleted after the give time.
     * };
     * // upload an object
     * const putObjectRes = await bucket.putObject(objectName, objectData, options);
     * console.log(putObjectRes);
     * ```
     * @returns 'true' if upload success else return 'false'
     */
    putObject(objectName: string, objectData: Stream | Buffer | string, uploadOptions?: ICatalystPutObjectOptions): Promise<boolean>;
    /**
     * Extract the zip object and upload all the files inside it as individual objects to the same bucket.
     * @param objectName name of the object.
     * @param destPath path to be unzipped.
     * @example
     * ```js
     * const objectName = 'out/sam/temp.zip';
     * const destPath = 'sam/out/';
     * // invoke zip extraction operation
     * const unzipObjectRes = await bucket.unzipObject(objectName, destPath);
     * console.log(unzipObjectRes);
     * ```
     * @returns ICatalystUnzipRes.
     */
    unzipObject(objectName: string, destPath: string): Promise<ICatalystUnzipRes>;
    /**
     * Get the status of the unzipObject operation.
     * @param objectName name of the object.
     * @param taskId Id to find the status of unzip task.
     * @example
     * ```js
     * const objectName = 'out/sam/temp.zip';
     * const taskId = '4384292001930123';
     * // get the status of zip extraction
     * const getUnzipStatusRes = await bucket.getUnzipStatus(objectName, taskId);
     * console.log(getUnzipStatusRes);
     * ```
     * @returns Record<string, string>.
     */
    getUnzipStatus(objectName: string, taskId: string): Promise<Record<string, string>>;
    /**
     * Get the CORS details of the bucket
     * @returns response of the get cors operation.
     */
    getCors(): Promise<Array<ICatalystCorsRes>>;
    /**
     * Check whether a specific object is existing and also whether the given user has permission to access the object.
     * @param objectName Name that uniquely identifies the object within this bucket.
     * @param versionId Id of the object in case of a versioning enabled bucket.
     * @param throwErr throw error if the object doesn't exist.
     * @example
     * ```js
     * const objectName = 'out1/sam1/temp1.txt';
     * // check the availabilty of the object.
     * const headObjecttRes = await bucket.headObject(objectName, { versionId: 'dskjhgdfue627', throwErr: false });
     * console.log(headObjecttRes);
     * ```
     * @returns return 'true' if it exist else return false
     */
    headObject(objectName: string, { versionId, throwErr }?: {
        versionId?: string;
        throwErr?: boolean;
    }): Promise<boolean>;
    /**
     * Initiate the multipart upload.
     * @param objectName name of the object.
     * @returns details of the initiated object.
     */
    initiateMultipartUpload(objectName: string): Promise<ICatalystInitiateUpload>;
    /**
     * Upload the individual parts of the file, with a distinct part number.
     * @param objectName Name of the object.
     * @param uploadId Id of the particular upload.
     * @param objectData to be uploaded.
     * @param partNumber part number can be between 1 and 1000. It represent the ordering of the parts.
     * The parts can be uploaded in any order.
     * @returns return 'true' if completed successfully else return 'false'.
     */
    uploadPart(objectName: string, uploadId: string, objectData: Stream | Buffer, partNumber: number, overwrite?: string): Promise<boolean>;
    /**
     * Complete the multipart upload, after all parts are uploaded.
     * @param objectName Name of the object.
     * @param uploadId Id of the particular upload.
     * @returns return 'true' if completed successfully else return 'false'.
     */
    completeMultipartUpload(objectName: string, uploadId: string): Promise<boolean>;
    /**
     * Get a summary of the uploaded parts.
     * @param objectName Name of the object.
     * @param uploadId Id of the particular upload.
     * @returns ICatalystMultipartSummaryRes.
     */
    getMultipartUploadSummary(objectName: string, uploadId: string): Promise<ICatalystMultipartSummaryRes>;
    /**
     * Get the object instance.
     *  @param objectName name of the object.
     * @returns instance of the object.
     */
    object(objectName: string): StratusObject;
    toString(): string;
    toJSON(): ICatalystBucket;
}
