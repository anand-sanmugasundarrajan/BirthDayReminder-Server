"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const error_1 = __importDefault(require("../../../../error"));
const constants_1 = require("../../../../util_modules/constants");
const fs_1 = require("../../../../util_modules/fs");
const logger_1 = require("../../../../util_modules/logger");
const project_1 = require("../../../../util_modules/project");
const shell_1 = require("../../../../util_modules/shell");
const endpoints_1 = require("../../../../endpoints");
const archiver_1 = __importDefault(require("../../../../archiver"));
const option_1 = require("../../../../util_modules/option");
const execute_script_1 = require("../../../../execute-script");
const master_1 = __importDefault(require("../master"));
const ansi_colors_1 = require("ansi-colors");
const common_1 = require("../../../../init/util/common");
function executeHook(script, name, moduleSource) {
    if ((0, option_1.getOptionValue)('ignoreScripts', false)) {
        (0, logger_1.debug)(`skipping ${name} hook`);
        return;
    }
    (0, execute_script_1.executeCommand)(script, { moduleSource, feature: name });
}
const startAppSail = (port, opts) => {
    const startScriptPath = (0, path_1.join)(__dirname, 'start.js');
    const _opts = [startScriptPath, '-t', opts.type];
    if (opts.command) {
        _opts.push('-c', opts.command);
    }
    const child = (0, shell_1.spawn)('node', _opts, {
        cwd: opts.target,
        stdio: 'pipe',
        env: Object.assign({ X_ZOHO_CATALYST_LISTEN_PORT: port + '', X_ZOHO_CATALYST_RUNTIME_MEMORY: opts.memory + '', X_ZOHO_CATALYST_ACCOUNTS_URL: constants_1.ORIGIN.auth, X_ZOHO_CATALYST_CONSOLE_URL: constants_1.ORIGIN.admin, X_ZOHO_STRATUS_RESOURCE_SUFFIX: constants_1.ORIGIN.stratusSuffix, X_ZOHO_CATALYST_IS_LOCAL: 'true', X_ZC_RESOURCE_NAME: opts.name + '', CATALYST_PROJECT_TIMEZONE: (0, project_1.getProjectTimezone)(Intl.DateTimeFormat().resolvedOptions().timeZone) }, (opts.env || {}))
    }).RAW();
    return new Promise((_res, _rej) => {
        child.on('spawn', () => _res(child));
        child.on('error', (reason) => _rej(reason));
    });
};
exports.default = (serverDetails) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d, _e, _f, _g;
    let child;
    const targetSail = serverDetails.target;
    if (!targetSail || !targetSail.config) {
        throw new error_1.default('AppSail details not found');
    }
    if ((_a = targetSail.config.scripts) === null || _a === void 0 ? void 0 : _a.preserve) {
        executeHook(targetSail.config.scripts.preserve, `AppSail [PRESERVE] [${targetSail.name}]`, targetSail.source);
    }
    const buildPath = (_b = targetSail.config) === null || _b === void 0 ? void 0 : _b.build_path;
    const target = (yield fs_1.ASYNC.fileExists(buildPath)) ? (0, path_1.dirname)(buildPath) : buildPath;
    if (!(yield fs_1.ASYNC.isPathExists(target))) {
        if ((0, path_1.isAbsolute)(((_c = targetSail.config) === null || _c === void 0 ? void 0 : _c.raw.build_path) || '')) {
            throw new error_1.default('The given AppSail build path does not exists', {
                exit: 1,
                errorId: 'SERVE-APPSAIL-1',
                arg: [ansi_colors_1.italic.underline.red(target), (0, ansi_colors_1.bold)(targetSail.name)]
            });
        }
        throw new error_1.default('The given AppSail build path does not exists: ' + targetSail.name, {
            exit: 1,
            errorId: 'SERVE-APPSAIL-2',
            arg: [
                (0, ansi_colors_1.underline)(((_d = targetSail.config) === null || _d === void 0 ? void 0 : _d.raw.build_path) || ''),
                ansi_colors_1.italic.underline(targetSail.config.raw.source_path || ''),
                ansi_colors_1.italic.underline(((_e = targetSail.config) === null || _e === void 0 ? void 0 : _e.raw.build_path) || ''),
                ansi_colors_1.italic.underline(target)
            ]
        });
    }
    switch (true) {
        case targetSail.config.stack.startsWith('node'): {
            child = yield startAppSail(targetSail.port.appsail, {
                type: 'nodejs',
                target,
                command: targetSail.config.command,
                memory: targetSail.config.memory || 256,
                env: targetSail.config.env_variables,
                name: targetSail.name
            });
            break;
        }
        case targetSail.config.stack.startsWith('python'): {
            child = yield startAppSail(targetSail.port.appsail, {
                type: 'python',
                target,
                command: targetSail.config.command,
                memory: targetSail.config.memory || 256,
                env: targetSail.config.env_variables,
                name: targetSail.name
            });
            break;
        }
        case targetSail.config.stack.startsWith('java'): {
            if (targetSail.config.platform === 'war') {
                const jettyPath = (0, path_1.join)(constants_1.ENVPATH.runtimes.data, 'jetty');
                if (!(yield fs_1.ASYNC.fileExists((0, path_1.join)(jettyPath, 'start.jar')).catch((err) => (0, logger_1.debug)(err)))) {
                    try {
                        yield fs_1.ASYNC.ensureDir(jettyPath);
                        const appxAPI = yield (0, endpoints_1.appSailAPI)();
                        const jettyZip = yield appxAPI.downloadJetty();
                        const zip = new archiver_1.default();
                        zip.load(jettyZip);
                        zip.extract(jettyPath, '/', {
                            ignoreInitial: false,
                            isFolder: true
                        });
                        yield zip.finalize();
                    }
                    catch (err) {
                        (0, logger_1.debug)('Unable to ensure Jetty Runtime');
                        throw err;
                    }
                }
                const jettyCommand = `java -jar "${(0, path_1.join)(jettyPath, 'start.jar')}" -Djetty.deploy.monitoredPath="${(0, project_1.resolveProjectPath)(target)}" -Djetty.http.port=${targetSail.port.appsail}`;
                child = yield startAppSail(targetSail.port.appsail, {
                    target,
                    type: 'war',
                    command: jettyCommand,
                    memory: targetSail.config.memory || 256,
                    env: Object.assign({ JETTY_BASE: (0, path_1.join)(jettyPath, 'JETTY_BASE') }, targetSail.config.env_variables),
                    name: targetSail.name
                });
                break;
            }
            child = yield startAppSail(targetSail.port.appsail, {
                target,
                command: targetSail.config.command,
                type: 'javase',
                memory: targetSail.config.memory || 256,
                env: targetSail.config.env_variables,
                name: targetSail.name
            });
            break;
        }
        default: {
            const appSailRuntime = yield (0, common_1.getRuntimeDetails)();
            throw new error_1.default('Invalid AppSail stack', {
                exit: 1,
                errorId: 'SERVE-APPSAIL-4',
                arg: [
                    (0, ansi_colors_1.bold)(targetSail.name),
                    ansi_colors_1.bold.red(targetSail.config.stack),
                    appSailRuntime.runtimes.map((val) => (0, ansi_colors_1.bold)(`* ${val}`)).join('\n')
                ]
            });
        }
    }
    const masterServe = yield (0, master_1.default)(targetSail.port.proxy, {
        appSailDetails: serverDetails
    });
    child.once('exit', () => {
        masterServe.close((err) => {
            if (err) {
                (0, logger_1.debug)('Error stopping the AppSail proxy server: ', err);
            }
        });
    });
    if ((_g = (_f = targetSail.config) === null || _f === void 0 ? void 0 : _f.scripts) === null || _g === void 0 ? void 0 : _g.postserve) {
        child.once('exit', () => {
            var _a, _b, _c;
            if (!((_a = targetSail.config) === null || _a === void 0 ? void 0 : _a.scripts)) {
                return;
            }
            executeHook((_c = (_b = targetSail.config) === null || _b === void 0 ? void 0 : _b.scripts) === null || _c === void 0 ? void 0 : _c.postserve, `AppSail [POSTSERVE] [${targetSail.name}]`, targetSail.source);
        });
    }
    process.on('SIGINT', () => {
        targetSail.trigger.kill = true;
    });
    child.once('exit', (code) => {
        var _a, _b, _c;
        if (code === 150) {
            targetSail.validity = {
                valid: false,
                reason: 'Unable to start the AppSail'
            };
            throw new error_1.default('Unable to start the AppSail', {
                exit: 1,
                errorId: 'SERVE-APPSAIL-3',
                arg: [
                    (0, ansi_colors_1.bold)(targetSail.name),
                    ((_a = targetSail.config) === null || _a === void 0 ? void 0 : _a.command) || '',
                    (0, ansi_colors_1.underline)(((_b = targetSail.config) === null || _b === void 0 ? void 0 : _b.build_path) || ''),
                    ((_c = targetSail.config) === null || _c === void 0 ? void 0 : _c.stack) || ''
                ]
            });
        }
    });
    return child;
});
